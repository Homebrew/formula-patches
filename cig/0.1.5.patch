From f5ae27b19863e3cb6b73ca4d42560fec52ddea60 Mon Sep 17 00:00:00 2001
From: Steven Jack <stevenmajack@gmail.com>
Date: Sun, 4 Oct 2015 14:41:20 +0100
Subject: [PATCH 1/4] Closes #37 - User docker-compose to run and build project

---
 .gitignore         |  1 +
 Makefile           | 10 ++++++++--
 docker-compose.yml | 14 +++++++++++---
 3 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/.gitignore b/.gitignore
index 3b9e1ae..3f4ead7 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,3 +23,4 @@ _testmain.go
 *.test
 *.prof
 cig_*
+.cig.yaml
diff --git a/Makefile b/Makefile
index e810253..7bd9136 100644
--- a/Makefile
+++ b/Makefile
@@ -1,8 +1,8 @@
 VERISON ?= ""
 TYPE ?= ""
 
-PHONY: bump
-SILENT: bump
+PHONY: bump run build
+SILENT: bump run build
 
 current_version:
 	$(eval CURRENT_VERSION:=$(shell cat VERSION))
@@ -28,3 +28,9 @@ push:
 	git push origin --tags
 
 bump: update_files commit tag
+
+run:
+	docker-compose run dev
+
+build:
+	docker-compose run build
diff --git a/docker-compose.yml b/docker-compose.yml
index bfb4146..ad41fb5 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -1,8 +1,16 @@
-dev:
+common: &common
   build: .
-  command: gox
   working_dir: /go/src/github.com/stevenjack/cig
+
+dev:
+  <<: *common
+  command: go run cig.go --cp /go/src/github.com/stevenjack/cig
   volumes:
     - .:/go/src/github.com/stevenjack/cig
     - ~/Projects:/projects
-    - ~/.cig.yaml:/root/.cig.yaml
+
+build:
+  <<: *common
+  command: gox
+  volumes:
+    - .:/go/src/github.com/stevenjack/cig
-- 
2.29.2


From bb9334597869d47d05467403556296936be1a3b2 Mon Sep 17 00:00:00 2001
From: Steven Jack <stevenmajack@gmail.com>
Date: Sun, 4 Oct 2015 14:54:41 +0100
Subject: [PATCH 2/4] Closes #38 - Refactor variable names, in line with go
 convention

---
 app/app.go    | 10 +++++-----
 app/config.go | 16 ++++++++--------
 cig.go        | 22 +++++++++++-----------
 repo/repo.go  | 34 +++++++++++++++++-----------------
 4 files changed, 41 insertions(+), 41 deletions(-)

diff --git a/app/app.go b/app/app.go
index 9a0f8d3..786c62d 100644
--- a/app/app.go
+++ b/app/app.go
@@ -13,30 +13,30 @@ import (
 	"github.com/stevenjack/cig/repo"
 )
 
-func Handle(repoList map[string]string, projectTypeToCheck string, filter string, output_channel chan output.Payload) {
+func Handle(repoList map[string]string, projectTypeToCheck string, filter string, outputChannel chan output.Payload) {
 	var wg sync.WaitGroup
 
 	for projectType, path := range repoList {
 		if projectTypeToCheck == "" || projectTypeToCheck == projectType {
-			output_channel <- output.Print(fmt.Sprintf("\nChecking '%s' (%s) repos...", projectType, path))
+                        outputChannel <- output.Print(fmt.Sprintf("\nChecking '%s' (%s) repos...", projectType, path))
 			path = resolvePath(path)
 
 			visit := func(visitedPath string, info os.FileInfo, err error) error {
 				if err != nil {
-					output_channel <- output.Error(fmt.Sprintf("- %s", err.Error()))
+                                        outputChannel <- output.Error(fmt.Sprintf("- %s", err.Error()))
 					return nil
 				}
 				matched, _ := regexp.MatchString(filter, visitedPath)
 				if info.IsDir() && (filter == "" || matched) {
 					wg.Add(1)
-					go repo.Check(path, visitedPath, output_channel, &wg)
+                                        go repo.Check(path, visitedPath, outputChannel, &wg)
 				}
 				return nil
 			}
 
 			err := filepath.Walk(path, visit)
 			if err != nil {
-				output_channel <- output.Error(err.Error())
+                                outputChannel <- output.Error(err.Error())
 			}
 		}
 
diff --git a/app/config.go b/app/config.go
index 5ddef43..ff6b95b 100644
--- a/app/config.go
+++ b/app/config.go
@@ -10,30 +10,30 @@ import (
 	"github.com/stevenjack/cig/Godeps/_workspace/src/gopkg.in/yaml.v2"
 )
 
-func Config(config_path string) (map[string]string, error) {
-	repo_list := make(map[string]string)
-	home_dir, err := homedir.Dir()
+func Config(configPath string) (map[string]string, error) {
+        repoList := make(map[string]string)
+        homeDir, err := homedir.Dir()
 
-	if config_path != "" {
-		home_dir = config_path
+        if configPath != "" {
+                homeDir = configPath
 	}
 
 	if err != nil {
 		return nil, errors.New("Couldn't determine home directory")
 	}
 
-	path := filepath.Join(home_dir, ".cig.yaml")
+        path := filepath.Join(homeDir, ".cig.yaml")
 	data, err := ioutil.ReadFile(path)
 
 	if err != nil {
 		return nil, errors.New(fmt.Sprintf("Can't find config '%s'", path))
 	}
 
-	err = yaml.Unmarshal([]byte(data), &repo_list)
+        err = yaml.Unmarshal([]byte(data), &repoList)
 
 	if err != nil {
 		return nil, errors.New(fmt.Sprintf("Problem parsing '%s', please check documentation", path))
 	}
 
-	return repo_list, nil
+        return repoList, nil
 }
diff --git a/cig.go b/cig.go
index 374ec55..1bca219 100644
--- a/cig.go
+++ b/cig.go
@@ -11,28 +11,28 @@ import (
 const version string = "0.1.5"
 
 func main() {
-	var output_channel = make(chan output.Payload)
+        var outputChannel = make(chan output.Payload)
 
-	go output.Wait(output_channel)
-	cli_wrapper := main_app()
+        go output.Wait(outputChannel)
+        cliWrapper := mainApp()
 
-	cli_wrapper.Action = func(context *cli.Context) {
-		config_path := context.String("config-path")
-		project_type := context.String("type")
+        cliWrapper.Action = func(context *cli.Context) {
+                configPath := context.String("config-path")
+                projectType := context.String("type")
 		filter := context.String("filter")
-		repo_list, err := app.Config(config_path)
+                repoList, err := app.Config(configPath)
 
 		if err != nil {
-			output_channel <- output.FatalError(err.Error())
+                        outputChannel <- output.FatalError(err.Error())
 		}
 
-		app.Handle(repo_list, project_type, filter, output_channel)
+                app.Handle(repoList, projectType, filter, outputChannel)
 	}
 
-	cli_wrapper.Run(os.Args)
+        cliWrapper.Run(os.Args)
 }
 
-func main_app() *cli.App {
+func mainApp() *cli.App {
 	app := cli.NewApp()
 	app.Name = "cig"
 	app.Usage = "cig (Can I go?) checks all your git repos to see if they're in the state you want them to be"
diff --git a/repo/repo.go b/repo/repo.go
index 9ebaecb..697caca 100644
--- a/repo/repo.go
+++ b/repo/repo.go
@@ -12,7 +12,7 @@ import (
 	"github.com/stevenjack/cig/output"
 )
 
-func Check(root string, path string, output_channel chan output.Payload, wg *sync.WaitGroup) {
+func Check(root string, path string, outputChannel chan output.Payload, wg *sync.WaitGroup) {
 	defer wg.Done()
 	exists, err := Exists(filepath.Join(path, ".git"))
 
@@ -21,52 +21,52 @@ func Check(root string, path string, output_channel chan output.Payload, wg *syn
 	}
 
 	if exists {
-		modified_files := exec.Command("git", "status", "--porcelain")
-		modified_files.Dir = path
+                modifiedFiles := exec.Command("git", "status", "--porcelain")
+                modifiedFiles.Dir = path
 
-		count_out, _ := modified_files.Output()
-		modified_lines := strings.Split(string(count_out), "\n")
-		modified := len(modified_lines) - 1
+                countOut, _ := modifiedFiles.Output()
+                modifiedLines := strings.Split(string(countOut), "\n")
+                modified := len(modifiedLines) - 1
 
 		if err != nil {
-			output_channel <- output.FatalError(err.Error())
+                        outputChannel <- output.FatalError(err.Error())
 		}
 
 		changes := []string{}
 
-		if modified > 0 && modified_lines[0] != "" {
+                if modified > 0 && modifiedLines[0] != "" {
 			changes = append(changes, output.ApplyColour(fmt.Sprintf(" M(%d)", modified), "red"))
 		}
 
 		branch := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
 		branch.Dir = path
 		bstdout, _ := branch.Output()
-		branch_name := strings.TrimSpace(string(bstdout[:]))
+                branchName := strings.TrimSpace(string(bstdout[:]))
 
-		local := exec.Command("git", "rev-parse", branch_name)
+                local := exec.Command("git", "rev-parse", branchName)
 		local.Dir = path
 		lstdout, _ := local.Output()
-		local_ref := strings.TrimSpace(string(lstdout[:]))
+                localRef := strings.TrimSpace(string(lstdout[:]))
 
-		remote := exec.Command("git", "rev-parse", fmt.Sprintf("origin/%s", branch_name))
+                remote := exec.Command("git", "rev-parse", fmt.Sprintf("origin/%s", branchName))
 		remote.Dir = path
 		rstdout, err := remote.Output()
-		remote_ref := strings.TrimSpace(string(rstdout[:]))
+                remoteRef := strings.TrimSpace(string(rstdout[:]))
 
-		if err == nil && remote_ref != local_ref {
+                if err == nil && remoteRef != localRef {
 			changes = append(changes, output.ApplyColour(" P", "blue"))
 		}
 
 		if len(changes) > 0 {
 			var buffer bytes.Buffer
 
-			repo_name := strings.Replace(path, fmt.Sprintf("%s%s", root, string(os.PathSeparator)), "", -1)
+                        repoName := strings.Replace(path, fmt.Sprintf("%s%s", root, string(os.PathSeparator)), "", -1)
 
-			buffer.WriteString(fmt.Sprintf("- %s (%s)", repo_name, branch_name))
+                        buffer.WriteString(fmt.Sprintf("- %s (%s)", repoName, branchName))
 			for _, change := range changes {
 				buffer.WriteString(change)
 			}
-			output_channel <- output.Print(buffer.String())
+                        outputChannel <- output.Print(buffer.String())
 		}
 
 	}
-- 
2.29.2


From ca5cb255a0c8a8f3e2d9dd0ec38bb556dd999d01 Mon Sep 17 00:00:00 2001
From: Steven Jack <stevenmajack@gmail.com>
Date: Sun, 27 Dec 2015 10:55:10 +0000
Subject: [PATCH 3/4] Closes #39 - Adds tests for config

---
 app/config_test.go              | 40 +++++++++++++++++++++++++++++++++
 build/ci.sh                     |  2 +-
 test/fixtures/invalid/.cig.yaml |  4 ++++
 test/fixtures/valid/.cig.yaml   |  2 ++
 4 files changed, 47 insertions(+), 1 deletion(-)
 create mode 100644 app/config_test.go
 create mode 100644 test/fixtures/invalid/.cig.yaml
 create mode 100644 test/fixtures/valid/.cig.yaml

diff --git a/app/config_test.go b/app/config_test.go
new file mode 100644
index 0000000..9678a1e
--- /dev/null
+++ b/app/config_test.go
@@ -0,0 +1,40 @@
+package app
+
+import (
+	"fmt"
+	"os"
+	"path/filepath"
+	"testing"
+
+	"github.com/stevenjack/cig/app"
+)
+
+func TestMapReturnedFromCigYaml(t *testing.T) {
+	repoList, err := config("valid")
+
+	if err != nil {
+		t.Error(fmt.Sprintf("return of app.Config should be of type 'map[string]string, got: %s", repoList))
+	}
+}
+
+func TestErrorRaisedWhenConfigDoesNotExist(t *testing.T) {
+	_, err := config("cig_doesnt_exist_path")
+
+	if err == nil {
+		t.Error("app.Config should raise error with invalid path")
+	}
+}
+
+func TestMalformedYamlRasiesError(t *testing.T) {
+	_, err := config("invalid")
+
+	if err == nil {
+		t.Error("app.Config should raise error with invalid yaml")
+	}
+}
+
+func config(config_path string) (map[string]string, error) {
+	cwd, _ := os.Getwd()
+	path := filepath.Join(cwd, "..", "test", "fixtures", config_path)
+	return app.Config(path)
+}
diff --git a/build/ci.sh b/build/ci.sh
index d8c1c80..f6317cd 100755
--- a/build/ci.sh
+++ b/build/ci.sh
@@ -1,6 +1,6 @@
 #!/bin/bash
 
-go test
+go test */**_test.go
 
 if [[ $TRAVIS_TAG =~ ^v[0-9\.]+ ]]; then
   go get github.com/mitchellh/gox
diff --git a/test/fixtures/invalid/.cig.yaml b/test/fixtures/invalid/.cig.yaml
new file mode 100644
index 0000000..b7e21b8
--- /dev/null
+++ b/test/fixtures/invalid/.cig.yaml
@@ -0,0 +1,4 @@
+*
+& ^%
+  foo: /test/path
+bar: /another/test/path
diff --git a/test/fixtures/valid/.cig.yaml b/test/fixtures/valid/.cig.yaml
new file mode 100644
index 0000000..70a0b64
--- /dev/null
+++ b/test/fixtures/valid/.cig.yaml
@@ -0,0 +1,2 @@
+foo: /test/path
+bar: /another/test/path
-- 
2.29.2


From f0e78f0ae0e47adda463efda60d592acc3fad7f1 Mon Sep 17 00:00:00 2001
From: loyalsoldier <10487845+Loyalsoldier@users.noreply.github.com>
Date: Sat, 12 Dec 2020 02:40:04 +0800
Subject: [PATCH 4/4] Comply with Golang semantic import versioning

---
 Godeps/Godeps.json                            |   27 -
 Godeps/Readme                                 |    5 -
 Godeps/_workspace/.gitignore                  |    2 -
 .../github.com/codegangsta/cli/.travis.yml    |    6 -
 .../src/github.com/codegangsta/cli/LICENSE    |   21 -
 .../src/github.com/codegangsta/cli/README.md  |  298 --
 .../src/github.com/codegangsta/cli/app.go     |  321 --
 .../github.com/codegangsta/cli/app_test.go    |  622 ----
 .../cli/autocomplete/bash_autocomplete        |   13 -
 .../cli/autocomplete/zsh_autocomplete         |    5 -
 .../src/github.com/codegangsta/cli/cli.go     |   19 -
 .../github.com/codegangsta/cli/cli_test.go    |  100 -
 .../src/github.com/codegangsta/cli/command.go |  177 --
 .../codegangsta/cli/command_test.go           |   49 -
 .../src/github.com/codegangsta/cli/context.go |  344 ---
 .../codegangsta/cli/context_test.go           |  111 -
 .../src/github.com/codegangsta/cli/flag.go    |  454 ---
 .../github.com/codegangsta/cli/flag_test.go   |  742 -----
 .../src/github.com/codegangsta/cli/help.go    |  215 --
 .../codegangsta/cli/helpers_test.go           |   19 -
 .../src/github.com/fatih/color/.travis.yml    |    2 -
 .../src/github.com/fatih/color/LICENSE.md     |   20 -
 .../src/github.com/fatih/color/README.md      |  119 -
 .../src/github.com/fatih/color/color.go       |  291 --
 .../src/github.com/fatih/color/color_test.go  |  129 -
 .../src/github.com/fatih/color/doc.go         |   91 -
 .../github.com/mitchellh/go-homedir/LICENSE   |   21 -
 .../github.com/mitchellh/go-homedir/README.md |   14 -
 .../mitchellh/go-homedir/homedir.go           |   84 -
 .../mitchellh/go-homedir/homedir_test.go      |   98 -
 .../github.com/shiena/ansicolor/.gitignore    |   26 -
 .../src/github.com/shiena/ansicolor/LICENSE   |   21 -
 .../src/github.com/shiena/ansicolor/README.md |   81 -
 .../github.com/shiena/ansicolor/ansicolor.go  |   17 -
 .../shiena/ansicolor/ansicolor/main.go        |   27 -
 .../shiena/ansicolor/ansicolor_ansi.go        |   17 -
 .../shiena/ansicolor/ansicolor_windows.go     |  315 --
 .../ansicolor/ansicolor_windows_test.go       |  220 --
 .../shiena/ansicolor/example_test.go          |   24 -
 .../shiena/ansicolor/export_test.go           |   19 -
 .../_workspace/src/gopkg.in/yaml.v2/LICENSE   |  188 --
 .../src/gopkg.in/yaml.v2/LICENSE.libyaml      |   31 -
 .../_workspace/src/gopkg.in/yaml.v2/README.md |  127 -
 .../_workspace/src/gopkg.in/yaml.v2/apic.go   |  742 -----
 .../_workspace/src/gopkg.in/yaml.v2/decode.go |  665 ----
 .../src/gopkg.in/yaml.v2/decode_test.go       |  902 ------
 .../src/gopkg.in/yaml.v2/emitterc.go          | 1685 ----------
 .../_workspace/src/gopkg.in/yaml.v2/encode.go |  290 --
 .../src/gopkg.in/yaml.v2/encode_test.go       |  434 ---
 .../src/gopkg.in/yaml.v2/parserc.go           | 1096 -------
 .../src/gopkg.in/yaml.v2/readerc.go           |  391 ---
 .../src/gopkg.in/yaml.v2/resolve.go           |  203 --
 .../src/gopkg.in/yaml.v2/scannerc.go          | 2710 -----------------
 .../_workspace/src/gopkg.in/yaml.v2/sorter.go |  104 -
 .../src/gopkg.in/yaml.v2/suite_test.go        |   12 -
 .../src/gopkg.in/yaml.v2/writerc.go           |   89 -
 .../_workspace/src/gopkg.in/yaml.v2/yaml.go   |  334 --
 .../_workspace/src/gopkg.in/yaml.v2/yamlh.go  |  716 -----
 .../src/gopkg.in/yaml.v2/yamlprivateh.go      |  173 --
 app/app.go                                    |   10 +-
 app/config.go                                 |   18 +-
 app/config_test.go                            |    4 +-
 cig.go                                        |   22 +-
 go.mod                                        |   12 +
 go.sum                                        |   17 +
 output/output.go                              |    2 +-
 repo/repo.go                                  |   32 +-
 67 files changed, 72 insertions(+), 16123 deletions(-)
 delete mode 100644 Godeps/Godeps.json
 delete mode 100644 Godeps/Readme
 delete mode 100644 Godeps/_workspace/.gitignore
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/.travis.yml
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/LICENSE
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/README.md
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/app.go
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/app_test.go
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/bash_autocomplete
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/zsh_autocomplete
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/cli.go
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/cli_test.go
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/command.go
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/command_test.go
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/context.go
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/context_test.go
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/flag.go
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/flag_test.go
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/help.go
 delete mode 100644 Godeps/_workspace/src/github.com/codegangsta/cli/helpers_test.go
 delete mode 100644 Godeps/_workspace/src/github.com/fatih/color/.travis.yml
 delete mode 100644 Godeps/_workspace/src/github.com/fatih/color/LICENSE.md
 delete mode 100644 Godeps/_workspace/src/github.com/fatih/color/README.md
 delete mode 100644 Godeps/_workspace/src/github.com/fatih/color/color.go
 delete mode 100644 Godeps/_workspace/src/github.com/fatih/color/color_test.go
 delete mode 100644 Godeps/_workspace/src/github.com/fatih/color/doc.go
 delete mode 100644 Godeps/_workspace/src/github.com/mitchellh/go-homedir/LICENSE
 delete mode 100644 Godeps/_workspace/src/github.com/mitchellh/go-homedir/README.md
 delete mode 100644 Godeps/_workspace/src/github.com/mitchellh/go-homedir/homedir.go
 delete mode 100644 Godeps/_workspace/src/github.com/mitchellh/go-homedir/homedir_test.go
 delete mode 100644 Godeps/_workspace/src/github.com/shiena/ansicolor/.gitignore
 delete mode 100644 Godeps/_workspace/src/github.com/shiena/ansicolor/LICENSE
 delete mode 100644 Godeps/_workspace/src/github.com/shiena/ansicolor/README.md
 delete mode 100644 Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor.go
 delete mode 100644 Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor/main.go
 delete mode 100644 Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor_ansi.go
 delete mode 100644 Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor_windows.go
 delete mode 100644 Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor_windows_test.go
 delete mode 100644 Godeps/_workspace/src/github.com/shiena/ansicolor/example_test.go
 delete mode 100644 Godeps/_workspace/src/github.com/shiena/ansicolor/export_test.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/LICENSE
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/LICENSE.libyaml
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/README.md
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/apic.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/decode.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/decode_test.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/emitterc.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/encode.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/encode_test.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/parserc.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/readerc.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/resolve.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/scannerc.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/sorter.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/suite_test.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/writerc.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/yaml.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/yamlh.go
 delete mode 100644 Godeps/_workspace/src/gopkg.in/yaml.v2/yamlprivateh.go
 create mode 100644 go.mod
 create mode 100644 go.sum

diff --git a/Godeps/Godeps.json b/Godeps/Godeps.json
deleted file mode 100644
index 895dc30..0000000
--- a/Godeps/Godeps.json
+++ /dev/null
@@ -1,27 +0,0 @@
-{
-        "ImportPath": "github.com/stevenjack/cig",
-        "GoVersion": "go1.4",
-        "Deps": [
-                {
-                        "ImportPath": "github.com/codegangsta/cli",
-                        "Comment": "1.2.0-95-g9b2bd2b",
-                        "Rev": "9b2bd2b3489748d4d0a204fa4eb2ee9e89e0ebc6"
-                },
-                {
-                        "ImportPath": "github.com/fatih/color",
-                        "Rev": "f952d5afece9417e6240c2b649c1ef84bc3b6299"
-                },
-                {
-                        "ImportPath": "github.com/mitchellh/go-homedir",
-                        "Rev": "1f6da4a72e57d4e7edd4a7295a585e0a3999a2d4"
-                },
-                {
-                        "ImportPath": "github.com/shiena/ansicolor",
-                        "Rev": "8368d3b31cf6f2c2464c7a91675342c9a0ac6658"
-                },
-                {
-                        "ImportPath": "gopkg.in/yaml.v2",
-                        "Rev": "d466437aa4adc35830964cffc5b5f262c63ddcb4"
-                }
-        ]
-}
diff --git a/Godeps/Readme b/Godeps/Readme
deleted file mode 100644
index 4cdaa53..0000000
--- a/Godeps/Readme
+++ /dev/null
@@ -1,5 +0,0 @@
-This directory tree is generated automatically by godep.
-
-Please do not edit.
-
-See https://github.com/tools/godep for more information.
diff --git a/Godeps/_workspace/.gitignore b/Godeps/_workspace/.gitignore
deleted file mode 100644
index f037d68..0000000
--- a/Godeps/_workspace/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-/pkg
-/bin
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/.travis.yml b/Godeps/_workspace/src/github.com/codegangsta/cli/.travis.yml
deleted file mode 100644
index baf46ab..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/.travis.yml
+++ /dev/null
@@ -1,6 +0,0 @@
-language: go
-go: 1.1
-
-script:
-- go vet ./...
-- go test -v ./...
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/LICENSE b/Godeps/_workspace/src/github.com/codegangsta/cli/LICENSE
deleted file mode 100644
index 5515ccf..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/LICENSE
+++ /dev/null
@@ -1,21 +0,0 @@
-Copyright (C) 2013 Jeremy Saenz
-All Rights Reserved.
-
-MIT LICENSE
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of
-this software and associated documentation files (the "Software"), to deal in
-the Software without restriction, including without limitation the rights to
-use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-the Software, and to permit persons to whom the Software is furnished to do so,
-subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/README.md b/Godeps/_workspace/src/github.com/codegangsta/cli/README.md
deleted file mode 100644
index 5e4a098..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/README.md
+++ /dev/null
@@ -1,298 +0,0 @@
-[![Build Status](https://travis-ci.org/codegangsta/cli.png?branch=master)](https://travis-ci.org/codegangsta/cli)
-
-# cli.go
-cli.go is simple, fast, and fun package for building command line apps in Go. The goal is to enable developers to write fast and distributable command line applications in an expressive way.
-
-You can view the API docs here:
-http://godoc.org/github.com/codegangsta/cli
-
-## Overview
-Command line apps are usually so tiny that there is absolutely no reason why your code should *not* be self-documenting. Things like generating help text and parsing command flags/options should not hinder productivity when writing a command line app.
-
-**This is where cli.go comes into play.** cli.go makes command line programming fun, organized, and expressive!
-
-## Installation
-Make sure you have a working Go environment (go 1.1 is *required*). [See the install instructions](http://golang.org/doc/install.html).
-
-To install `cli.go`, simply run:
-```
-$ go get github.com/codegangsta/cli
-```
-
-Make sure your `PATH` includes to the `$GOPATH/bin` directory so your commands can be easily used:
-```
-export PATH=$PATH:$GOPATH/bin
-```
-
-## Getting Started
-One of the philosophies behind cli.go is that an API should be playful and full of discovery. So a cli.go app can be as little as one line of code in `main()`.
-
-``` go
-package main
-
-import (
-  "os"
-  "github.com/codegangsta/cli"
-)
-
-func main() {
-  cli.NewApp().Run(os.Args)
-}
-```
-
-This app will run and show help text, but is not very useful. Let's give an action to execute and some help documentation:
-
-``` go
-package main
-
-import (
-  "os"
-  "github.com/codegangsta/cli"
-)
-
-func main() {
-  app := cli.NewApp()
-  app.Name = "boom"
-  app.Usage = "make an explosive entrance"
-  app.Action = func(c *cli.Context) {
-    println("boom! I say!")
-  }
-
-  app.Run(os.Args)
-}
-```
-
-Running this already gives you a ton of functionality, plus support for things like subcommands and flags, which are covered below.
-
-## Example
-
-Being a programmer can be a lonely job. Thankfully by the power of automation that is not the case! Let's create a greeter app to fend off our demons of loneliness!
-
-Start by creating a directory named `greet`, and within it, add a file, `greet.go` with the following code in it:
-
-``` go
-package main
-
-import (
-  "os"
-  "github.com/codegangsta/cli"
-)
-
-func main() {
-  app := cli.NewApp()
-  app.Name = "greet"
-  app.Usage = "fight the loneliness!"
-  app.Action = func(c *cli.Context) {
-    println("Hello friend!")
-  }
-
-  app.Run(os.Args)
-}
-```
-
-Install our command to the `$GOPATH/bin` directory:
-
-```
-$ go install
-```
-
-Finally run our new command:
-
-```
-$ greet
-Hello friend!
-```
-
-cli.go also generates some bitchass help text:
-```
-$ greet help
-NAME:
-    greet - fight the loneliness!
-
-USAGE:
-    greet [global options] command [command options] [arguments...]
-
-VERSION:
-    0.0.0
-
-COMMANDS:
-    help, h  Shows a list of commands or help for one command
-
-GLOBAL OPTIONS
-    --version	Shows version information
-```
-
-### Arguments
-You can lookup arguments by calling the `Args` function on `cli.Context`.
-
-``` go
-...
-app.Action = func(c *cli.Context) {
-  println("Hello", c.Args()[0])
-}
-...
-```
-
-### Flags
-Setting and querying flags is simple.
-``` go
-...
-app.Flags = []cli.Flag {
-  cli.StringFlag{
-    Name: "lang",
-    Value: "english",
-    Usage: "language for the greeting",
-  },
-}
-app.Action = func(c *cli.Context) {
-  name := "someone"
-  if len(c.Args()) > 0 {
-    name = c.Args()[0]
-  }
-  if c.String("lang") == "spanish" {
-    println("Hola", name)
-  } else {
-    println("Hello", name)
-  }
-}
-...
-```
-
-#### Alternate Names
-
-You can set alternate (or short) names for flags by providing a comma-delimited list for the `Name`. e.g.
-
-``` go
-app.Flags = []cli.Flag {
-  cli.StringFlag{
-    Name: "lang, l",
-    Value: "english",
-    Usage: "language for the greeting",
-  },
-}
-```
-
-That flag can then be set with `--lang spanish` or `-l spanish`. Note that giving two different forms of the same flag in the same command invocation is an error.
-
-#### Values from the Environment
-
-You can also have the default value set from the environment via `EnvVar`.  e.g.
-
-``` go
-app.Flags = []cli.Flag {
-  cli.StringFlag{
-    Name: "lang, l",
-    Value: "english",
-    Usage: "language for the greeting",
-    EnvVar: "APP_LANG",
-  },
-}
-```
-
-The `EnvVar` may also be given as a comma-delimited "cascade", where the first environment variable that resolves is used as the default.
-
-``` go
-app.Flags = []cli.Flag {
-  cli.StringFlag{
-    Name: "lang, l",
-    Value: "english",
-    Usage: "language for the greeting",
-    EnvVar: "LEGACY_COMPAT_LANG,APP_LANG,LANG",
-  },
-}
-```
-
-### Subcommands
-
-Subcommands can be defined for a more git-like command line app.
-```go
-...
-app.Commands = []cli.Command{
-  {
-    Name:      "add",
-    Aliases:     []string{"a"},
-    Usage:     "add a task to the list",
-    Action: func(c *cli.Context) {
-      println("added task: ", c.Args().First())
-    },
-  },
-  {
-    Name:      "complete",
-    Aliases:     []string{"c"},
-    Usage:     "complete a task on the list",
-    Action: func(c *cli.Context) {
-      println("completed task: ", c.Args().First())
-    },
-  },
-  {
-    Name:      "template",
-    Aliases:     []string{"r"},
-    Usage:     "options for task templates",
-    Subcommands: []cli.Command{
-      {
-        Name:  "add",
-        Usage: "add a new template",
-        Action: func(c *cli.Context) {
-            println("new task template: ", c.Args().First())
-        },
-      },
-      {
-        Name:  "remove",
-        Usage: "remove an existing template",
-        Action: func(c *cli.Context) {
-          println("removed task template: ", c.Args().First())
-        },
-      },
-    },
-  },
-}
-...
-```
-
-### Bash Completion
-
-You can enable completion commands by setting the `EnableBashCompletion`
-flag on the `App` object.  By default, this setting will only auto-complete to
-show an app's subcommands, but you can write your own completion methods for
-the App or its subcommands.
-```go
-...
-var tasks = []string{"cook", "clean", "laundry", "eat", "sleep", "code"}
-app := cli.NewApp()
-app.EnableBashCompletion = true
-app.Commands = []cli.Command{
-  {
-    Name:  "complete",
-    Aliases: []string{"c"},
-    Usage: "complete a task on the list",
-    Action: func(c *cli.Context) {
-       println("completed task: ", c.Args().First())
-    },
-    BashComplete: func(c *cli.Context) {
-      // This will complete if no args are passed
-      if len(c.Args()) > 0 {
-        return
-      }
-      for _, t := range tasks {
-        fmt.Println(t)
-      }
-    },
-  }
-}
-...
-```
-
-#### To Enable
-
-Source the `autocomplete/bash_autocomplete` file in your `.bashrc` file while
-setting the `PROG` variable to the name of your program:
-
-`PROG=myprogram source /.../cli/autocomplete/bash_autocomplete`
-
-
-## Contribution Guidelines
-Feel free to put up a pull request to fix a bug or maybe add a feature. I will give it a code review and make sure that it does not break backwards compatibility. If I or any other collaborators agree that it is in line with the vision of the project, we will work with you to get the code into a mergeable state and merge it into the master branch.
-
-If you have contributed something significant to the project, I will most likely add you as a collaborator. As a collaborator you are given the ability to merge others pull requests. It is very important that new code does not break existing code, so be careful about what code you do choose to merge. If you have any questions feel free to link @codegangsta to the issue in question and we can review it together.
-
-If you feel like you have contributed to the project but have not yet been added as a collaborator, I probably forgot to add you. Hit @codegangsta up over email and we will get it figured out.
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/app.go b/Godeps/_workspace/src/github.com/codegangsta/cli/app.go
deleted file mode 100644
index 3b5bd61..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/app.go
+++ /dev/null
@@ -1,321 +0,0 @@
-package cli
-
-import (
-        "fmt"
-        "io"
-        "io/ioutil"
-        "os"
-        "strings"
-        "text/tabwriter"
-        "text/template"
-        "time"
-)
-
-// App is the main structure of a cli application. It is recomended that
-// and app be created with the cli.NewApp() function
-type App struct {
-        // The name of the program. Defaults to os.Args[0]
-        Name string
-        // Description of the program.
-        Usage string
-        // Version of the program
-        Version string
-        // List of commands to execute
-        Commands []Command
-        // List of flags to parse
-        Flags []Flag
-        // Boolean to enable bash completion commands
-        EnableBashCompletion bool
-        // Boolean to hide built-in help command
-        HideHelp bool
-        // Boolean to hide built-in version flag
-        HideVersion bool
-        // An action to execute when the bash-completion flag is set
-        BashComplete func(context *Context)
-        // An action to execute before any subcommands are run, but after the context is ready
-        // If a non-nil error is returned, no subcommands are run
-        Before func(context *Context) error
-        // An action to execute after any subcommands are run, but after the subcommand has finished
-        // It is run even if Action() panics
-        After func(context *Context) error
-        // The action to execute when no subcommands are specified
-        Action func(context *Context)
-        // Execute this function if the proper command cannot be found
-        CommandNotFound func(context *Context, command string)
-        // Compilation date
-        Compiled time.Time
-        // List of all authors who contributed
-        Authors []Author
-        // Name of Author (Note: Use App.Authors, this is deprecated)
-        Author string
-        // Email of Author (Note: Use App.Authors, this is deprecated)
-        Email string
-        // Writer writer to write output to
-        Writer io.Writer
-}
-
-// Tries to find out when this binary was compiled.
-// Returns the current time if it fails to find it.
-func compileTime() time.Time {
-        info, err := os.Stat(os.Args[0])
-        if err != nil {
-                return time.Now()
-        }
-        return info.ModTime()
-}
-
-// Creates a new cli Application with some reasonable defaults for Name, Usage, Version and Action.
-func NewApp() *App {
-        return &App{
-                Name:         os.Args[0],
-                Usage:        "A new cli application",
-                Version:      "0.0.0",
-                BashComplete: DefaultAppComplete,
-                Action:       helpCommand.Action,
-                Compiled:     compileTime(),
-                Writer:       os.Stdout,
-        }
-}
-
-// Entry point to the cli app. Parses the arguments slice and routes to the proper flag/args combination
-func (a *App) Run(arguments []string) (err error) {
-        if a.Author != "" || a.Email != "" {
-                a.Authors = append(a.Authors, Author{Name: a.Author, Email: a.Email})
-        }
-
-        if HelpPrinter == nil {
-                defer func() {
-                        HelpPrinter = nil
-                }()
-
-                HelpPrinter = func(templ string, data interface{}) {
-                        funcMap := template.FuncMap{
-                                "join": strings.Join,
-                        }
-
-                        w := tabwriter.NewWriter(a.Writer, 0, 8, 1, '\t', 0)
-                        t := template.Must(template.New("help").Funcs(funcMap).Parse(templ))
-                        err := t.Execute(w, data)
-                        if err != nil {
-                                panic(err)
-                        }
-                        w.Flush()
-                }
-        }
-
-        // append help to commands
-        if a.Command(helpCommand.Name) == nil && !a.HideHelp {
-                a.Commands = append(a.Commands, helpCommand)
-                if (HelpFlag != BoolFlag{}) {
-                        a.appendFlag(HelpFlag)
-                }
-        }
-
-        //append version/help flags
-        if a.EnableBashCompletion {
-                a.appendFlag(BashCompletionFlag)
-        }
-
-        if !a.HideVersion {
-                a.appendFlag(VersionFlag)
-        }
-
-        // parse flags
-        set := flagSet(a.Name, a.Flags)
-        set.SetOutput(ioutil.Discard)
-        err = set.Parse(arguments[1:])
-        nerr := normalizeFlags(a.Flags, set)
-        if nerr != nil {
-                fmt.Fprintln(a.Writer, nerr)
-                context := NewContext(a, set, set)
-                ShowAppHelp(context)
-                fmt.Fprintln(a.Writer)
-                return nerr
-        }
-        context := NewContext(a, set, set)
-
-        if err != nil {
-                fmt.Fprintf(a.Writer, "Incorrect Usage.\n\n")
-                ShowAppHelp(context)
-                fmt.Fprintln(a.Writer)
-                return err
-        }
-
-        if checkCompletions(context) {
-                return nil
-        }
-
-        if checkHelp(context) {
-                return nil
-        }
-
-        if checkVersion(context) {
-                return nil
-        }
-
-        if a.After != nil {
-                defer func() {
-                        // err is always nil here.
-                        // There is a check to see if it is non-nil
-                        // just few lines before.
-                        err = a.After(context)
-                }()
-        }
-
-        if a.Before != nil {
-                err := a.Before(context)
-                if err != nil {
-                        return err
-                }
-        }
-
-        args := context.Args()
-        if args.Present() {
-                name := args.First()
-                c := a.Command(name)
-                if c != nil {
-                        return c.Run(context)
-                }
-        }
-
-        // Run default Action
-        a.Action(context)
-        return nil
-}
-
-// Another entry point to the cli app, takes care of passing arguments and error handling
-func (a *App) RunAndExitOnError() {
-        if err := a.Run(os.Args); err != nil {
-                fmt.Fprintln(os.Stderr, err)
-                os.Exit(1)
-        }
-}
-
-// Invokes the subcommand given the context, parses ctx.Args() to generate command-specific flags
-func (a *App) RunAsSubcommand(ctx *Context) (err error) {
-        // append help to commands
-        if len(a.Commands) > 0 {
-                if a.Command(helpCommand.Name) == nil && !a.HideHelp {
-                        a.Commands = append(a.Commands, helpCommand)
-                        if (HelpFlag != BoolFlag{}) {
-                                a.appendFlag(HelpFlag)
-                        }
-                }
-        }
-
-        // append flags
-        if a.EnableBashCompletion {
-                a.appendFlag(BashCompletionFlag)
-        }
-
-        // parse flags
-        set := flagSet(a.Name, a.Flags)
-        set.SetOutput(ioutil.Discard)
-        err = set.Parse(ctx.Args().Tail())
-        nerr := normalizeFlags(a.Flags, set)
-        context := NewContext(a, set, ctx.globalSet)
-
-        if nerr != nil {
-                fmt.Fprintln(a.Writer, nerr)
-                if len(a.Commands) > 0 {
-                        ShowSubcommandHelp(context)
-                } else {
-                        ShowCommandHelp(ctx, context.Args().First())
-                }
-                fmt.Fprintln(a.Writer)
-                return nerr
-        }
-
-        if err != nil {
-                fmt.Fprintf(a.Writer, "Incorrect Usage.\n\n")
-                ShowSubcommandHelp(context)
-                return err
-        }
-
-        if checkCompletions(context) {
-                return nil
-        }
-
-        if len(a.Commands) > 0 {
-                if checkSubcommandHelp(context) {
-                        return nil
-                }
-        } else {
-                if checkCommandHelp(ctx, context.Args().First()) {
-                        return nil
-                }
-        }
-
-        if a.After != nil {
-                defer func() {
-                        // err is always nil here.
-                        // There is a check to see if it is non-nil
-                        // just few lines before.
-                        err = a.After(context)
-                }()
-        }
-
-        if a.Before != nil {
-                err := a.Before(context)
-                if err != nil {
-                        return err
-                }
-        }
-
-        args := context.Args()
-        if args.Present() {
-                name := args.First()
-                c := a.Command(name)
-                if c != nil {
-                        return c.Run(context)
-                }
-        }
-
-        // Run default Action
-        a.Action(context)
-
-        return nil
-}
-
-// Returns the named command on App. Returns nil if the command does not exist
-func (a *App) Command(name string) *Command {
-        for _, c := range a.Commands {
-                if c.HasName(name) {
-                        return &c
-                }
-        }
-
-        return nil
-}
-
-func (a *App) hasFlag(flag Flag) bool {
-        for _, f := range a.Flags {
-                if flag == f {
-                        return true
-                }
-        }
-
-        return false
-}
-
-func (a *App) appendFlag(flag Flag) {
-        if !a.hasFlag(flag) {
-                a.Flags = append(a.Flags, flag)
-        }
-}
-
-// Author represents someone who has contributed to a cli project.
-type Author struct {
-        Name  string // The Authors name
-        Email string // The Authors email
-}
-
-// String makes Author comply to the Stringer interface, to allow an easy print in the templating process
-func (a Author) String() string {
-        e := ""
-        if a.Email != "" {
-                e = "<" + a.Email + "> "
-        }
-
-        return fmt.Sprintf("%v %v", a.Name, e)
-}
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/app_test.go b/Godeps/_workspace/src/github.com/codegangsta/cli/app_test.go
deleted file mode 100644
index 517facd..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/app_test.go
+++ /dev/null
@@ -1,622 +0,0 @@
-package cli_test
-
-import (
-        "flag"
-        "fmt"
-        "os"
-        "testing"
-
-        "github.com/stevenjack/cig/Godeps/_workspace/src/github.com/codegangsta/cli"
-)
-
-func ExampleApp() {
-        // set args for examples sake
-        os.Args = []string{"greet", "--name", "Jeremy"}
-
-        app := cli.NewApp()
-        app.Name = "greet"
-        app.Flags = []cli.Flag{
-                cli.StringFlag{Name: "name", Value: "bob", Usage: "a name to say"},
-        }
-        app.Action = func(c *cli.Context) {
-                fmt.Printf("Hello %v\n", c.String("name"))
-        }
-        app.Author = "Harrison"
-        app.Email = "harrison@lolwut.com"
-        app.Authors = []cli.Author{cli.Author{Name: "Oliver Allen", Email: "oliver@toyshop.com"}}
-        app.Run(os.Args)
-        // Output:
-        // Hello Jeremy
-}
-
-func ExampleAppSubcommand() {
-        // set args for examples sake
-        os.Args = []string{"say", "hi", "english", "--name", "Jeremy"}
-        app := cli.NewApp()
-        app.Name = "say"
-        app.Commands = []cli.Command{
-                {
-                        Name:        "hello",
-                        Aliases:     []string{"hi"},
-                        Usage:       "use it to see a description",
-                        Description: "This is how we describe hello the function",
-                        Subcommands: []cli.Command{
-                                {
-                                        Name:        "english",
-                                        Aliases:     []string{"en"},
-                                        Usage:       "sends a greeting in english",
-                                        Description: "greets someone in english",
-                                        Flags: []cli.Flag{
-                                                cli.StringFlag{
-                                                        Name:  "name",
-                                                        Value: "Bob",
-                                                        Usage: "Name of the person to greet",
-                                                },
-                                        },
-                                        Action: func(c *cli.Context) {
-                                                fmt.Println("Hello,", c.String("name"))
-                                        },
-                                },
-                        },
-                },
-        }
-
-        app.Run(os.Args)
-        // Output:
-        // Hello, Jeremy
-}
-
-func ExampleAppHelp() {
-        // set args for examples sake
-        os.Args = []string{"greet", "h", "describeit"}
-
-        app := cli.NewApp()
-        app.Name = "greet"
-        app.Flags = []cli.Flag{
-                cli.StringFlag{Name: "name", Value: "bob", Usage: "a name to say"},
-        }
-        app.Commands = []cli.Command{
-                {
-                        Name:        "describeit",
-                        Aliases:     []string{"d"},
-                        Usage:       "use it to see a description",
-                        Description: "This is how we describe describeit the function",
-                        Action: func(c *cli.Context) {
-                                fmt.Printf("i like to describe things")
-                        },
-                },
-        }
-        app.Run(os.Args)
-        // Output:
-        // NAME:
-        //    describeit - use it to see a description
-        //
-        // USAGE:
-        //    command describeit [arguments...]
-        //
-        // DESCRIPTION:
-        //    This is how we describe describeit the function
-}
-
-func ExampleAppBashComplete() {
-        // set args for examples sake
-        os.Args = []string{"greet", "--generate-bash-completion"}
-
-        app := cli.NewApp()
-        app.Name = "greet"
-        app.EnableBashCompletion = true
-        app.Commands = []cli.Command{
-                {
-                        Name:        "describeit",
-                        Aliases:     []string{"d"},
-                        Usage:       "use it to see a description",
-                        Description: "This is how we describe describeit the function",
-                        Action: func(c *cli.Context) {
-                                fmt.Printf("i like to describe things")
-                        },
-                }, {
-                        Name:        "next",
-                        Usage:       "next example",
-                        Description: "more stuff to see when generating bash completion",
-                        Action: func(c *cli.Context) {
-                                fmt.Printf("the next example")
-                        },
-                },
-        }
-
-        app.Run(os.Args)
-        // Output:
-        // describeit
-        // d
-        // next
-        // help
-        // h
-}
-
-func TestApp_Run(t *testing.T) {
-        s := ""
-
-        app := cli.NewApp()
-        app.Action = func(c *cli.Context) {
-                s = s + c.Args().First()
-        }
-
-        err := app.Run([]string{"command", "foo"})
-        expect(t, err, nil)
-        err = app.Run([]string{"command", "bar"})
-        expect(t, err, nil)
-        expect(t, s, "foobar")
-}
-
-var commandAppTests = []struct {
-        name     string
-        expected bool
-}{
-        {"foobar", true},
-        {"batbaz", true},
-        {"b", true},
-        {"f", true},
-        {"bat", false},
-        {"nothing", false},
-}
-
-func TestApp_Command(t *testing.T) {
-        app := cli.NewApp()
-        fooCommand := cli.Command{Name: "foobar", Aliases: []string{"f"}}
-        batCommand := cli.Command{Name: "batbaz", Aliases: []string{"b"}}
-        app.Commands = []cli.Command{
-                fooCommand,
-                batCommand,
-        }
-
-        for _, test := range commandAppTests {
-                expect(t, app.Command(test.name) != nil, test.expected)
-        }
-}
-
-func TestApp_CommandWithArgBeforeFlags(t *testing.T) {
-        var parsedOption, firstArg string
-
-        app := cli.NewApp()
-        command := cli.Command{
-                Name: "cmd",
-                Flags: []cli.Flag{
-                        cli.StringFlag{Name: "option", Value: "", Usage: "some option"},
-                },
-                Action: func(c *cli.Context) {
-                        parsedOption = c.String("option")
-                        firstArg = c.Args().First()
-                },
-        }
-        app.Commands = []cli.Command{command}
-
-        app.Run([]string{"", "cmd", "my-arg", "--option", "my-option"})
-
-        expect(t, parsedOption, "my-option")
-        expect(t, firstArg, "my-arg")
-}
-
-func TestApp_RunAsSubcommandParseFlags(t *testing.T) {
-        var context *cli.Context
-
-        a := cli.NewApp()
-        a.Commands = []cli.Command{
-                {
-                        Name: "foo",
-                        Action: func(c *cli.Context) {
-                                context = c
-                        },
-                        Flags: []cli.Flag{
-                                cli.StringFlag{
-                                        Name:  "lang",
-                                        Value: "english",
-                                        Usage: "language for the greeting",
-                                },
-                        },
-                        Before: func(_ *cli.Context) error { return nil },
-                },
-        }
-        a.Run([]string{"", "foo", "--lang", "spanish", "abcd"})
-
-        expect(t, context.Args().Get(0), "abcd")
-        expect(t, context.String("lang"), "spanish")
-}
-
-func TestApp_CommandWithFlagBeforeTerminator(t *testing.T) {
-        var parsedOption string
-        var args []string
-
-        app := cli.NewApp()
-        command := cli.Command{
-                Name: "cmd",
-                Flags: []cli.Flag{
-                        cli.StringFlag{Name: "option", Value: "", Usage: "some option"},
-                },
-                Action: func(c *cli.Context) {
-                        parsedOption = c.String("option")
-                        args = c.Args()
-                },
-        }
-        app.Commands = []cli.Command{command}
-
-        app.Run([]string{"", "cmd", "my-arg", "--option", "my-option", "--", "--notARealFlag"})
-
-        expect(t, parsedOption, "my-option")
-        expect(t, args[0], "my-arg")
-        expect(t, args[1], "--")
-        expect(t, args[2], "--notARealFlag")
-}
-
-func TestApp_CommandWithNoFlagBeforeTerminator(t *testing.T) {
-        var args []string
-
-        app := cli.NewApp()
-        command := cli.Command{
-                Name: "cmd",
-                Action: func(c *cli.Context) {
-                        args = c.Args()
-                },
-        }
-        app.Commands = []cli.Command{command}
-
-        app.Run([]string{"", "cmd", "my-arg", "--", "notAFlagAtAll"})
-
-        expect(t, args[0], "my-arg")
-        expect(t, args[1], "--")
-        expect(t, args[2], "notAFlagAtAll")
-}
-
-func TestApp_Float64Flag(t *testing.T) {
-        var meters float64
-
-        app := cli.NewApp()
-        app.Flags = []cli.Flag{
-                cli.Float64Flag{Name: "height", Value: 1.5, Usage: "Set the height, in meters"},
-        }
-        app.Action = func(c *cli.Context) {
-                meters = c.Float64("height")
-        }
-
-        app.Run([]string{"", "--height", "1.93"})
-        expect(t, meters, 1.93)
-}
-
-func TestApp_ParseSliceFlags(t *testing.T) {
-        var parsedOption, firstArg string
-        var parsedIntSlice []int
-        var parsedStringSlice []string
-
-        app := cli.NewApp()
-        command := cli.Command{
-                Name: "cmd",
-                Flags: []cli.Flag{
-                        cli.IntSliceFlag{Name: "p", Value: &cli.IntSlice{}, Usage: "set one or more ip addr"},
-                        cli.StringSliceFlag{Name: "ip", Value: &cli.StringSlice{}, Usage: "set one or more ports to open"},
-                },
-                Action: func(c *cli.Context) {
-                        parsedIntSlice = c.IntSlice("p")
-                        parsedStringSlice = c.StringSlice("ip")
-                        parsedOption = c.String("option")
-                        firstArg = c.Args().First()
-                },
-        }
-        app.Commands = []cli.Command{command}
-
-        app.Run([]string{"", "cmd", "my-arg", "-p", "22", "-p", "80", "-ip", "8.8.8.8", "-ip", "8.8.4.4"})
-
-        IntsEquals := func(a, b []int) bool {
-                if len(a) != len(b) {
-                        return false
-                }
-                for i, v := range a {
-                        if v != b[i] {
-                                return false
-                        }
-                }
-                return true
-        }
-
-        StrsEquals := func(a, b []string) bool {
-                if len(a) != len(b) {
-                        return false
-                }
-                for i, v := range a {
-                        if v != b[i] {
-                                return false
-                        }
-                }
-                return true
-        }
-        var expectedIntSlice = []int{22, 80}
-        var expectedStringSlice = []string{"8.8.8.8", "8.8.4.4"}
-
-        if !IntsEquals(parsedIntSlice, expectedIntSlice) {
-                t.Errorf("%v does not match %v", parsedIntSlice, expectedIntSlice)
-        }
-
-        if !StrsEquals(parsedStringSlice, expectedStringSlice) {
-                t.Errorf("%v does not match %v", parsedStringSlice, expectedStringSlice)
-        }
-}
-
-func TestApp_DefaultStdout(t *testing.T) {
-        app := cli.NewApp()
-
-        if app.Writer != os.Stdout {
-                t.Error("Default output writer not set.")
-        }
-}
-
-type mockWriter struct {
-        written []byte
-}
-
-func (fw *mockWriter) Write(p []byte) (n int, err error) {
-        if fw.written == nil {
-                fw.written = p
-        } else {
-                fw.written = append(fw.written, p...)
-        }
-
-        return len(p), nil
-}
-
-func (fw *mockWriter) GetWritten() (b []byte) {
-        return fw.written
-}
-
-func TestApp_SetStdout(t *testing.T) {
-        w := &mockWriter{}
-
-        app := cli.NewApp()
-        app.Name = "test"
-        app.Writer = w
-
-        err := app.Run([]string{"help"})
-
-        if err != nil {
-                t.Fatalf("Run error: %s", err)
-        }
-
-        if len(w.written) == 0 {
-                t.Error("App did not write output to desired writer.")
-        }
-}
-
-func TestApp_BeforeFunc(t *testing.T) {
-        beforeRun, subcommandRun := false, false
-        beforeError := fmt.Errorf("fail")
-        var err error
-
-        app := cli.NewApp()
-
-        app.Before = func(c *cli.Context) error {
-                beforeRun = true
-                s := c.String("opt")
-                if s == "fail" {
-                        return beforeError
-                }
-
-                return nil
-        }
-
-        app.Commands = []cli.Command{
-                cli.Command{
-                        Name: "sub",
-                        Action: func(c *cli.Context) {
-                                subcommandRun = true
-                        },
-                },
-        }
-
-        app.Flags = []cli.Flag{
-                cli.StringFlag{Name: "opt"},
-        }
-
-        // run with the Before() func succeeding
-        err = app.Run([]string{"command", "--opt", "succeed", "sub"})
-
-        if err != nil {
-                t.Fatalf("Run error: %s", err)
-        }
-
-        if beforeRun == false {
-                t.Errorf("Before() not executed when expected")
-        }
-
-        if subcommandRun == false {
-                t.Errorf("Subcommand not executed when expected")
-        }
-
-        // reset
-        beforeRun, subcommandRun = false, false
-
-        // run with the Before() func failing
-        err = app.Run([]string{"command", "--opt", "fail", "sub"})
-
-        // should be the same error produced by the Before func
-        if err != beforeError {
-                t.Errorf("Run error expected, but not received")
-        }
-
-        if beforeRun == false {
-                t.Errorf("Before() not executed when expected")
-        }
-
-        if subcommandRun == true {
-                t.Errorf("Subcommand executed when NOT expected")
-        }
-
-}
-
-func TestApp_AfterFunc(t *testing.T) {
-        afterRun, subcommandRun := false, false
-        afterError := fmt.Errorf("fail")
-        var err error
-
-        app := cli.NewApp()
-
-        app.After = func(c *cli.Context) error {
-                afterRun = true
-                s := c.String("opt")
-                if s == "fail" {
-                        return afterError
-                }
-
-                return nil
-        }
-
-        app.Commands = []cli.Command{
-                cli.Command{
-                        Name: "sub",
-                        Action: func(c *cli.Context) {
-                                subcommandRun = true
-                        },
-                },
-        }
-
-        app.Flags = []cli.Flag{
-                cli.StringFlag{Name: "opt"},
-        }
-
-        // run with the After() func succeeding
-        err = app.Run([]string{"command", "--opt", "succeed", "sub"})
-
-        if err != nil {
-                t.Fatalf("Run error: %s", err)
-        }
-
-        if afterRun == false {
-                t.Errorf("After() not executed when expected")
-        }
-
-        if subcommandRun == false {
-                t.Errorf("Subcommand not executed when expected")
-        }
-
-        // reset
-        afterRun, subcommandRun = false, false
-
-        // run with the Before() func failing
-        err = app.Run([]string{"command", "--opt", "fail", "sub"})
-
-        // should be the same error produced by the Before func
-        if err != afterError {
-                t.Errorf("Run error expected, but not received")
-        }
-
-        if afterRun == false {
-                t.Errorf("After() not executed when expected")
-        }
-
-        if subcommandRun == false {
-                t.Errorf("Subcommand not executed when expected")
-        }
-}
-
-func TestAppNoHelpFlag(t *testing.T) {
-        oldFlag := cli.HelpFlag
-        defer func() {
-                cli.HelpFlag = oldFlag
-        }()
-
-        cli.HelpFlag = cli.BoolFlag{}
-
-        app := cli.NewApp()
-        err := app.Run([]string{"test", "-h"})
-
-        if err != flag.ErrHelp {
-                t.Errorf("expected error about missing help flag, but got: %s (%T)", err, err)
-        }
-}
-
-func TestAppHelpPrinter(t *testing.T) {
-        oldPrinter := cli.HelpPrinter
-        defer func() {
-                cli.HelpPrinter = oldPrinter
-        }()
-
-        var wasCalled = false
-        cli.HelpPrinter = func(template string, data interface{}) {
-                wasCalled = true
-        }
-
-        app := cli.NewApp()
-        app.Run([]string{"-h"})
-
-        if wasCalled == false {
-                t.Errorf("Help printer expected to be called, but was not")
-        }
-}
-
-func TestAppVersionPrinter(t *testing.T) {
-        oldPrinter := cli.VersionPrinter
-        defer func() {
-                cli.VersionPrinter = oldPrinter
-        }()
-
-        var wasCalled = false
-        cli.VersionPrinter = func(c *cli.Context) {
-                wasCalled = true
-        }
-
-        app := cli.NewApp()
-        ctx := cli.NewContext(app, nil, nil)
-        cli.ShowVersion(ctx)
-
-        if wasCalled == false {
-                t.Errorf("Version printer expected to be called, but was not")
-        }
-}
-
-func TestAppCommandNotFound(t *testing.T) {
-        beforeRun, subcommandRun := false, false
-        app := cli.NewApp()
-
-        app.CommandNotFound = func(c *cli.Context, command string) {
-                beforeRun = true
-        }
-
-        app.Commands = []cli.Command{
-                cli.Command{
-                        Name: "bar",
-                        Action: func(c *cli.Context) {
-                                subcommandRun = true
-                        },
-                },
-        }
-
-        app.Run([]string{"command", "foo"})
-
-        expect(t, beforeRun, true)
-        expect(t, subcommandRun, false)
-}
-
-func TestGlobalFlagsInSubcommands(t *testing.T) {
-        subcommandRun := false
-        app := cli.NewApp()
-
-        app.Flags = []cli.Flag{
-                cli.BoolFlag{Name: "debug, d", Usage: "Enable debugging"},
-        }
-
-        app.Commands = []cli.Command{
-                cli.Command{
-                        Name: "foo",
-                        Subcommands: []cli.Command{
-                                {
-                                        Name: "bar",
-                                        Action: func(c *cli.Context) {
-                                                if c.GlobalBool("debug") {
-                                                        subcommandRun = true
-                                                }
-                                        },
-                                },
-                        },
-                },
-        }
-
-        app.Run([]string{"command", "-d", "foo", "bar"})
-
-        expect(t, subcommandRun, true)
-}
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/bash_autocomplete b/Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/bash_autocomplete
deleted file mode 100644
index 2a229f2..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/bash_autocomplete
+++ /dev/null
@@ -1,13 +0,0 @@
-#! /bin/bash
-
-_cli_bash_autocomplete() {
-     local cur prev opts base
-     COMPREPLY=()
-     cur="${COMP_WORDS[COMP_CWORD]}"
-     prev="${COMP_WORDS[COMP_CWORD-1]}"
-     opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} --generate-bash-completion )
-     COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
-     return 0
- }
-
- complete -F _cli_bash_autocomplete $PROG
\ No newline at end of file
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/zsh_autocomplete b/Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/zsh_autocomplete
deleted file mode 100644
index 5430a18..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/autocomplete/zsh_autocomplete
+++ /dev/null
@@ -1,5 +0,0 @@
-autoload -U compinit && compinit
-autoload -U bashcompinit && bashcompinit
-
-script_dir=$(dirname $0)
-source ${script_dir}/bash_autocomplete
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/cli.go b/Godeps/_workspace/src/github.com/codegangsta/cli/cli.go
deleted file mode 100644
index b742545..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/cli.go
+++ /dev/null
@@ -1,19 +0,0 @@
-// Package cli provides a minimal framework for creating and organizing command line
-// Go applications. cli is designed to be easy to understand and write, the most simple
-// cli application can be written as follows:
-//   func main() {
-//     cli.NewApp().Run(os.Args)
-//   }
-//
-// Of course this application does not do much, so let's make this an actual application:
-//   func main() {
-//     app := cli.NewApp()
-//     app.Name = "greet"
-//     app.Usage = "say a greeting"
-//     app.Action = func(c *cli.Context) {
-//       println("Greetings")
-//     }
-//
-//     app.Run(os.Args)
-//   }
-package cli
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/cli_test.go b/Godeps/_workspace/src/github.com/codegangsta/cli/cli_test.go
deleted file mode 100644
index 3bb844d..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/cli_test.go
+++ /dev/null
@@ -1,100 +0,0 @@
-package cli_test
-
-import (
-        "os"
-
-        "github.com/stevenjack/cig/Godeps/_workspace/src/github.com/codegangsta/cli"
-)
-
-func Example() {
-        app := cli.NewApp()
-        app.Name = "todo"
-        app.Usage = "task list on the command line"
-        app.Commands = []cli.Command{
-                {
-                        Name:    "add",
-                        Aliases: []string{"a"},
-                        Usage:   "add a task to the list",
-                        Action: func(c *cli.Context) {
-                                println("added task: ", c.Args().First())
-                        },
-                },
-                {
-                        Name:    "complete",
-                        Aliases: []string{"c"},
-                        Usage:   "complete a task on the list",
-                        Action: func(c *cli.Context) {
-                                println("completed task: ", c.Args().First())
-                        },
-                },
-        }
-
-        app.Run(os.Args)
-}
-
-func ExampleSubcommand() {
-        app := cli.NewApp()
-        app.Name = "say"
-        app.Commands = []cli.Command{
-                {
-                        Name:        "hello",
-                        Aliases:     []string{"hi"},
-                        Usage:       "use it to see a description",
-                        Description: "This is how we describe hello the function",
-                        Subcommands: []cli.Command{
-                                {
-                                        Name:        "english",
-                                        Aliases:     []string{"en"},
-                                        Usage:       "sends a greeting in english",
-                                        Description: "greets someone in english",
-                                        Flags: []cli.Flag{
-                                                cli.StringFlag{
-                                                        Name:  "name",
-                                                        Value: "Bob",
-                                                        Usage: "Name of the person to greet",
-                                                },
-                                        },
-                                        Action: func(c *cli.Context) {
-                                                println("Hello, ", c.String("name"))
-                                        },
-                                }, {
-                                        Name:    "spanish",
-                                        Aliases: []string{"sp"},
-                                        Usage:   "sends a greeting in spanish",
-                                        Flags: []cli.Flag{
-                                                cli.StringFlag{
-                                                        Name:  "surname",
-                                                        Value: "Jones",
-                                                        Usage: "Surname of the person to greet",
-                                                },
-                                        },
-                                        Action: func(c *cli.Context) {
-                                                println("Hola, ", c.String("surname"))
-                                        },
-                                }, {
-                                        Name:    "french",
-                                        Aliases: []string{"fr"},
-                                        Usage:   "sends a greeting in french",
-                                        Flags: []cli.Flag{
-                                                cli.StringFlag{
-                                                        Name:  "nickname",
-                                                        Value: "Stevie",
-                                                        Usage: "Nickname of the person to greet",
-                                                },
-                                        },
-                                        Action: func(c *cli.Context) {
-                                                println("Bonjour, ", c.String("nickname"))
-                                        },
-                                },
-                        },
-                }, {
-                        Name:  "bye",
-                        Usage: "says goodbye",
-                        Action: func(c *cli.Context) {
-                                println("bye")
-                        },
-                },
-        }
-
-        app.Run(os.Args)
-}
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/command.go b/Godeps/_workspace/src/github.com/codegangsta/cli/command.go
deleted file mode 100644
index 1f2ae51..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/command.go
+++ /dev/null
@@ -1,177 +0,0 @@
-package cli
-
-import (
-        "fmt"
-        "io/ioutil"
-        "strings"
-)
-
-// Command is a subcommand for a cli.App.
-type Command struct {
-        // The name of the command
-        Name string
-        // short name of the command. Typically one character (deprecated, use `Aliases`)
-        ShortName string
-        // A list of aliases for the command
-        Aliases []string
-        // A short description of the usage of this command
-        Usage string
-        // A longer explanation of how the command works
-        Description string
-        // The function to call when checking for bash command completions
-        BashComplete func(context *Context)
-        // An action to execute before any sub-subcommands are run, but after the context is ready
-        // If a non-nil error is returned, no sub-subcommands are run
-        Before func(context *Context) error
-        // An action to execute after any subcommands are run, but after the subcommand has finished
-        // It is run even if Action() panics
-        After func(context *Context) error
-        // The function to call when this command is invoked
-        Action func(context *Context)
-        // List of child commands
-        Subcommands []Command
-        // List of flags to parse
-        Flags []Flag
-        // Treat all flags as normal arguments if true
-        SkipFlagParsing bool
-        // Boolean to hide built-in help command
-        HideHelp bool
-}
-
-// Invokes the command given the context, parses ctx.Args() to generate command-specific flags
-func (c Command) Run(ctx *Context) error {
-
-        if len(c.Subcommands) > 0 || c.Before != nil || c.After != nil {
-                return c.startApp(ctx)
-        }
-
-        if !c.HideHelp && (HelpFlag != BoolFlag{}) {
-                // append help to flags
-                c.Flags = append(
-                        c.Flags,
-                        HelpFlag,
-                )
-        }
-
-        if ctx.App.EnableBashCompletion {
-                c.Flags = append(c.Flags, BashCompletionFlag)
-        }
-
-        set := flagSet(c.Name, c.Flags)
-        set.SetOutput(ioutil.Discard)
-
-        firstFlagIndex := -1
-        terminatorIndex := -1
-        for index, arg := range ctx.Args() {
-                if arg == "--" {
-                        terminatorIndex = index
-                        break
-                } else if strings.HasPrefix(arg, "-") && firstFlagIndex == -1 {
-                        firstFlagIndex = index
-                }
-        }
-
-        var err error
-        if firstFlagIndex > -1 && !c.SkipFlagParsing {
-                args := ctx.Args()
-                regularArgs := make([]string, len(args[1:firstFlagIndex]))
-                copy(regularArgs, args[1:firstFlagIndex])
-
-                var flagArgs []string
-                if terminatorIndex > -1 {
-                        flagArgs = args[firstFlagIndex:terminatorIndex]
-                        regularArgs = append(regularArgs, args[terminatorIndex:]...)
-                } else {
-                        flagArgs = args[firstFlagIndex:]
-                }
-
-                err = set.Parse(append(flagArgs, regularArgs...))
-        } else {
-                err = set.Parse(ctx.Args().Tail())
-        }
-
-        if err != nil {
-                fmt.Fprint(ctx.App.Writer, "Incorrect Usage.\n\n")
-                ShowCommandHelp(ctx, c.Name)
-                fmt.Fprintln(ctx.App.Writer)
-                return err
-        }
-
-        nerr := normalizeFlags(c.Flags, set)
-        if nerr != nil {
-                fmt.Fprintln(ctx.App.Writer, nerr)
-                fmt.Fprintln(ctx.App.Writer)
-                ShowCommandHelp(ctx, c.Name)
-                fmt.Fprintln(ctx.App.Writer)
-                return nerr
-        }
-        context := NewContext(ctx.App, set, ctx.globalSet)
-
-        if checkCommandCompletions(context, c.Name) {
-                return nil
-        }
-
-        if checkCommandHelp(context, c.Name) {
-                return nil
-        }
-        context.Command = c
-        c.Action(context)
-        return nil
-}
-
-func (c Command) Names() []string {
-        names := []string{c.Name}
-
-        if c.ShortName != "" {
-                names = append(names, c.ShortName)
-        }
-
-        return append(names, c.Aliases...)
-}
-
-// Returns true if Command.Name or Command.ShortName matches given name
-func (c Command) HasName(name string) bool {
-        for _, n := range c.Names() {
-                if n == name {
-                        return true
-                }
-        }
-        return false
-}
-
-func (c Command) startApp(ctx *Context) error {
-        app := NewApp()
-
-        // set the name and usage
-        app.Name = fmt.Sprintf("%s %s", ctx.App.Name, c.Name)
-        if c.Description != "" {
-                app.Usage = c.Description
-        } else {
-                app.Usage = c.Usage
-        }
-
-        // set CommandNotFound
-        app.CommandNotFound = ctx.App.CommandNotFound
-
-        // set the flags and commands
-        app.Commands = c.Subcommands
-        app.Flags = c.Flags
-        app.HideHelp = c.HideHelp
-
-        // bash completion
-        app.EnableBashCompletion = ctx.App.EnableBashCompletion
-        if c.BashComplete != nil {
-                app.BashComplete = c.BashComplete
-        }
-
-        // set the actions
-        app.Before = c.Before
-        app.After = c.After
-        if c.Action != nil {
-                app.Action = c.Action
-        } else {
-                app.Action = helpSubcommand.Action
-        }
-
-        return app.RunAsSubcommand(ctx)
-}
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/command_test.go b/Godeps/_workspace/src/github.com/codegangsta/cli/command_test.go
deleted file mode 100644
index e0c6fa3..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/command_test.go
+++ /dev/null
@@ -1,49 +0,0 @@
-package cli_test
-
-import (
-        "flag"
-        "testing"
-
-        "github.com/stevenjack/cig/Godeps/_workspace/src/github.com/codegangsta/cli"
-)
-
-func TestCommandDoNotIgnoreFlags(t *testing.T) {
-        app := cli.NewApp()
-        set := flag.NewFlagSet("test", 0)
-        test := []string{"blah", "blah", "-break"}
-        set.Parse(test)
-
-        c := cli.NewContext(app, set, set)
-
-        command := cli.Command{
-                Name:        "test-cmd",
-                Aliases:     []string{"tc"},
-                Usage:       "this is for testing",
-                Description: "testing",
-                Action:      func(_ *cli.Context) {},
-        }
-        err := command.Run(c)
-
-        expect(t, err.Error(), "flag provided but not defined: -break")
-}
-
-func TestCommandIgnoreFlags(t *testing.T) {
-        app := cli.NewApp()
-        set := flag.NewFlagSet("test", 0)
-        test := []string{"blah", "blah"}
-        set.Parse(test)
-
-        c := cli.NewContext(app, set, set)
-
-        command := cli.Command{
-                Name:            "test-cmd",
-                Aliases:         []string{"tc"},
-                Usage:           "this is for testing",
-                Description:     "testing",
-                Action:          func(_ *cli.Context) {},
-                SkipFlagParsing: true,
-        }
-        err := command.Run(c)
-
-        expect(t, err, nil)
-}
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/context.go b/Godeps/_workspace/src/github.com/codegangsta/cli/context.go
deleted file mode 100644
index 6d9dca8..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/context.go
+++ /dev/null
@@ -1,344 +0,0 @@
-package cli
-
-import (
-        "errors"
-        "flag"
-        "strconv"
-        "strings"
-        "time"
-)
-
-// Context is a type that is passed through to
-// each Handler action in a cli application. Context
-// can be used to retrieve context-specific Args and
-// parsed command-line options.
-type Context struct {
-        App            *App
-        Command        Command
-        flagSet        *flag.FlagSet
-        globalSet      *flag.FlagSet
-        setFlags       map[string]bool
-        globalSetFlags map[string]bool
-}
-
-// Creates a new context. For use in when invoking an App or Command action.
-func NewContext(app *App, set *flag.FlagSet, globalSet *flag.FlagSet) *Context {
-        return &Context{App: app, flagSet: set, globalSet: globalSet}
-}
-
-// Looks up the value of a local int flag, returns 0 if no int flag exists
-func (c *Context) Int(name string) int {
-        return lookupInt(name, c.flagSet)
-}
-
-// Looks up the value of a local time.Duration flag, returns 0 if no time.Duration flag exists
-func (c *Context) Duration(name string) time.Duration {
-        return lookupDuration(name, c.flagSet)
-}
-
-// Looks up the value of a local float64 flag, returns 0 if no float64 flag exists
-func (c *Context) Float64(name string) float64 {
-        return lookupFloat64(name, c.flagSet)
-}
-
-// Looks up the value of a local bool flag, returns false if no bool flag exists
-func (c *Context) Bool(name string) bool {
-        return lookupBool(name, c.flagSet)
-}
-
-// Looks up the value of a local boolT flag, returns false if no bool flag exists
-func (c *Context) BoolT(name string) bool {
-        return lookupBoolT(name, c.flagSet)
-}
-
-// Looks up the value of a local string flag, returns "" if no string flag exists
-func (c *Context) String(name string) string {
-        return lookupString(name, c.flagSet)
-}
-
-// Looks up the value of a local string slice flag, returns nil if no string slice flag exists
-func (c *Context) StringSlice(name string) []string {
-        return lookupStringSlice(name, c.flagSet)
-}
-
-// Looks up the value of a local int slice flag, returns nil if no int slice flag exists
-func (c *Context) IntSlice(name string) []int {
-        return lookupIntSlice(name, c.flagSet)
-}
-
-// Looks up the value of a local generic flag, returns nil if no generic flag exists
-func (c *Context) Generic(name string) interface{} {
-        return lookupGeneric(name, c.flagSet)
-}
-
-// Looks up the value of a global int flag, returns 0 if no int flag exists
-func (c *Context) GlobalInt(name string) int {
-        return lookupInt(name, c.globalSet)
-}
-
-// Looks up the value of a global time.Duration flag, returns 0 if no time.Duration flag exists
-func (c *Context) GlobalDuration(name string) time.Duration {
-        return lookupDuration(name, c.globalSet)
-}
-
-// Looks up the value of a global bool flag, returns false if no bool flag exists
-func (c *Context) GlobalBool(name string) bool {
-        return lookupBool(name, c.globalSet)
-}
-
-// Looks up the value of a global string flag, returns "" if no string flag exists
-func (c *Context) GlobalString(name string) string {
-        return lookupString(name, c.globalSet)
-}
-
-// Looks up the value of a global string slice flag, returns nil if no string slice flag exists
-func (c *Context) GlobalStringSlice(name string) []string {
-        return lookupStringSlice(name, c.globalSet)
-}
-
-// Looks up the value of a global int slice flag, returns nil if no int slice flag exists
-func (c *Context) GlobalIntSlice(name string) []int {
-        return lookupIntSlice(name, c.globalSet)
-}
-
-// Looks up the value of a global generic flag, returns nil if no generic flag exists
-func (c *Context) GlobalGeneric(name string) interface{} {
-        return lookupGeneric(name, c.globalSet)
-}
-
-// Returns the number of flags set
-func (c *Context) NumFlags() int {
-        return c.flagSet.NFlag()
-}
-
-// Determines if the flag was actually set
-func (c *Context) IsSet(name string) bool {
-        if c.setFlags == nil {
-                c.setFlags = make(map[string]bool)
-                c.flagSet.Visit(func(f *flag.Flag) {
-                        c.setFlags[f.Name] = true
-                })
-        }
-        return c.setFlags[name] == true
-}
-
-// Determines if the global flag was actually set
-func (c *Context) GlobalIsSet(name string) bool {
-        if c.globalSetFlags == nil {
-                c.globalSetFlags = make(map[string]bool)
-                c.globalSet.Visit(func(f *flag.Flag) {
-                        c.globalSetFlags[f.Name] = true
-                })
-        }
-        return c.globalSetFlags[name] == true
-}
-
-// Returns a slice of flag names used in this context.
-func (c *Context) FlagNames() (names []string) {
-        for _, flag := range c.Command.Flags {
-                name := strings.Split(flag.getName(), ",")[0]
-                if name == "help" {
-                        continue
-                }
-                names = append(names, name)
-        }
-        return
-}
-
-// Returns a slice of global flag names used by the app.
-func (c *Context) GlobalFlagNames() (names []string) {
-        for _, flag := range c.App.Flags {
-                name := strings.Split(flag.getName(), ",")[0]
-                if name == "help" || name == "version" {
-                        continue
-                }
-                names = append(names, name)
-        }
-        return
-}
-
-type Args []string
-
-// Returns the command line arguments associated with the context.
-func (c *Context) Args() Args {
-        args := Args(c.flagSet.Args())
-        return args
-}
-
-// Returns the nth argument, or else a blank string
-func (a Args) Get(n int) string {
-        if len(a) > n {
-                return a[n]
-        }
-        return ""
-}
-
-// Returns the first argument, or else a blank string
-func (a Args) First() string {
-        return a.Get(0)
-}
-
-// Return the rest of the arguments (not the first one)
-// or else an empty string slice
-func (a Args) Tail() []string {
-        if len(a) >= 2 {
-                return []string(a)[1:]
-        }
-        return []string{}
-}
-
-// Checks if there are any arguments present
-func (a Args) Present() bool {
-        return len(a) != 0
-}
-
-// Swaps arguments at the given indexes
-func (a Args) Swap(from, to int) error {
-        if from >= len(a) || to >= len(a) {
-                return errors.New("index out of range")
-        }
-        a[from], a[to] = a[to], a[from]
-        return nil
-}
-
-func lookupInt(name string, set *flag.FlagSet) int {
-        f := set.Lookup(name)
-        if f != nil {
-                val, err := strconv.Atoi(f.Value.String())
-                if err != nil {
-                        return 0
-                }
-                return val
-        }
-
-        return 0
-}
-
-func lookupDuration(name string, set *flag.FlagSet) time.Duration {
-        f := set.Lookup(name)
-        if f != nil {
-                val, err := time.ParseDuration(f.Value.String())
-                if err == nil {
-                        return val
-                }
-        }
-
-        return 0
-}
-
-func lookupFloat64(name string, set *flag.FlagSet) float64 {
-        f := set.Lookup(name)
-        if f != nil {
-                val, err := strconv.ParseFloat(f.Value.String(), 64)
-                if err != nil {
-                        return 0
-                }
-                return val
-        }
-
-        return 0
-}
-
-func lookupString(name string, set *flag.FlagSet) string {
-        f := set.Lookup(name)
-        if f != nil {
-                return f.Value.String()
-        }
-
-        return ""
-}
-
-func lookupStringSlice(name string, set *flag.FlagSet) []string {
-        f := set.Lookup(name)
-        if f != nil {
-                return (f.Value.(*StringSlice)).Value()
-
-        }
-
-        return nil
-}
-
-func lookupIntSlice(name string, set *flag.FlagSet) []int {
-        f := set.Lookup(name)
-        if f != nil {
-                return (f.Value.(*IntSlice)).Value()
-
-        }
-
-        return nil
-}
-
-func lookupGeneric(name string, set *flag.FlagSet) interface{} {
-        f := set.Lookup(name)
-        if f != nil {
-                return f.Value
-        }
-        return nil
-}
-
-func lookupBool(name string, set *flag.FlagSet) bool {
-        f := set.Lookup(name)
-        if f != nil {
-                val, err := strconv.ParseBool(f.Value.String())
-                if err != nil {
-                        return false
-                }
-                return val
-        }
-
-        return false
-}
-
-func lookupBoolT(name string, set *flag.FlagSet) bool {
-        f := set.Lookup(name)
-        if f != nil {
-                val, err := strconv.ParseBool(f.Value.String())
-                if err != nil {
-                        return true
-                }
-                return val
-        }
-
-        return false
-}
-
-func copyFlag(name string, ff *flag.Flag, set *flag.FlagSet) {
-        switch ff.Value.(type) {
-        case *StringSlice:
-        default:
-                set.Set(name, ff.Value.String())
-        }
-}
-
-func normalizeFlags(flags []Flag, set *flag.FlagSet) error {
-        visited := make(map[string]bool)
-        set.Visit(func(f *flag.Flag) {
-                visited[f.Name] = true
-        })
-        for _, f := range flags {
-                parts := strings.Split(f.getName(), ",")
-                if len(parts) == 1 {
-                        continue
-                }
-                var ff *flag.Flag
-                for _, name := range parts {
-                        name = strings.Trim(name, " ")
-                        if visited[name] {
-                                if ff != nil {
-                                        return errors.New("Cannot use two forms of the same flag: " + name + " " + ff.Name)
-                                }
-                                ff = set.Lookup(name)
-                        }
-                }
-                if ff == nil {
-                        continue
-                }
-                for _, name := range parts {
-                        name = strings.Trim(name, " ")
-                        if !visited[name] {
-                                copyFlag(name, ff, set)
-                        }
-                }
-        }
-        return nil
-}
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/context_test.go b/Godeps/_workspace/src/github.com/codegangsta/cli/context_test.go
deleted file mode 100644
index 9406e5b..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/context_test.go
+++ /dev/null
@@ -1,111 +0,0 @@
-package cli_test
-
-import (
-        "flag"
-        "testing"
-        "time"
-
-        "github.com/stevenjack/cig/Godeps/_workspace/src/github.com/codegangsta/cli"
-)
-
-func TestNewContext(t *testing.T) {
-        set := flag.NewFlagSet("test", 0)
-        set.Int("myflag", 12, "doc")
-        globalSet := flag.NewFlagSet("test", 0)
-        globalSet.Int("myflag", 42, "doc")
-        command := cli.Command{Name: "mycommand"}
-        c := cli.NewContext(nil, set, globalSet)
-        c.Command = command
-        expect(t, c.Int("myflag"), 12)
-        expect(t, c.GlobalInt("myflag"), 42)
-        expect(t, c.Command.Name, "mycommand")
-}
-
-func TestContext_Int(t *testing.T) {
-        set := flag.NewFlagSet("test", 0)
-        set.Int("myflag", 12, "doc")
-        c := cli.NewContext(nil, set, set)
-        expect(t, c.Int("myflag"), 12)
-}
-
-func TestContext_Duration(t *testing.T) {
-        set := flag.NewFlagSet("test", 0)
-        set.Duration("myflag", time.Duration(12*time.Second), "doc")
-        c := cli.NewContext(nil, set, set)
-        expect(t, c.Duration("myflag"), time.Duration(12*time.Second))
-}
-
-func TestContext_String(t *testing.T) {
-        set := flag.NewFlagSet("test", 0)
-        set.String("myflag", "hello world", "doc")
-        c := cli.NewContext(nil, set, set)
-        expect(t, c.String("myflag"), "hello world")
-}
-
-func TestContext_Bool(t *testing.T) {
-        set := flag.NewFlagSet("test", 0)
-        set.Bool("myflag", false, "doc")
-        c := cli.NewContext(nil, set, set)
-        expect(t, c.Bool("myflag"), false)
-}
-
-func TestContext_BoolT(t *testing.T) {
-        set := flag.NewFlagSet("test", 0)
-        set.Bool("myflag", true, "doc")
-        c := cli.NewContext(nil, set, set)
-        expect(t, c.BoolT("myflag"), true)
-}
-
-func TestContext_Args(t *testing.T) {
-        set := flag.NewFlagSet("test", 0)
-        set.Bool("myflag", false, "doc")
-        c := cli.NewContext(nil, set, set)
-        set.Parse([]string{"--myflag", "bat", "baz"})
-        expect(t, len(c.Args()), 2)
-        expect(t, c.Bool("myflag"), true)
-}
-
-func TestContext_IsSet(t *testing.T) {
-        set := flag.NewFlagSet("test", 0)
-        set.Bool("myflag", false, "doc")
-        set.String("otherflag", "hello world", "doc")
-        globalSet := flag.NewFlagSet("test", 0)
-        globalSet.Bool("myflagGlobal", true, "doc")
-        c := cli.NewContext(nil, set, globalSet)
-        set.Parse([]string{"--myflag", "bat", "baz"})
-        globalSet.Parse([]string{"--myflagGlobal", "bat", "baz"})
-        expect(t, c.IsSet("myflag"), true)
-        expect(t, c.IsSet("otherflag"), false)
-        expect(t, c.IsSet("bogusflag"), false)
-        expect(t, c.IsSet("myflagGlobal"), false)
-}
-
-func TestContext_GlobalIsSet(t *testing.T) {
-        set := flag.NewFlagSet("test", 0)
-        set.Bool("myflag", false, "doc")
-        set.String("otherflag", "hello world", "doc")
-        globalSet := flag.NewFlagSet("test", 0)
-        globalSet.Bool("myflagGlobal", true, "doc")
-        globalSet.Bool("myflagGlobalUnset", true, "doc")
-        c := cli.NewContext(nil, set, globalSet)
-        set.Parse([]string{"--myflag", "bat", "baz"})
-        globalSet.Parse([]string{"--myflagGlobal", "bat", "baz"})
-        expect(t, c.GlobalIsSet("myflag"), false)
-        expect(t, c.GlobalIsSet("otherflag"), false)
-        expect(t, c.GlobalIsSet("bogusflag"), false)
-        expect(t, c.GlobalIsSet("myflagGlobal"), true)
-        expect(t, c.GlobalIsSet("myflagGlobalUnset"), false)
-        expect(t, c.GlobalIsSet("bogusGlobal"), false)
-}
-
-func TestContext_NumFlags(t *testing.T) {
-        set := flag.NewFlagSet("test", 0)
-        set.Bool("myflag", false, "doc")
-        set.String("otherflag", "hello world", "doc")
-        globalSet := flag.NewFlagSet("test", 0)
-        globalSet.Bool("myflagGlobal", true, "doc")
-        c := cli.NewContext(nil, set, globalSet)
-        set.Parse([]string{"--myflag", "--otherflag=foo"})
-        globalSet.Parse([]string{"--myflagGlobal"})
-        expect(t, c.NumFlags(), 2)
-}
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/flag.go b/Godeps/_workspace/src/github.com/codegangsta/cli/flag.go
deleted file mode 100644
index 28be0e6..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/flag.go
+++ /dev/null
@@ -1,454 +0,0 @@
-package cli
-
-import (
-        "flag"
-        "fmt"
-        "os"
-        "strconv"
-        "strings"
-        "time"
-)
-
-// This flag enables bash-completion for all commands and subcommands
-var BashCompletionFlag = BoolFlag{
-        Name: "generate-bash-completion",
-}
-
-// This flag prints the version for the application
-var VersionFlag = BoolFlag{
-        Name:  "version, v",
-        Usage: "print the version",
-}
-
-// This flag prints the help for all commands and subcommands
-// Set to the zero value (BoolFlag{}) to disable flag -- keeps subcommand
-// unless HideHelp is set to true)
-var HelpFlag = BoolFlag{
-        Name:  "help, h",
-        Usage: "show help",
-}
-
-// Flag is a common interface related to parsing flags in cli.
-// For more advanced flag parsing techniques, it is recomended that
-// this interface be implemented.
-type Flag interface {
-        fmt.Stringer
-        // Apply Flag settings to the given flag set
-        Apply(*flag.FlagSet)
-        getName() string
-}
-
-func flagSet(name string, flags []Flag) *flag.FlagSet {
-        set := flag.NewFlagSet(name, flag.ContinueOnError)
-
-        for _, f := range flags {
-                f.Apply(set)
-        }
-        return set
-}
-
-func eachName(longName string, fn func(string)) {
-        parts := strings.Split(longName, ",")
-        for _, name := range parts {
-                name = strings.Trim(name, " ")
-                fn(name)
-        }
-}
-
-// Generic is a generic parseable type identified by a specific flag
-type Generic interface {
-        Set(value string) error
-        String() string
-}
-
-// GenericFlag is the flag type for types implementing Generic
-type GenericFlag struct {
-        Name   string
-        Value  Generic
-        Usage  string
-        EnvVar string
-}
-
-// String returns the string representation of the generic flag to display the
-// help text to the user (uses the String() method of the generic flag to show
-// the value)
-func (f GenericFlag) String() string {
-        return withEnvHint(f.EnvVar, fmt.Sprintf("%s%s \"%v\"\t%v", prefixFor(f.Name), f.Name, f.Value, f.Usage))
-}
-
-// Apply takes the flagset and calls Set on the generic flag with the value
-// provided by the user for parsing by the flag
-func (f GenericFlag) Apply(set *flag.FlagSet) {
-        val := f.Value
-        if f.EnvVar != "" {
-                for _, envVar := range strings.Split(f.EnvVar, ",") {
-                        envVar = strings.TrimSpace(envVar)
-                        if envVal := os.Getenv(envVar); envVal != "" {
-                                val.Set(envVal)
-                                break
-                        }
-                }
-        }
-
-        eachName(f.Name, func(name string) {
-                set.Var(f.Value, name, f.Usage)
-        })
-}
-
-func (f GenericFlag) getName() string {
-        return f.Name
-}
-
-type StringSlice []string
-
-func (f *StringSlice) Set(value string) error {
-        *f = append(*f, value)
-        return nil
-}
-
-func (f *StringSlice) String() string {
-        return fmt.Sprintf("%s", *f)
-}
-
-func (f *StringSlice) Value() []string {
-        return *f
-}
-
-type StringSliceFlag struct {
-        Name   string
-        Value  *StringSlice
-        Usage  string
-        EnvVar string
-}
-
-func (f StringSliceFlag) String() string {
-        firstName := strings.Trim(strings.Split(f.Name, ",")[0], " ")
-        pref := prefixFor(firstName)
-        return withEnvHint(f.EnvVar, fmt.Sprintf("%s [%v]\t%v", prefixedNames(f.Name), pref+firstName+" option "+pref+firstName+" option", f.Usage))
-}
-
-func (f StringSliceFlag) Apply(set *flag.FlagSet) {
-        if f.EnvVar != "" {
-                for _, envVar := range strings.Split(f.EnvVar, ",") {
-                        envVar = strings.TrimSpace(envVar)
-                        if envVal := os.Getenv(envVar); envVal != "" {
-                                newVal := &StringSlice{}
-                                for _, s := range strings.Split(envVal, ",") {
-                                        s = strings.TrimSpace(s)
-                                        newVal.Set(s)
-                                }
-                                f.Value = newVal
-                                break
-                        }
-                }
-        }
-
-        eachName(f.Name, func(name string) {
-                set.Var(f.Value, name, f.Usage)
-        })
-}
-
-func (f StringSliceFlag) getName() string {
-        return f.Name
-}
-
-type IntSlice []int
-
-func (f *IntSlice) Set(value string) error {
-
-        tmp, err := strconv.Atoi(value)
-        if err != nil {
-                return err
-        } else {
-                *f = append(*f, tmp)
-        }
-        return nil
-}
-
-func (f *IntSlice) String() string {
-        return fmt.Sprintf("%d", *f)
-}
-
-func (f *IntSlice) Value() []int {
-        return *f
-}
-
-type IntSliceFlag struct {
-        Name   string
-        Value  *IntSlice
-        Usage  string
-        EnvVar string
-}
-
-func (f IntSliceFlag) String() string {
-        firstName := strings.Trim(strings.Split(f.Name, ",")[0], " ")
-        pref := prefixFor(firstName)
-        return withEnvHint(f.EnvVar, fmt.Sprintf("%s [%v]\t%v", prefixedNames(f.Name), pref+firstName+" option "+pref+firstName+" option", f.Usage))
-}
-
-func (f IntSliceFlag) Apply(set *flag.FlagSet) {
-        if f.EnvVar != "" {
-                for _, envVar := range strings.Split(f.EnvVar, ",") {
-                        envVar = strings.TrimSpace(envVar)
-                        if envVal := os.Getenv(envVar); envVal != "" {
-                                newVal := &IntSlice{}
-                                for _, s := range strings.Split(envVal, ",") {
-                                        s = strings.TrimSpace(s)
-                                        err := newVal.Set(s)
-                                        if err != nil {
-                                                fmt.Fprintf(os.Stderr, err.Error())
-                                        }
-                                }
-                                f.Value = newVal
-                                break
-                        }
-                }
-        }
-
-        eachName(f.Name, func(name string) {
-                set.Var(f.Value, name, f.Usage)
-        })
-}
-
-func (f IntSliceFlag) getName() string {
-        return f.Name
-}
-
-type BoolFlag struct {
-        Name   string
-        Usage  string
-        EnvVar string
-}
-
-func (f BoolFlag) String() string {
-        return withEnvHint(f.EnvVar, fmt.Sprintf("%s\t%v", prefixedNames(f.Name), f.Usage))
-}
-
-func (f BoolFlag) Apply(set *flag.FlagSet) {
-        val := false
-        if f.EnvVar != "" {
-                for _, envVar := range strings.Split(f.EnvVar, ",") {
-                        envVar = strings.TrimSpace(envVar)
-                        if envVal := os.Getenv(envVar); envVal != "" {
-                                envValBool, err := strconv.ParseBool(envVal)
-                                if err == nil {
-                                        val = envValBool
-                                }
-                                break
-                        }
-                }
-        }
-
-        eachName(f.Name, func(name string) {
-                set.Bool(name, val, f.Usage)
-        })
-}
-
-func (f BoolFlag) getName() string {
-        return f.Name
-}
-
-type BoolTFlag struct {
-        Name   string
-        Usage  string
-        EnvVar string
-}
-
-func (f BoolTFlag) String() string {
-        return withEnvHint(f.EnvVar, fmt.Sprintf("%s\t%v", prefixedNames(f.Name), f.Usage))
-}
-
-func (f BoolTFlag) Apply(set *flag.FlagSet) {
-        val := true
-        if f.EnvVar != "" {
-                for _, envVar := range strings.Split(f.EnvVar, ",") {
-                        envVar = strings.TrimSpace(envVar)
-                        if envVal := os.Getenv(envVar); envVal != "" {
-                                envValBool, err := strconv.ParseBool(envVal)
-                                if err == nil {
-                                        val = envValBool
-                                        break
-                                }
-                        }
-                }
-        }
-
-        eachName(f.Name, func(name string) {
-                set.Bool(name, val, f.Usage)
-        })
-}
-
-func (f BoolTFlag) getName() string {
-        return f.Name
-}
-
-type StringFlag struct {
-        Name   string
-        Value  string
-        Usage  string
-        EnvVar string
-}
-
-func (f StringFlag) String() string {
-        var fmtString string
-        fmtString = "%s %v\t%v"
-
-        if len(f.Value) > 0 {
-                fmtString = "%s \"%v\"\t%v"
-        } else {
-                fmtString = "%s %v\t%v"
-        }
-
-        return withEnvHint(f.EnvVar, fmt.Sprintf(fmtString, prefixedNames(f.Name), f.Value, f.Usage))
-}
-
-func (f StringFlag) Apply(set *flag.FlagSet) {
-        if f.EnvVar != "" {
-                for _, envVar := range strings.Split(f.EnvVar, ",") {
-                        envVar = strings.TrimSpace(envVar)
-                        if envVal := os.Getenv(envVar); envVal != "" {
-                                f.Value = envVal
-                                break
-                        }
-                }
-        }
-
-        eachName(f.Name, func(name string) {
-                set.String(name, f.Value, f.Usage)
-        })
-}
-
-func (f StringFlag) getName() string {
-        return f.Name
-}
-
-type IntFlag struct {
-        Name   string
-        Value  int
-        Usage  string
-        EnvVar string
-}
-
-func (f IntFlag) String() string {
-        return withEnvHint(f.EnvVar, fmt.Sprintf("%s \"%v\"\t%v", prefixedNames(f.Name), f.Value, f.Usage))
-}
-
-func (f IntFlag) Apply(set *flag.FlagSet) {
-        if f.EnvVar != "" {
-                for _, envVar := range strings.Split(f.EnvVar, ",") {
-                        envVar = strings.TrimSpace(envVar)
-                        if envVal := os.Getenv(envVar); envVal != "" {
-                                envValInt, err := strconv.ParseInt(envVal, 0, 64)
-                                if err == nil {
-                                        f.Value = int(envValInt)
-                                        break
-                                }
-                        }
-                }
-        }
-
-        eachName(f.Name, func(name string) {
-                set.Int(name, f.Value, f.Usage)
-        })
-}
-
-func (f IntFlag) getName() string {
-        return f.Name
-}
-
-type DurationFlag struct {
-        Name   string
-        Value  time.Duration
-        Usage  string
-        EnvVar string
-}
-
-func (f DurationFlag) String() string {
-        return withEnvHint(f.EnvVar, fmt.Sprintf("%s \"%v\"\t%v", prefixedNames(f.Name), f.Value, f.Usage))
-}
-
-func (f DurationFlag) Apply(set *flag.FlagSet) {
-        if f.EnvVar != "" {
-                for _, envVar := range strings.Split(f.EnvVar, ",") {
-                        envVar = strings.TrimSpace(envVar)
-                        if envVal := os.Getenv(envVar); envVal != "" {
-                                envValDuration, err := time.ParseDuration(envVal)
-                                if err == nil {
-                                        f.Value = envValDuration
-                                        break
-                                }
-                        }
-                }
-        }
-
-        eachName(f.Name, func(name string) {
-                set.Duration(name, f.Value, f.Usage)
-        })
-}
-
-func (f DurationFlag) getName() string {
-        return f.Name
-}
-
-type Float64Flag struct {
-        Name   string
-        Value  float64
-        Usage  string
-        EnvVar string
-}
-
-func (f Float64Flag) String() string {
-        return withEnvHint(f.EnvVar, fmt.Sprintf("%s \"%v\"\t%v", prefixedNames(f.Name), f.Value, f.Usage))
-}
-
-func (f Float64Flag) Apply(set *flag.FlagSet) {
-        if f.EnvVar != "" {
-                for _, envVar := range strings.Split(f.EnvVar, ",") {
-                        envVar = strings.TrimSpace(envVar)
-                        if envVal := os.Getenv(envVar); envVal != "" {
-                                envValFloat, err := strconv.ParseFloat(envVal, 10)
-                                if err == nil {
-                                        f.Value = float64(envValFloat)
-                                }
-                        }
-                }
-        }
-
-        eachName(f.Name, func(name string) {
-                set.Float64(name, f.Value, f.Usage)
-        })
-}
-
-func (f Float64Flag) getName() string {
-        return f.Name
-}
-
-func prefixFor(name string) (prefix string) {
-        if len(name) == 1 {
-                prefix = "-"
-        } else {
-                prefix = "--"
-        }
-
-        return
-}
-
-func prefixedNames(fullName string) (prefixed string) {
-        parts := strings.Split(fullName, ",")
-        for i, name := range parts {
-                name = strings.Trim(name, " ")
-                prefixed += prefixFor(name) + name
-                if i < len(parts)-1 {
-                        prefixed += ", "
-                }
-        }
-        return
-}
-
-func withEnvHint(envVar, str string) string {
-        envText := ""
-        if envVar != "" {
-                envText = fmt.Sprintf(" [$%s]", strings.Join(strings.Split(envVar, ","), ", $"))
-        }
-        return str + envText
-}
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/flag_test.go b/Godeps/_workspace/src/github.com/codegangsta/cli/flag_test.go
deleted file mode 100644
index ee2fc1e..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/flag_test.go
+++ /dev/null
@@ -1,742 +0,0 @@
-package cli_test
-
-import (
-        "fmt"
-        "os"
-        "reflect"
-        "strings"
-        "testing"
-
-        "github.com/stevenjack/cig/Godeps/_workspace/src/github.com/codegangsta/cli"
-)
-
-var boolFlagTests = []struct {
-        name     string
-        expected string
-}{
-        {"help", "--help\t"},
-        {"h", "-h\t"},
-}
-
-func TestBoolFlagHelpOutput(t *testing.T) {
-
-        for _, test := range boolFlagTests {
-                flag := cli.BoolFlag{Name: test.name}
-                output := flag.String()
-
-                if output != test.expected {
-                        t.Errorf("%s does not match %s", output, test.expected)
-                }
-        }
-}
-
-var stringFlagTests = []struct {
-        name     string
-        value    string
-        expected string
-}{
-        {"help", "", "--help \t"},
-        {"h", "", "-h \t"},
-        {"h", "", "-h \t"},
-        {"test", "Something", "--test \"Something\"\t"},
-}
-
-func TestStringFlagHelpOutput(t *testing.T) {
-
-        for _, test := range stringFlagTests {
-                flag := cli.StringFlag{Name: test.name, Value: test.value}
-                output := flag.String()
-
-                if output != test.expected {
-                        t.Errorf("%s does not match %s", output, test.expected)
-                }
-        }
-}
-
-func TestStringFlagWithEnvVarHelpOutput(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_FOO", "derp")
-        for _, test := range stringFlagTests {
-                flag := cli.StringFlag{Name: test.name, Value: test.value, EnvVar: "APP_FOO"}
-                output := flag.String()
-
-                if !strings.HasSuffix(output, " [$APP_FOO]") {
-                        t.Errorf("%s does not end with [$APP_FOO]", output)
-                }
-        }
-}
-
-var stringSliceFlagTests = []struct {
-        name     string
-        value    *cli.StringSlice
-        expected string
-}{
-        {"help", func() *cli.StringSlice {
-                s := &cli.StringSlice{}
-                s.Set("")
-                return s
-        }(), "--help [--help option --help option]\t"},
-        {"h", func() *cli.StringSlice {
-                s := &cli.StringSlice{}
-                s.Set("")
-                return s
-        }(), "-h [-h option -h option]\t"},
-        {"h", func() *cli.StringSlice {
-                s := &cli.StringSlice{}
-                s.Set("")
-                return s
-        }(), "-h [-h option -h option]\t"},
-        {"test", func() *cli.StringSlice {
-                s := &cli.StringSlice{}
-                s.Set("Something")
-                return s
-        }(), "--test [--test option --test option]\t"},
-}
-
-func TestStringSliceFlagHelpOutput(t *testing.T) {
-
-        for _, test := range stringSliceFlagTests {
-                flag := cli.StringSliceFlag{Name: test.name, Value: test.value}
-                output := flag.String()
-
-                if output != test.expected {
-                        t.Errorf("%q does not match %q", output, test.expected)
-                }
-        }
-}
-
-func TestStringSliceFlagWithEnvVarHelpOutput(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_QWWX", "11,4")
-        for _, test := range stringSliceFlagTests {
-                flag := cli.StringSliceFlag{Name: test.name, Value: test.value, EnvVar: "APP_QWWX"}
-                output := flag.String()
-
-                if !strings.HasSuffix(output, " [$APP_QWWX]") {
-                        t.Errorf("%q does not end with [$APP_QWWX]", output)
-                }
-        }
-}
-
-var intFlagTests = []struct {
-        name     string
-        expected string
-}{
-        {"help", "--help \"0\"\t"},
-        {"h", "-h \"0\"\t"},
-}
-
-func TestIntFlagHelpOutput(t *testing.T) {
-
-        for _, test := range intFlagTests {
-                flag := cli.IntFlag{Name: test.name}
-                output := flag.String()
-
-                if output != test.expected {
-                        t.Errorf("%s does not match %s", output, test.expected)
-                }
-        }
-}
-
-func TestIntFlagWithEnvVarHelpOutput(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_BAR", "2")
-        for _, test := range intFlagTests {
-                flag := cli.IntFlag{Name: test.name, EnvVar: "APP_BAR"}
-                output := flag.String()
-
-                if !strings.HasSuffix(output, " [$APP_BAR]") {
-                        t.Errorf("%s does not end with [$APP_BAR]", output)
-                }
-        }
-}
-
-var durationFlagTests = []struct {
-        name     string
-        expected string
-}{
-        {"help", "--help \"0\"\t"},
-        {"h", "-h \"0\"\t"},
-}
-
-func TestDurationFlagHelpOutput(t *testing.T) {
-
-        for _, test := range durationFlagTests {
-                flag := cli.DurationFlag{Name: test.name}
-                output := flag.String()
-
-                if output != test.expected {
-                        t.Errorf("%s does not match %s", output, test.expected)
-                }
-        }
-}
-
-func TestDurationFlagWithEnvVarHelpOutput(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_BAR", "2h3m6s")
-        for _, test := range durationFlagTests {
-                flag := cli.DurationFlag{Name: test.name, EnvVar: "APP_BAR"}
-                output := flag.String()
-
-                if !strings.HasSuffix(output, " [$APP_BAR]") {
-                        t.Errorf("%s does not end with [$APP_BAR]", output)
-                }
-        }
-}
-
-var intSliceFlagTests = []struct {
-        name     string
-        value    *cli.IntSlice
-        expected string
-}{
-        {"help", &cli.IntSlice{}, "--help [--help option --help option]\t"},
-        {"h", &cli.IntSlice{}, "-h [-h option -h option]\t"},
-        {"h", &cli.IntSlice{}, "-h [-h option -h option]\t"},
-        {"test", func() *cli.IntSlice {
-                i := &cli.IntSlice{}
-                i.Set("9")
-                return i
-        }(), "--test [--test option --test option]\t"},
-}
-
-func TestIntSliceFlagHelpOutput(t *testing.T) {
-
-        for _, test := range intSliceFlagTests {
-                flag := cli.IntSliceFlag{Name: test.name, Value: test.value}
-                output := flag.String()
-
-                if output != test.expected {
-                        t.Errorf("%q does not match %q", output, test.expected)
-                }
-        }
-}
-
-func TestIntSliceFlagWithEnvVarHelpOutput(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_SMURF", "42,3")
-        for _, test := range intSliceFlagTests {
-                flag := cli.IntSliceFlag{Name: test.name, Value: test.value, EnvVar: "APP_SMURF"}
-                output := flag.String()
-
-                if !strings.HasSuffix(output, " [$APP_SMURF]") {
-                        t.Errorf("%q does not end with [$APP_SMURF]", output)
-                }
-        }
-}
-
-var float64FlagTests = []struct {
-        name     string
-        expected string
-}{
-        {"help", "--help \"0\"\t"},
-        {"h", "-h \"0\"\t"},
-}
-
-func TestFloat64FlagHelpOutput(t *testing.T) {
-
-        for _, test := range float64FlagTests {
-                flag := cli.Float64Flag{Name: test.name}
-                output := flag.String()
-
-                if output != test.expected {
-                        t.Errorf("%s does not match %s", output, test.expected)
-                }
-        }
-}
-
-func TestFloat64FlagWithEnvVarHelpOutput(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_BAZ", "99.4")
-        for _, test := range float64FlagTests {
-                flag := cli.Float64Flag{Name: test.name, EnvVar: "APP_BAZ"}
-                output := flag.String()
-
-                if !strings.HasSuffix(output, " [$APP_BAZ]") {
-                        t.Errorf("%s does not end with [$APP_BAZ]", output)
-                }
-        }
-}
-
-var genericFlagTests = []struct {
-        name     string
-        value    cli.Generic
-        expected string
-}{
-        {"test", &Parser{"abc", "def"}, "--test \"abc,def\"\ttest flag"},
-        {"t", &Parser{"abc", "def"}, "-t \"abc,def\"\ttest flag"},
-}
-
-func TestGenericFlagHelpOutput(t *testing.T) {
-
-        for _, test := range genericFlagTests {
-                flag := cli.GenericFlag{Name: test.name, Value: test.value, Usage: "test flag"}
-                output := flag.String()
-
-                if output != test.expected {
-                        t.Errorf("%q does not match %q", output, test.expected)
-                }
-        }
-}
-
-func TestGenericFlagWithEnvVarHelpOutput(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_ZAP", "3")
-        for _, test := range genericFlagTests {
-                flag := cli.GenericFlag{Name: test.name, EnvVar: "APP_ZAP"}
-                output := flag.String()
-
-                if !strings.HasSuffix(output, " [$APP_ZAP]") {
-                        t.Errorf("%s does not end with [$APP_ZAP]", output)
-                }
-        }
-}
-
-func TestParseMultiString(t *testing.T) {
-        (&cli.App{
-                Flags: []cli.Flag{
-                        cli.StringFlag{Name: "serve, s"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.String("serve") != "10" {
-                                t.Errorf("main name not set")
-                        }
-                        if ctx.String("s") != "10" {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }).Run([]string{"run", "-s", "10"})
-}
-
-func TestParseMultiStringFromEnv(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_COUNT", "20")
-        (&cli.App{
-                Flags: []cli.Flag{
-                        cli.StringFlag{Name: "count, c", EnvVar: "APP_COUNT"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.String("count") != "20" {
-                                t.Errorf("main name not set")
-                        }
-                        if ctx.String("c") != "20" {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }).Run([]string{"run"})
-}
-
-func TestParseMultiStringFromEnvCascade(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_COUNT", "20")
-        (&cli.App{
-                Flags: []cli.Flag{
-                        cli.StringFlag{Name: "count, c", EnvVar: "COMPAT_COUNT,APP_COUNT"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.String("count") != "20" {
-                                t.Errorf("main name not set")
-                        }
-                        if ctx.String("c") != "20" {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }).Run([]string{"run"})
-}
-
-func TestParseMultiStringSlice(t *testing.T) {
-        (&cli.App{
-                Flags: []cli.Flag{
-                        cli.StringSliceFlag{Name: "serve, s", Value: &cli.StringSlice{}},
-                },
-                Action: func(ctx *cli.Context) {
-                        if !reflect.DeepEqual(ctx.StringSlice("serve"), []string{"10", "20"}) {
-                                t.Errorf("main name not set")
-                        }
-                        if !reflect.DeepEqual(ctx.StringSlice("s"), []string{"10", "20"}) {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }).Run([]string{"run", "-s", "10", "-s", "20"})
-}
-
-func TestParseMultiStringSliceFromEnv(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_INTERVALS", "20,30,40")
-
-        (&cli.App{
-                Flags: []cli.Flag{
-                        cli.StringSliceFlag{Name: "intervals, i", Value: &cli.StringSlice{}, EnvVar: "APP_INTERVALS"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if !reflect.DeepEqual(ctx.StringSlice("intervals"), []string{"20", "30", "40"}) {
-                                t.Errorf("main name not set from env")
-                        }
-                        if !reflect.DeepEqual(ctx.StringSlice("i"), []string{"20", "30", "40"}) {
-                                t.Errorf("short name not set from env")
-                        }
-                },
-        }).Run([]string{"run"})
-}
-
-func TestParseMultiStringSliceFromEnvCascade(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_INTERVALS", "20,30,40")
-
-        (&cli.App{
-                Flags: []cli.Flag{
-                        cli.StringSliceFlag{Name: "intervals, i", Value: &cli.StringSlice{}, EnvVar: "COMPAT_INTERVALS,APP_INTERVALS"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if !reflect.DeepEqual(ctx.StringSlice("intervals"), []string{"20", "30", "40"}) {
-                                t.Errorf("main name not set from env")
-                        }
-                        if !reflect.DeepEqual(ctx.StringSlice("i"), []string{"20", "30", "40"}) {
-                                t.Errorf("short name not set from env")
-                        }
-                },
-        }).Run([]string{"run"})
-}
-
-func TestParseMultiInt(t *testing.T) {
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.IntFlag{Name: "serve, s"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.Int("serve") != 10 {
-                                t.Errorf("main name not set")
-                        }
-                        if ctx.Int("s") != 10 {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }
-        a.Run([]string{"run", "-s", "10"})
-}
-
-func TestParseMultiIntFromEnv(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_TIMEOUT_SECONDS", "10")
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.IntFlag{Name: "timeout, t", EnvVar: "APP_TIMEOUT_SECONDS"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.Int("timeout") != 10 {
-                                t.Errorf("main name not set")
-                        }
-                        if ctx.Int("t") != 10 {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }
-        a.Run([]string{"run"})
-}
-
-func TestParseMultiIntFromEnvCascade(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_TIMEOUT_SECONDS", "10")
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.IntFlag{Name: "timeout, t", EnvVar: "COMPAT_TIMEOUT_SECONDS,APP_TIMEOUT_SECONDS"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.Int("timeout") != 10 {
-                                t.Errorf("main name not set")
-                        }
-                        if ctx.Int("t") != 10 {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }
-        a.Run([]string{"run"})
-}
-
-func TestParseMultiIntSlice(t *testing.T) {
-        (&cli.App{
-                Flags: []cli.Flag{
-                        cli.IntSliceFlag{Name: "serve, s", Value: &cli.IntSlice{}},
-                },
-                Action: func(ctx *cli.Context) {
-                        if !reflect.DeepEqual(ctx.IntSlice("serve"), []int{10, 20}) {
-                                t.Errorf("main name not set")
-                        }
-                        if !reflect.DeepEqual(ctx.IntSlice("s"), []int{10, 20}) {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }).Run([]string{"run", "-s", "10", "-s", "20"})
-}
-
-func TestParseMultiIntSliceFromEnv(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_INTERVALS", "20,30,40")
-
-        (&cli.App{
-                Flags: []cli.Flag{
-                        cli.IntSliceFlag{Name: "intervals, i", Value: &cli.IntSlice{}, EnvVar: "APP_INTERVALS"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if !reflect.DeepEqual(ctx.IntSlice("intervals"), []int{20, 30, 40}) {
-                                t.Errorf("main name not set from env")
-                        }
-                        if !reflect.DeepEqual(ctx.IntSlice("i"), []int{20, 30, 40}) {
-                                t.Errorf("short name not set from env")
-                        }
-                },
-        }).Run([]string{"run"})
-}
-
-func TestParseMultiIntSliceFromEnvCascade(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_INTERVALS", "20,30,40")
-
-        (&cli.App{
-                Flags: []cli.Flag{
-                        cli.IntSliceFlag{Name: "intervals, i", Value: &cli.IntSlice{}, EnvVar: "COMPAT_INTERVALS,APP_INTERVALS"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if !reflect.DeepEqual(ctx.IntSlice("intervals"), []int{20, 30, 40}) {
-                                t.Errorf("main name not set from env")
-                        }
-                        if !reflect.DeepEqual(ctx.IntSlice("i"), []int{20, 30, 40}) {
-                                t.Errorf("short name not set from env")
-                        }
-                },
-        }).Run([]string{"run"})
-}
-
-func TestParseMultiFloat64(t *testing.T) {
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.Float64Flag{Name: "serve, s"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.Float64("serve") != 10.2 {
-                                t.Errorf("main name not set")
-                        }
-                        if ctx.Float64("s") != 10.2 {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }
-        a.Run([]string{"run", "-s", "10.2"})
-}
-
-func TestParseMultiFloat64FromEnv(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_TIMEOUT_SECONDS", "15.5")
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.Float64Flag{Name: "timeout, t", EnvVar: "APP_TIMEOUT_SECONDS"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.Float64("timeout") != 15.5 {
-                                t.Errorf("main name not set")
-                        }
-                        if ctx.Float64("t") != 15.5 {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }
-        a.Run([]string{"run"})
-}
-
-func TestParseMultiFloat64FromEnvCascade(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_TIMEOUT_SECONDS", "15.5")
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.Float64Flag{Name: "timeout, t", EnvVar: "COMPAT_TIMEOUT_SECONDS,APP_TIMEOUT_SECONDS"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.Float64("timeout") != 15.5 {
-                                t.Errorf("main name not set")
-                        }
-                        if ctx.Float64("t") != 15.5 {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }
-        a.Run([]string{"run"})
-}
-
-func TestParseMultiBool(t *testing.T) {
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.BoolFlag{Name: "serve, s"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.Bool("serve") != true {
-                                t.Errorf("main name not set")
-                        }
-                        if ctx.Bool("s") != true {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }
-        a.Run([]string{"run", "--serve"})
-}
-
-func TestParseMultiBoolFromEnv(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_DEBUG", "1")
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.BoolFlag{Name: "debug, d", EnvVar: "APP_DEBUG"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.Bool("debug") != true {
-                                t.Errorf("main name not set from env")
-                        }
-                        if ctx.Bool("d") != true {
-                                t.Errorf("short name not set from env")
-                        }
-                },
-        }
-        a.Run([]string{"run"})
-}
-
-func TestParseMultiBoolFromEnvCascade(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_DEBUG", "1")
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.BoolFlag{Name: "debug, d", EnvVar: "COMPAT_DEBUG,APP_DEBUG"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.Bool("debug") != true {
-                                t.Errorf("main name not set from env")
-                        }
-                        if ctx.Bool("d") != true {
-                                t.Errorf("short name not set from env")
-                        }
-                },
-        }
-        a.Run([]string{"run"})
-}
-
-func TestParseMultiBoolT(t *testing.T) {
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.BoolTFlag{Name: "serve, s"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.BoolT("serve") != true {
-                                t.Errorf("main name not set")
-                        }
-                        if ctx.BoolT("s") != true {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }
-        a.Run([]string{"run", "--serve"})
-}
-
-func TestParseMultiBoolTFromEnv(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_DEBUG", "0")
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.BoolTFlag{Name: "debug, d", EnvVar: "APP_DEBUG"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.BoolT("debug") != false {
-                                t.Errorf("main name not set from env")
-                        }
-                        if ctx.BoolT("d") != false {
-                                t.Errorf("short name not set from env")
-                        }
-                },
-        }
-        a.Run([]string{"run"})
-}
-
-func TestParseMultiBoolTFromEnvCascade(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_DEBUG", "0")
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.BoolTFlag{Name: "debug, d", EnvVar: "COMPAT_DEBUG,APP_DEBUG"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if ctx.BoolT("debug") != false {
-                                t.Errorf("main name not set from env")
-                        }
-                        if ctx.BoolT("d") != false {
-                                t.Errorf("short name not set from env")
-                        }
-                },
-        }
-        a.Run([]string{"run"})
-}
-
-type Parser [2]string
-
-func (p *Parser) Set(value string) error {
-        parts := strings.Split(value, ",")
-        if len(parts) != 2 {
-                return fmt.Errorf("invalid format")
-        }
-
-        (*p)[0] = parts[0]
-        (*p)[1] = parts[1]
-
-        return nil
-}
-
-func (p *Parser) String() string {
-        return fmt.Sprintf("%s,%s", p[0], p[1])
-}
-
-func TestParseGeneric(t *testing.T) {
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.GenericFlag{Name: "serve, s", Value: &Parser{}},
-                },
-                Action: func(ctx *cli.Context) {
-                        if !reflect.DeepEqual(ctx.Generic("serve"), &Parser{"10", "20"}) {
-                                t.Errorf("main name not set")
-                        }
-                        if !reflect.DeepEqual(ctx.Generic("s"), &Parser{"10", "20"}) {
-                                t.Errorf("short name not set")
-                        }
-                },
-        }
-        a.Run([]string{"run", "-s", "10,20"})
-}
-
-func TestParseGenericFromEnv(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_SERVE", "20,30")
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.GenericFlag{Name: "serve, s", Value: &Parser{}, EnvVar: "APP_SERVE"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if !reflect.DeepEqual(ctx.Generic("serve"), &Parser{"20", "30"}) {
-                                t.Errorf("main name not set from env")
-                        }
-                        if !reflect.DeepEqual(ctx.Generic("s"), &Parser{"20", "30"}) {
-                                t.Errorf("short name not set from env")
-                        }
-                },
-        }
-        a.Run([]string{"run"})
-}
-
-func TestParseGenericFromEnvCascade(t *testing.T) {
-        os.Clearenv()
-        os.Setenv("APP_FOO", "99,2000")
-        a := cli.App{
-                Flags: []cli.Flag{
-                        cli.GenericFlag{Name: "foos", Value: &Parser{}, EnvVar: "COMPAT_FOO,APP_FOO"},
-                },
-                Action: func(ctx *cli.Context) {
-                        if !reflect.DeepEqual(ctx.Generic("foos"), &Parser{"99", "2000"}) {
-                                t.Errorf("value not set from env")
-                        }
-                },
-        }
-        a.Run([]string{"run"})
-}
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/help.go b/Godeps/_workspace/src/github.com/codegangsta/cli/help.go
deleted file mode 100644
index 093e50b..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/help.go
+++ /dev/null
@@ -1,215 +0,0 @@
-package cli
-
-import "fmt"
-
-// The text template for the Default help topic.
-// cli.go uses text/template to render templates. You can
-// render custom help text by setting this variable.
-var AppHelpTemplate = `NAME:
-   {{.Name}} - {{.Usage}}
-
-USAGE:
-   {{.Name}} {{if .Flags}}[global options] {{end}}command{{if .Flags}} [command options]{{end}} [arguments...]
-
-VERSION:
-   {{.Version}}
-
-AUTHOR(S):
-   {{range .Authors}}{{ . }}
-   {{end}}
-COMMANDS:
-   {{range .Commands}}{{join .Names ", "}}{{ "\t" }}{{.Usage}}
-   {{end}}{{if .Flags}}
-GLOBAL OPTIONS:
-   {{range .Flags}}{{.}}
-   {{end}}{{end}}
-`
-
-// The text template for the command help topic.
-// cli.go uses text/template to render templates. You can
-// render custom help text by setting this variable.
-var CommandHelpTemplate = `NAME:
-   {{.Name}} - {{.Usage}}
-
-USAGE:
-   command {{.Name}}{{if .Flags}} [command options]{{end}} [arguments...]{{if .Description}}
-
-DESCRIPTION:
-   {{.Description}}{{end}}{{if .Flags}}
-
-OPTIONS:
-   {{range .Flags}}{{.}}
-   {{end}}{{ end }}
-`
-
-// The text template for the subcommand help topic.
-// cli.go uses text/template to render templates. You can
-// render custom help text by setting this variable.
-var SubcommandHelpTemplate = `NAME:
-   {{.Name}} - {{.Usage}}
-
-USAGE:
-   {{.Name}} command{{if .Flags}} [command options]{{end}} [arguments...]
-
-COMMANDS:
-   {{range .Commands}}{{join .Names ", "}}{{ "\t" }}{{.Usage}}
-   {{end}}{{if .Flags}}
-OPTIONS:
-   {{range .Flags}}{{.}}
-   {{end}}{{end}}
-`
-
-var helpCommand = Command{
-        Name:    "help",
-        Aliases: []string{"h"},
-        Usage:   "Shows a list of commands or help for one command",
-        Action: func(c *Context) {
-                args := c.Args()
-                if args.Present() {
-                        ShowCommandHelp(c, args.First())
-                } else {
-                        ShowAppHelp(c)
-                }
-        },
-}
-
-var helpSubcommand = Command{
-        Name:    "help",
-        Aliases: []string{"h"},
-        Usage:   "Shows a list of commands or help for one command",
-        Action: func(c *Context) {
-                args := c.Args()
-                if args.Present() {
-                        ShowCommandHelp(c, args.First())
-                } else {
-                        ShowSubcommandHelp(c)
-                }
-        },
-}
-
-// Prints help for the App
-type helpPrinter func(templ string, data interface{})
-
-var HelpPrinter helpPrinter = nil
-
-// Prints version for the App
-var VersionPrinter = printVersion
-
-func ShowAppHelp(c *Context) {
-        HelpPrinter(AppHelpTemplate, c.App)
-}
-
-// Prints the list of subcommands as the default app completion method
-func DefaultAppComplete(c *Context) {
-        for _, command := range c.App.Commands {
-                for _, name := range command.Names() {
-                        fmt.Fprintln(c.App.Writer, name)
-                }
-        }
-}
-
-// Prints help for the given command
-func ShowCommandHelp(c *Context, command string) {
-        // show the subcommand help for a command with subcommands
-        if command == "" {
-                HelpPrinter(SubcommandHelpTemplate, c.App)
-                return
-        }
-
-        for _, c := range c.App.Commands {
-                if c.HasName(command) {
-                        HelpPrinter(CommandHelpTemplate, c)
-                        return
-                }
-        }
-
-        if c.App.CommandNotFound != nil {
-                c.App.CommandNotFound(c, command)
-        } else {
-                fmt.Fprintf(c.App.Writer, "No help topic for '%v'\n", command)
-        }
-}
-
-// Prints help for the given subcommand
-func ShowSubcommandHelp(c *Context) {
-        ShowCommandHelp(c, c.Command.Name)
-}
-
-// Prints the version number of the App
-func ShowVersion(c *Context) {
-        VersionPrinter(c)
-}
-
-func printVersion(c *Context) {
-        fmt.Fprintf(c.App.Writer, "%v version %v\n", c.App.Name, c.App.Version)
-}
-
-// Prints the lists of commands within a given context
-func ShowCompletions(c *Context) {
-        a := c.App
-        if a != nil && a.BashComplete != nil {
-                a.BashComplete(c)
-        }
-}
-
-// Prints the custom completions for a given command
-func ShowCommandCompletions(ctx *Context, command string) {
-        c := ctx.App.Command(command)
-        if c != nil && c.BashComplete != nil {
-                c.BashComplete(ctx)
-        }
-}
-
-func checkVersion(c *Context) bool {
-        if c.GlobalBool("version") {
-                ShowVersion(c)
-                return true
-        }
-
-        return false
-}
-
-func checkHelp(c *Context) bool {
-        if c.GlobalBool("h") || c.GlobalBool("help") {
-                ShowAppHelp(c)
-                return true
-        }
-
-        return false
-}
-
-func checkCommandHelp(c *Context, name string) bool {
-        if c.Bool("h") || c.Bool("help") {
-                ShowCommandHelp(c, name)
-                return true
-        }
-
-        return false
-}
-
-func checkSubcommandHelp(c *Context) bool {
-        if c.GlobalBool("h") || c.GlobalBool("help") {
-                ShowSubcommandHelp(c)
-                return true
-        }
-
-        return false
-}
-
-func checkCompletions(c *Context) bool {
-        if (c.GlobalBool(BashCompletionFlag.Name) || c.Bool(BashCompletionFlag.Name)) && c.App.EnableBashCompletion {
-                ShowCompletions(c)
-                return true
-        }
-
-        return false
-}
-
-func checkCommandCompletions(c *Context, name string) bool {
-        if c.Bool(BashCompletionFlag.Name) && c.App.EnableBashCompletion {
-                ShowCommandCompletions(c, name)
-                return true
-        }
-
-        return false
-}
diff --git a/Godeps/_workspace/src/github.com/codegangsta/cli/helpers_test.go b/Godeps/_workspace/src/github.com/codegangsta/cli/helpers_test.go
deleted file mode 100644
index f4b3975..0000000
--- a/Godeps/_workspace/src/github.com/codegangsta/cli/helpers_test.go
+++ /dev/null
@@ -1,19 +0,0 @@
-package cli_test
-
-import (
-        "reflect"
-        "testing"
-)
-
-/* Test Helpers */
-func expect(t *testing.T, a interface{}, b interface{}) {
-        if a != b {
-                t.Errorf("Expected %v (type %v) - Got %v (type %v)", b, reflect.TypeOf(b), a, reflect.TypeOf(a))
-        }
-}
-
-func refute(t *testing.T, a interface{}, b interface{}) {
-        if a == b {
-                t.Errorf("Did not expect %v (type %v) - Got %v (type %v)", b, reflect.TypeOf(b), a, reflect.TypeOf(a))
-        }
-}
diff --git a/Godeps/_workspace/src/github.com/fatih/color/.travis.yml b/Godeps/_workspace/src/github.com/fatih/color/.travis.yml
deleted file mode 100644
index d7acc29..0000000
--- a/Godeps/_workspace/src/github.com/fatih/color/.travis.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-language: go
-go: 1.3
diff --git a/Godeps/_workspace/src/github.com/fatih/color/LICENSE.md b/Godeps/_workspace/src/github.com/fatih/color/LICENSE.md
deleted file mode 100644
index 25fdaf6..0000000
--- a/Godeps/_workspace/src/github.com/fatih/color/LICENSE.md
+++ /dev/null
@@ -1,20 +0,0 @@
-The MIT License (MIT)
-
-Copyright (c) 2013 Fatih Arslan
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of
-this software and associated documentation files (the "Software"), to deal in
-the Software without restriction, including without limitation the rights to
-use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-the Software, and to permit persons to whom the Software is furnished to do so,
-subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/Godeps/_workspace/src/github.com/fatih/color/README.md b/Godeps/_workspace/src/github.com/fatih/color/README.md
deleted file mode 100644
index 3f62b39..0000000
--- a/Godeps/_workspace/src/github.com/fatih/color/README.md
+++ /dev/null
@@ -1,119 +0,0 @@
-# Color [![GoDoc](http://img.shields.io/badge/go-documentation-blue.svg?style=flat-square)](http://godoc.org/github.com/fatih/color) [![Build Status](http://img.shields.io/travis/fatih/color.svg?style=flat-square)](https://travis-ci.org/fatih/color)
-
-
-
-Color lets you use colorized outputs in terms of [ANSI Escape Codes](http://en.wikipedia.org/wiki/ANSI_escape_code#Colors) in Go (Golang). It has support for Windows too! The API can be used in several ways, pick one that suits you.
-
-
-
-![Color](http://i.imgur.com/c1JI0lA.png)
-
-
-## Install
-
-```bash
-go get github.com/fatih/color
-```
-
-## Examples
-
-### Standard colors
-
-```go
-// Print with default helper functions
-color.Cyan("Prints text in cyan.")
-
-// A newline will be appended automatically
-color.Blue("Prints %s in blue.", "text")
-
-// These are using the default foreground colors
-color.Red("We have red")
-color.Magenta("And many others ..")
-
-```
-
-### Mix and reuse colors
-
-```go
-// Create a new color object
-c := color.New(color.FgCyan).Add(color.Underline)
-c.Println("Prints cyan text with an underline.")
-
-// Or just add them to New()
-d := color.New(color.FgCyan, color.Bold)
-d.Printf("This prints bold cyan %s\n", "too!.")
-
-// Mix up foreground and background colors, create new mixes!
-red := color.New(color.FgRed)
-
-boldRed := red.Add(color.Bold)
-boldRed.Println("This will print text in bold red.")
-
-whiteBackground := red.Add(color.BgWhite)
-whiteBackground.Println("Red text with white background.")
-```
-
-### Custom print functions (PrintFunc)
-
-```go
-// Create a custom print function for convenience
-red := color.New(color.FgRed).PrintfFunc()
-red("Warning")
-red("Error: %s", err)
-
-// Mix up multiple attributes
-notice := color.New(color.Bold, color.FgGreen).PrintlnFunc()
-notice("Don't forget this...")
-```
-
-### Insert into noncolor strings (SprintFunc)
-
-```go
-// Create SprintXxx functions to mix strings with other non-colorized strings:
-yellow := color.New(color.FgYellow).SprintFunc()
-red := color.New(color.FgRed).SprintFunc()
-fmt.Printf("This is a %s and this is %s.\n", yellow("warning"), red("error"))
-
-info := color.New(color.FgWhite, color.BgGreen).SprintFunc()
-fmt.Printf("This %s rocks!\n", info("package"))
-
-// Use helper functions
-fmt.Printf("This", color.RedString("warning"), "should be not neglected.")
-fmt.Printf(color.GreenString("Info:"), "an important message." )
-
-// Windows supported too! Just don't forget to change the output to color.Output
-fmt.Fprintf(color.Output, "Windows support: %s", color.GreenString("PASS"))
-```
-
-### Plug into existing code
-
-```go
-// Use handy standard colors
-color.Set(color.FgYellow)
-
-fmt.Println("Existing text will now be in yellow")
-fmt.Printf("This one %s\n", "too")
-
-color.Unset() // Don't forget to unset
-
-// You can mix up parameters
-color.Set(color.FgMagenta, color.Bold)
-defer color.Unset() // Use it in your function
-
-fmt.Println("All text will now be bold magenta.")
-```
-
-## Todo
-
-* Save/Return previous values
-* Evaluate fmt.Formatter interface
-
-
-## Credits
-
- * [Fatih Arslan](https://github.com/fatih)
- * Windows support via @shiena: [ansicolor](https://github.com/shiena/ansicolor)
-
-## License
-
-The MIT License (MIT) - see [`LICENSE.md`](https://github.com/fatih/color/blob/master/LICENSE.md) for more details
diff --git a/Godeps/_workspace/src/github.com/fatih/color/color.go b/Godeps/_workspace/src/github.com/fatih/color/color.go
deleted file mode 100644
index e7331b4..0000000
--- a/Godeps/_workspace/src/github.com/fatih/color/color.go
+++ /dev/null
@@ -1,291 +0,0 @@
-package color
-
-import (
-        "fmt"
-        "io"
-        "os"
-        "strconv"
-        "strings"
-
-        "github.com/stevenjack/cig/Godeps/_workspace/src/github.com/shiena/ansicolor"
-)
-
-// Color defines a custom color object which is defined by SGR parameters.
-type Color struct {
-        params []Attribute
-}
-
-// Attribute defines a single SGR Code
-type Attribute int
-
-const escape = "\x1b"
-
-// Base attributes
-const (
-        Reset Attribute = iota
-        Bold
-        Faint
-        Italic
-        Underline
-        BlinkSlow
-        BlinkRapid
-        ReverseVideo
-        Concealed
-        CrossedOut
-)
-
-// Foreground text colors
-const (
-        FgBlack Attribute = iota + 30
-        FgRed
-        FgGreen
-        FgYellow
-        FgBlue
-        FgMagenta
-        FgCyan
-        FgWhite
-)
-
-// Background text colors
-const (
-        BgBlack Attribute = iota + 40
-        BgRed
-        BgGreen
-        BgYellow
-        BgBlue
-        BgMagenta
-        BgCyan
-        BgWhite
-)
-
-// New returns a newly created color object.
-func New(value ...Attribute) *Color {
-        c := &Color{params: make([]Attribute, 0)}
-        c.Add(value...)
-        return c
-}
-
-// Set sets the given parameters immediately. It will change the color of
-// output with the given SGR parameters until color.Unset() is called.
-func Set(p ...Attribute) *Color {
-        c := New(p...)
-        c.Set()
-        return c
-}
-
-// Unset resets all escape attributes and clears the output. Usually should
-// be called after Set().
-func Unset() {
-        fmt.Fprintf(Output, "%s[%dm", escape, Reset)
-}
-
-// Add is used to chain SGR parameters. Use as many as parameters to combine
-// and create custom color objects. Example: Add(color.FgRed, color.Underline).
-func (c *Color) Add(value ...Attribute) *Color {
-        c.params = append(c.params, value...)
-        return c
-}
-
-func (c *Color) prepend(value Attribute) {
-        c.params = append(c.params, 0)
-        copy(c.params[1:], c.params[0:])
-        c.params[0] = value
-}
-
-// Output defines the standard output of the print functions. By default
-// os.Stdout is used.
-var Output io.Writer = ansicolor.NewAnsiColorWriter(os.Stdout)
-
-// Print formats using the default formats for its operands and writes to
-// standard output. Spaces are added between operands when neither is a
-// string. It returns the number of bytes written and any write error
-// encountered. This is the standard fmt.Print() method wrapped with the given
-// color.
-func (c *Color) Print(a ...interface{}) (n int, err error) {
-        c.Set()
-        defer Unset()
-
-        return fmt.Fprint(Output, a...)
-}
-
-// Printf formats according to a format specifier and writes to standard output.
-// It returns the number of bytes written and any write error encountered.
-// This is the standard fmt.Printf() method wrapped with the given color.
-func (c *Color) Printf(format string, a ...interface{}) (n int, err error) {
-        c.Set()
-        defer Unset()
-
-        return fmt.Fprintf(Output, format, a...)
-}
-
-// Println formats using the default formats for its operands and writes to
-// standard output. Spaces are always added between operands and a newline is
-// appended. It returns the number of bytes written and any write error
-// encountered. This is the standard fmt.Print() method wrapped with the given
-// color.
-func (c *Color) Println(a ...interface{}) (n int, err error) {
-        c.Set()
-        defer Unset()
-
-        return fmt.Fprintln(Output, a...)
-}
-
-// PrintFunc returns a new function that prints the passed arguments as
-// colorized with color.Print().
-func (c *Color) PrintFunc() func(a ...interface{}) {
-        return func(a ...interface{}) { c.Print(a...) }
-}
-
-// PrintfFunc returns a new function that prints the passed arguments as
-// colorized with color.Printf().
-func (c *Color) PrintfFunc() func(format string, a ...interface{}) {
-        return func(format string, a ...interface{}) { c.Printf(format, a...) }
-}
-
-// PrintlnFunc returns a new function that prints the passed arguments as
-// colorized with color.Println().
-func (c *Color) PrintlnFunc() func(a ...interface{}) {
-        return func(a ...interface{}) { c.Println(a...) }
-}
-
-// SprintFunc returns a new function that returns colorized strings for the
-// given arguments with fmt.Sprint(). Useful to put into or mix into other
-// string. Windows users should use this in conjuction with color.Output, example:
-//
-//	put := New(FgYellow).SprintFunc()
-//	fmt.Ffprintf(color.Output, "This is a %s", put("warning"))
-func (c *Color) SprintFunc() func(a ...interface{}) string {
-        return func(a ...interface{}) string {
-                return c.wrap(fmt.Sprint(a...))
-        }
-}
-
-// SprintfFunc returns a new function that returns colorized strings for the
-// given arguments with fmt.Sprintf(). Useful to put into or mix into other
-// string. Windows users should use this in conjuction with color.Output.
-func (c *Color) SprintfFunc() func(format string, a ...interface{}) string {
-        return func(format string, a ...interface{}) string {
-                return c.wrap(fmt.Sprintf(format, a...))
-        }
-}
-
-// SprintlnFunc returns a new function that returns colorized strings for the
-// given arguments with fmt.Sprintln(). Useful to put into or mix into other
-// string. Windows users should use this in conjuction with color.Output.
-func (c *Color) SprintlnFunc() func(a ...interface{}) string {
-        return func(a ...interface{}) string {
-                return c.wrap(fmt.Sprintln(a...))
-        }
-}
-
-// sequence returns a formated SGR sequence to be plugged into a "\x1b[...m"
-// an example output might be: "1;36" -> bold cyan
-func (c *Color) sequence() string {
-        format := make([]string, len(c.params))
-        for i, v := range c.params {
-                format[i] = strconv.Itoa(int(v))
-        }
-
-        return strings.Join(format, ";")
-}
-
-func (c *Color) wrap(s string) string { return c.format() + s + c.unformat() }
-
-func (c *Color) format() string { return fmt.Sprintf("%s[%sm", escape, c.sequence()) }
-
-func (c *Color) unformat() string { return fmt.Sprintf("%s[%dm", escape, Reset) }
-
-// Set sets the SGR sequence.
-func (c *Color) Set() *Color {
-        fmt.Fprintf(Output, c.format())
-        return c
-}
-
-// Black is an convenient helper function to print with black foreground. A
-// newline is appended to format by default.
-func Black(format string, a ...interface{}) { printColor(format, FgBlack, a...) }
-
-// Red is an convenient helper function to print with red foreground. A
-// newline is appended to format by default.
-func Red(format string, a ...interface{}) { printColor(format, FgRed, a...) }
-
-// Green is an convenient helper function to print with green foreground. A
-// newline is appended to format by default.
-func Green(format string, a ...interface{}) { printColor(format, FgGreen, a...) }
-
-// Yellow is an convenient helper function to print with yellow foreground.
-// A newline is appended to format by default.
-func Yellow(format string, a ...interface{}) { printColor(format, FgYellow, a...) }
-
-// Blue is an convenient helper function to print with blue foreground. A
-// newline is appended to format by default.
-func Blue(format string, a ...interface{}) { printColor(format, FgBlue, a...) }
-
-// Magenta is an convenient helper function to print with magenta foreground.
-// A newline is appended to format by default.
-func Magenta(format string, a ...interface{}) { printColor(format, FgMagenta, a...) }
-
-// Cyan is an convenient helper function to print with cyan foreground. A
-// newline is appended to format by default.
-func Cyan(format string, a ...interface{}) { printColor(format, FgCyan, a...) }
-
-// White is an convenient helper function to print with white foreground. A
-// newline is appended to format by default.
-func White(format string, a ...interface{}) { printColor(format, FgWhite, a...) }
-
-func printColor(format string, p Attribute, a ...interface{}) {
-        if !strings.HasSuffix(format, "\n") {
-                format += "\n"
-        }
-
-        c := &Color{params: []Attribute{p}}
-        c.Printf(format, a...)
-}
-
-// BlackString is an convenient helper function to return a string with black
-// foreground.
-func BlackString(format string, a ...interface{}) string {
-        return New(FgBlack).SprintfFunc()(format, a...)
-}
-
-// RedString is an convenient helper function to return a string with red
-// foreground.
-func RedString(format string, a ...interface{}) string {
-        return New(FgRed).SprintfFunc()(format, a...)
-}
-
-// GreenString is an convenient helper function to return a string with green
-// foreground.
-func GreenString(format string, a ...interface{}) string {
-        return New(FgGreen).SprintfFunc()(format, a...)
-}
-
-// YellowString is an convenient helper function to return a string with yellow
-// foreground.
-func YellowString(format string, a ...interface{}) string {
-        return New(FgYellow).SprintfFunc()(format, a...)
-}
-
-// BlueString is an convenient helper function to return a string with blue
-// foreground.
-func BlueString(format string, a ...interface{}) string {
-        return New(FgBlue).SprintfFunc()(format, a...)
-}
-
-// MagentaString is an convenient helper function to return a string with magenta
-// foreground.
-func MagentaString(format string, a ...interface{}) string {
-        return New(FgMagenta).SprintfFunc()(format, a...)
-}
-
-// CyanString is an convenient helper function to return a string with cyan
-// foreground.
-func CyanString(format string, a ...interface{}) string {
-        return New(FgCyan).SprintfFunc()(format, a...)
-}
-
-// WhiteString is an convenient helper function to return a string with white
-// foreground.
-func WhiteString(format string, a ...interface{}) string {
-        return New(FgWhite).SprintfFunc()(format, a...)
-}
diff --git a/Godeps/_workspace/src/github.com/fatih/color/color_test.go b/Godeps/_workspace/src/github.com/fatih/color/color_test.go
deleted file mode 100644
index 53054a9..0000000
--- a/Godeps/_workspace/src/github.com/fatih/color/color_test.go
+++ /dev/null
@@ -1,129 +0,0 @@
-package color
-
-import (
-        "bytes"
-        "fmt"
-        "os"
-        "testing"
-
-        "github.com/stevenjack/cig/Godeps/_workspace/src/github.com/shiena/ansicolor"
-)
-
-// Testing colors is kinda different. First we test for given colors and their
-// escaped formatted results. Next we create some visual tests to be tested.
-// Each visual test includes the color name to be compared.
-func TestColor(t *testing.T) {
-        rb := new(bytes.Buffer)
-        Output = rb
-
-        testColors := []struct {
-                text string
-                code Attribute
-        }{
-                {text: "black", code: FgBlack},
-                {text: "red", code: FgRed},
-                {text: "green", code: FgGreen},
-                {text: "yellow", code: FgYellow},
-                {text: "blue", code: FgBlue},
-                {text: "magent", code: FgMagenta},
-                {text: "cyan", code: FgCyan},
-                {text: "white", code: FgWhite},
-        }
-
-        for _, c := range testColors {
-                New(c.code).Print(c.text)
-
-                line, _ := rb.ReadString('\n')
-                scannedLine := fmt.Sprintf("%q", line)
-                colored := fmt.Sprintf("\x1b[%dm%s\x1b[0m", c.code, c.text)
-                escapedForm := fmt.Sprintf("%q", colored)
-
-                fmt.Printf("%s\t: %s\n", c.text, line)
-
-                if scannedLine != escapedForm {
-                        t.Errorf("Expecting %s, got '%s'\n", escapedForm, scannedLine)
-                }
-        }
-
-        // First Visual Test
-        fmt.Println("")
-        Output = ansicolor.NewAnsiColorWriter(os.Stdout)
-
-        New(FgRed).Printf("red\t")
-        New(BgRed).Print("         ")
-        New(FgRed, Bold).Println(" red")
-
-        New(FgGreen).Printf("green\t")
-        New(BgGreen).Print("         ")
-        New(FgGreen, Bold).Println(" green")
-
-        New(FgYellow).Printf("yellow\t")
-        New(BgYellow).Print("         ")
-        New(FgYellow, Bold).Println(" yellow")
-
-        New(FgBlue).Printf("blue\t")
-        New(BgBlue).Print("         ")
-        New(FgBlue, Bold).Println(" blue")
-
-        New(FgMagenta).Printf("magenta\t")
-        New(BgMagenta).Print("         ")
-        New(FgMagenta, Bold).Println(" magenta")
-
-        New(FgCyan).Printf("cyan\t")
-        New(BgCyan).Print("         ")
-        New(FgCyan, Bold).Println(" cyan")
-
-        New(FgWhite).Printf("white\t")
-        New(BgWhite).Print("         ")
-        New(FgWhite, Bold).Println(" white")
-        fmt.Println("")
-
-        // Second Visual test
-        Black("black")
-        Red("red")
-        Green("green")
-        Yellow("yellow")
-        Blue("blue")
-        Magenta("magenta")
-        Cyan("cyan")
-        White("white")
-
-        // Third visual test
-        fmt.Println()
-        Set(FgBlue)
-        fmt.Println("is this blue?")
-        Unset()
-
-        Set(FgMagenta)
-        fmt.Println("and this magenta?")
-        Unset()
-
-        // Fourth Visual test
-        fmt.Println()
-        blue := New(FgBlue).PrintlnFunc()
-        blue("blue text with custom print func")
-
-        red := New(FgRed).PrintfFunc()
-        red("red text with a printf func: %d\n", 123)
-
-        put := New(FgYellow).SprintFunc()
-        warn := New(FgRed).SprintFunc()
-
-        fmt.Fprintf(Output, "this is a %s and this is %s.\n", put("warning"), warn("error"))
-
-        info := New(FgWhite, BgGreen).SprintFunc()
-        fmt.Fprintf(Output, "this %s rocks!\n", info("package"))
-
-        // Fifth Visual Test
-        fmt.Println()
-
-        fmt.Fprintln(Output, BlackString("black"))
-        fmt.Fprintln(Output, RedString("red"))
-        fmt.Fprintln(Output, GreenString("green"))
-        fmt.Fprintln(Output, YellowString("yellow"))
-        fmt.Fprintln(Output, BlueString("blue"))
-        fmt.Fprintln(Output, MagentaString("magenta"))
-        fmt.Fprintln(Output, CyanString("cyan"))
-        fmt.Fprintln(Output, WhiteString("white"))
-
-}
diff --git a/Godeps/_workspace/src/github.com/fatih/color/doc.go b/Godeps/_workspace/src/github.com/fatih/color/doc.go
deleted file mode 100644
index eaa28b8..0000000
--- a/Godeps/_workspace/src/github.com/fatih/color/doc.go
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
-Package color is an ANSI color package to output colorized or SGR defined
-output to the standard output. The API can be used in several way, pick one
-that suits you.
-
-Use simple and default helper functions with predefined foreground colors:
-
-    color.Cyan("Prints text in cyan.")
-
-    // a newline will be appended automatically
-    color.Blue("Prints %s in blue.", "text")
-
-    // More default foreground colors..
-    color.Red("We have red")
-    color.Yellow("Yellow color too!")
-    color.Magenta("And many others ..")
-
-However there are times where custom color mixes are required. Below are some
-examples to create custom color objects and use the print functions of each
-separate color object.
-
-    // Create a new color object
-    c := color.New(color.FgCyan).Add(color.Underline)
-    c.Println("Prints cyan text with an underline.")
-
-    // Or just add them to New()
-    d := color.New(color.FgCyan, color.Bold)
-    d.Printf("This prints bold cyan %s\n", "too!.")
-
-
-    // Mix up foreground and background colors, create new mixes!
-    red := color.New(color.FgRed)
-
-    boldRed := red.Add(color.Bold)
-    boldRed.Println("This will print text in bold red.")
-
-    whiteBackground := red.Add(color.BgWhite)
-    whiteBackground.Println("Red text with White background.")
-
-
-You can create PrintXxx functions to simplify even more:
-
-    // Create a custom print function for convenient
-    red := color.New(color.FgRed).PrintfFunc()
-    red("warning")
-    red("error: %s", err)
-
-    // Mix up multiple attributes
-    notice := color.New(color.Bold, color.FgGreen).PrintlnFunc()
-    notice("don't forget this...")
-
-
-Or create SprintXxx functions to mix strings with other non-colorized strings:
-
-    yellow := New(FgYellow).SprintFunc()
-    red := New(FgRed).SprintFunc()
-
-    fmt.Printf("this is a %s and this is %s.\n", yellow("warning"), red("error"))
-
-    info := New(FgWhite, BgGreen).SprintFunc()
-    fmt.Printf("this %s rocks!\n", info("package"))
-
-Windows support is enabled by default. All Print functions works as intended.
-However only for color.SprintXXX functions, user should use fmt.FprintXXX and
-set the output to color.Output:
-
-        fmt.Fprintf(color.Output, "Windows support: %s", color.GreenString("PASS"))
-
-    info := New(FgWhite, BgGreen).SprintFunc()
-    fmt.Fprintf(color.Output, "this %s rocks!\n", info("package"))
-
-
-Using with existing code is possible. Just use the Set() method to set the
-standard output to the given parameters. That way a rewrite of an existing
-code is not required.
-
-    // Use handy standard colors.
-    color.Set(color.FgYellow)
-
-    fmt.Println("Existing text will be now in Yellow")
-    fmt.Printf("This one %s\n", "too")
-
-    color.Unset() // don't forget to unset
-
-    // You can mix up parameters
-    color.Set(color.FgMagenta, color.Bold)
-    defer color.Unset() // use it in your function
-
-    fmt.Println("All text will be now bold magenta.")
-*/
-package color
diff --git a/Godeps/_workspace/src/github.com/mitchellh/go-homedir/LICENSE b/Godeps/_workspace/src/github.com/mitchellh/go-homedir/LICENSE
deleted file mode 100644
index f9c841a..0000000
--- a/Godeps/_workspace/src/github.com/mitchellh/go-homedir/LICENSE
+++ /dev/null
@@ -1,21 +0,0 @@
-The MIT License (MIT)
-
-Copyright (c) 2013 Mitchell Hashimoto
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
diff --git a/Godeps/_workspace/src/github.com/mitchellh/go-homedir/README.md b/Godeps/_workspace/src/github.com/mitchellh/go-homedir/README.md
deleted file mode 100644
index d70706d..0000000
--- a/Godeps/_workspace/src/github.com/mitchellh/go-homedir/README.md
+++ /dev/null
@@ -1,14 +0,0 @@
-# go-homedir
-
-This is a Go library for detecting the user's home directory without
-the use of cgo, so the library can be used in cross-compilation environments.
-
-Usage is incredibly simple, just call `homedir.Dir()` to get the home directory
-for a user, and `homedir.Expand()` to expand the `~` in a path to the home
-directory.
-
-**Why not just use `os/user`?** The built-in `os/user` package requires
-cgo on Darwin systems. This means that any Go code that uses that package
-cannot cross compile. But 99% of the time the use for `os/user` is just to
-retrieve the home directory, which we can do for the current user without
-cgo. This library does that, enabling cross-compilation.
diff --git a/Godeps/_workspace/src/github.com/mitchellh/go-homedir/homedir.go b/Godeps/_workspace/src/github.com/mitchellh/go-homedir/homedir.go
deleted file mode 100644
index 6691ef3..0000000
--- a/Godeps/_workspace/src/github.com/mitchellh/go-homedir/homedir.go
+++ /dev/null
@@ -1,84 +0,0 @@
-package homedir
-
-import (
-        "bytes"
-        "errors"
-        "os"
-        "os/exec"
-        "path/filepath"
-        "runtime"
-        "strings"
-)
-
-// Dir returns the home directory for the executing user.
-//
-// This uses an OS-specific method for discovering the home directory.
-// An error is returned if a home directory cannot be detected.
-func Dir() (string, error) {
-        if runtime.GOOS == "windows" {
-                return dirWindows()
-        }
-
-        // Unix-like system, so just assume Unix
-        return dirUnix()
-}
-
-// Expand expands the path to include the home directory if the path
-// is prefixed with `~`. If it isn't prefixed with `~`, the path is
-// returned as-is.
-func Expand(path string) (string, error) {
-        if len(path) == 0 {
-                return path, nil
-        }
-
-        if path[0] != '~' {
-                return path, nil
-        }
-
-        if len(path) > 1 && path[1] != '/' && path[1] != '\\' {
-                return "", errors.New("cannot expand user-specific home dir")
-        }
-
-        dir, err := Dir()
-        if err != nil {
-                return "", err
-        }
-
-        return filepath.Join(dir, path[1:]), nil
-}
-
-func dirUnix() (string, error) {
-        // First prefer the HOME environmental variable
-        if home := os.Getenv("HOME"); home != "" {
-                return home, nil
-        }
-
-        // If that fails, try the shell
-        var stdout bytes.Buffer
-        cmd := exec.Command("sh", "-c", "eval echo ~$USER")
-        cmd.Stdout = &stdout
-        if err := cmd.Run(); err != nil {
-                return "", err
-        }
-
-        result := strings.TrimSpace(stdout.String())
-        if result == "" {
-                return "", errors.New("blank output when reading home directory")
-        }
-
-        return result, nil
-}
-
-func dirWindows() (string, error) {
-        drive := os.Getenv("HOMEDRIVE")
-        path := os.Getenv("HOMEPATH")
-        home := drive + path
-        if drive == "" || path == "" {
-                home = os.Getenv("USERPROFILE")
-        }
-        if home == "" {
-                return "", errors.New("HOMEDRIVE, HOMEPATH, and USERPROFILE are blank")
-        }
-
-        return home, nil
-}
diff --git a/Godeps/_workspace/src/github.com/mitchellh/go-homedir/homedir_test.go b/Godeps/_workspace/src/github.com/mitchellh/go-homedir/homedir_test.go
deleted file mode 100644
index dbbd43a..0000000
--- a/Godeps/_workspace/src/github.com/mitchellh/go-homedir/homedir_test.go
+++ /dev/null
@@ -1,98 +0,0 @@
-package homedir
-
-import (
-        "fmt"
-        "os"
-        "os/user"
-        "testing"
-)
-
-func patchEnv(key, value string) func() {
-        bck := os.Getenv(key)
-        deferFunc := func() {
-                os.Setenv(key, bck)
-        }
-
-        os.Setenv(key, value)
-        return deferFunc
-}
-
-func TestDir(t *testing.T) {
-        u, err := user.Current()
-        if err != nil {
-                t.Fatalf("err: %s", err)
-        }
-
-        dir, err := Dir()
-        if err != nil {
-                t.Fatalf("err: %s", err)
-        }
-
-        if u.HomeDir != dir {
-                t.Fatalf("%#v != %#v", u.HomeDir, dir)
-        }
-}
-
-func TestExpand(t *testing.T) {
-        u, err := user.Current()
-        if err != nil {
-                t.Fatalf("err: %s", err)
-        }
-
-        cases := []struct {
-                Input  string
-                Output string
-                Err    bool
-        }{
-                {
-                        "/foo",
-                        "/foo",
-                        false,
-                },
-
-                {
-                        "~/foo",
-                        fmt.Sprintf("%s/foo", u.HomeDir),
-                        false,
-                },
-
-                {
-                        "",
-                        "",
-                        false,
-                },
-
-                {
-                        "~",
-                        u.HomeDir,
-                        false,
-                },
-
-                {
-                        "~foo/foo",
-                        "",
-                        true,
-                },
-        }
-
-        for _, tc := range cases {
-                actual, err := Expand(tc.Input)
-                if (err != nil) != tc.Err {
-                        t.Fatalf("Input: %#v\n\nErr: %s", tc.Input, err)
-                }
-
-                if actual != tc.Output {
-                        t.Fatalf("Input: %#v\n\nOutput: %#v", tc.Input, actual)
-                }
-        }
-
-        defer patchEnv("HOME", "/custom/path/")()
-        expected := "/custom/path/foo/bar"
-        actual, err := Expand("~/foo/bar")
-
-        if err != nil {
-                t.Errorf("No error is expected, got: %v", err)
-        } else if actual != "/custom/path/foo/bar" {
-                t.Errorf("Expected: %v; actual: %v", expected, actual)
-        }
-}
diff --git a/Godeps/_workspace/src/github.com/shiena/ansicolor/.gitignore b/Godeps/_workspace/src/github.com/shiena/ansicolor/.gitignore
deleted file mode 100644
index 02d99b9..0000000
--- a/Godeps/_workspace/src/github.com/shiena/ansicolor/.gitignore
+++ /dev/null
@@ -1,26 +0,0 @@
-# Created by http://www.gitignore.io
-
-### Go ###
-# Compiled Object files, Static and Dynamic libs (Shared Objects)
-*.o
-*.a
-*.so
-
-# Folders
-_obj
-_test
-
-# Architecture specific extensions/prefixes
-*.[568vq]
-[568vq].out
-
-*.cgo1.go
-*.cgo2.c
-_cgo_defun.c
-_cgo_gotypes.go
-_cgo_export.*
-
-_testmain.go
-
-*.exe
-*.test
diff --git a/Godeps/_workspace/src/github.com/shiena/ansicolor/LICENSE b/Godeps/_workspace/src/github.com/shiena/ansicolor/LICENSE
deleted file mode 100644
index e58473e..0000000
--- a/Godeps/_workspace/src/github.com/shiena/ansicolor/LICENSE
+++ /dev/null
@@ -1,21 +0,0 @@
-The MIT License (MIT)
-
-Copyright (c) [2014] [shiena]
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
diff --git a/Godeps/_workspace/src/github.com/shiena/ansicolor/README.md b/Godeps/_workspace/src/github.com/shiena/ansicolor/README.md
deleted file mode 100644
index 905892e..0000000
--- a/Godeps/_workspace/src/github.com/shiena/ansicolor/README.md
+++ /dev/null
@@ -1,81 +0,0 @@
-# ansicolor
-
-Ansicolor library provides color console in Windows as ANSICON for Golang.
-
-## Features
-
-|Escape sequence|Text attributes|
-|---------------|----|
-|\x1b[0m|All attributes off(color at startup)|
-|\x1b[1m|Bold on(enable foreground intensity)|
-|\x1b[4m|Underline on|
-|\x1b[5m|Blink on(enable background intensity)|
-|\x1b[21m|Bold off(disable foreground intensity)|
-|\x1b[24m|Underline off|
-|\x1b[25m|Blink off(disable background intensity)|
-
-|Escape sequence|Foreground colors|
-|---------------|----|
-|\x1b[30m|Black|
-|\x1b[31m|Red|
-|\x1b[32m|Green|
-|\x1b[33m|Yellow|
-|\x1b[34m|Blue|
-|\x1b[35m|Magenta|
-|\x1b[36m|Cyan|
-|\x1b[37m|White|
-|\x1b[39m|Default(foreground color at startup)|
-
-|Escape sequence|Background colors|
-|---------------|----|
-|\x1b[40m|Black|
-|\x1b[41m|Red|
-|\x1b[42m|Green|
-|\x1b[43m|Yellow|
-|\x1b[44m|Blue|
-|\x1b[45m|Magenta|
-|\x1b[46m|Cyan|
-|\x1b[47m|White|
-|\x1b[49m|Default(background color at startup)|
-
-## Example
-
-```go
-package main
-
-import (
-        "fmt"
-        "os"
-
-        "github.com/shiena/ansicolor"
-)
-
-func main() {
-        w := ansicolor.NewAnsiColorWriter(os.Stdout)
-        text := "%sforeground %sbold%s %sbackground%s\n"
-        fmt.Fprintf(w, text, "\x1b[31m", "\x1b[1m", "\x1b[21m", "\x1b[41;32m", "\x1b[0m")
-        fmt.Fprintf(w, text, "\x1b[32m", "\x1b[1m", "\x1b[21m", "\x1b[42;31m", "\x1b[0m")
-        fmt.Fprintf(w, text, "\x1b[33m", "\x1b[1m", "\x1b[21m", "\x1b[43;34m", "\x1b[0m")
-        fmt.Fprintf(w, text, "\x1b[34m", "\x1b[1m", "\x1b[21m", "\x1b[44;33m", "\x1b[0m")
-        fmt.Fprintf(w, text, "\x1b[35m", "\x1b[1m", "\x1b[21m", "\x1b[45;36m", "\x1b[0m")
-        fmt.Fprintf(w, text, "\x1b[36m", "\x1b[1m", "\x1b[21m", "\x1b[46;35m", "\x1b[0m")
-        fmt.Fprintf(w, text, "\x1b[37m", "\x1b[1m", "\x1b[21m", "\x1b[47;30m", "\x1b[0m")
-}
-```
-
-![screenshot](https://gist.githubusercontent.com/shiena/a1bada24b525314a7d5e/raw/c763aa7cda6e4fefaccf831e2617adc40b6151c7/main.png)
-
-## See also:
-
-- https://github.com/daviddengcn/go-colortext
-- https://github.com/adoxa/ansicon
-- https://github.com/aslakhellesoy/wac
-- https://github.com/wsxiaoys/terminal
-
-## Contributing
-
-1. Fork it
-2. Create your feature branch (`git checkout -b my-new-feature`)
-3. Commit your changes (`git commit -am 'Add some feature'`)
-4. Push to the branch (`git push origin my-new-feature`)
-5. Create new Pull Request
diff --git a/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor.go b/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor.go
deleted file mode 100644
index 30ba28c..0000000
--- a/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor.go
+++ /dev/null
@@ -1,17 +0,0 @@
-// Copyright 2014 shiena Authors. All rights reserved.
-// Use of this source code is governed by a MIT-style
-// license that can be found in the LICENSE file.
-
-// Package ansicolor provides color console in Windows as ANSICON.
-package ansicolor
-
-import "io"
-
-// NewAnsiColorWriter creates and initializes a new ansiColorWriter
-// using io.Writer w as its initial contents.
-// In the console of Windows, which change the foreground and background
-// colors of the text by the escape sequence.
-// In the console of other systems, which writes to w all text.
-func NewAnsiColorWriter(w io.Writer) io.Writer {
-        return &ansiColorWriter{w: w}
-}
diff --git a/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor/main.go b/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor/main.go
deleted file mode 100644
index 9272583..0000000
--- a/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor/main.go
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright 2014 shiena Authors. All rights reserved.
-// Use of this source code is governed by a MIT-style
-// license that can be found in the LICENSE file.
-
-/*
-
-The ansicolor command colors a console text by ANSI escape sequence like wac.
-
-    $ go get github.com/shiena/ansicolor/ansicolor
-
-See also:
-    https://github.com/aslakhellesoy/wac
-
-*/
-package main
-
-import (
-        "io"
-        "os"
-
-        "github.com/stevenjack/cig/Godeps/_workspace/src/github.com/shiena/ansicolor"
-)
-
-func main() {
-        w := ansicolor.NewAnsiColorWriter(os.Stdout)
-        io.Copy(w, os.Stdin)
-}
diff --git a/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor_ansi.go b/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor_ansi.go
deleted file mode 100644
index 401f902..0000000
--- a/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor_ansi.go
+++ /dev/null
@@ -1,17 +0,0 @@
-// Copyright 2014 shiena Authors. All rights reserved.
-// Use of this source code is governed by a MIT-style
-// license that can be found in the LICENSE file.
-
-// +build !windows
-
-package ansicolor
-
-import "io"
-
-type ansiColorWriter struct {
-        w io.Writer
-}
-
-func (cw *ansiColorWriter) Write(p []byte) (int, error) {
-        return cw.w.Write(p)
-}
diff --git a/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor_windows.go b/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor_windows.go
deleted file mode 100644
index 85a3501..0000000
--- a/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor_windows.go
+++ /dev/null
@@ -1,315 +0,0 @@
-// Copyright 2014 shiena Authors. All rights reserved.
-// Use of this source code is governed by a MIT-style
-// license that can be found in the LICENSE file.
-
-// +build windows
-
-package ansicolor
-
-import (
-        "bytes"
-        "io"
-        "strings"
-        "syscall"
-        "unsafe"
-)
-
-type csiState int
-
-const (
-        outsideCsiCode csiState = iota
-        firstCsiCode
-        secondeCsiCode
-)
-
-type ansiColorWriter struct {
-        w        io.Writer
-        state    csiState
-        paramBuf bytes.Buffer
-}
-
-const (
-        firstCsiChar   byte = '\x1b'
-        secondeCsiChar byte = '['
-        separatorChar  byte = ';'
-        sgrCode        byte = 'm'
-)
-
-const (
-        foregroundBlue      = uint16(0x0001)
-        foregroundGreen     = uint16(0x0002)
-        foregroundRed       = uint16(0x0004)
-        foregroundIntensity = uint16(0x0008)
-        backgroundBlue      = uint16(0x0010)
-        backgroundGreen     = uint16(0x0020)
-        backgroundRed       = uint16(0x0040)
-        backgroundIntensity = uint16(0x0080)
-        underscore          = uint16(0x8000)
-
-        foregroundMask = foregroundBlue | foregroundGreen | foregroundRed | foregroundIntensity
-        backgroundMask = backgroundBlue | backgroundGreen | backgroundRed | backgroundIntensity
-)
-
-const (
-        ansiReset        = "0"
-        ansiIntensityOn  = "1"
-        ansiIntensityOff = "21"
-        ansiUnderlineOn  = "4"
-        ansiUnderlineOff = "24"
-        ansiBlinkOn      = "5"
-        ansiBlinkOff     = "25"
-
-        ansiForegroundBlack   = "30"
-        ansiForegroundRed     = "31"
-        ansiForegroundGreen   = "32"
-        ansiForegroundYellow  = "33"
-        ansiForegroundBlue    = "34"
-        ansiForegroundMagenta = "35"
-        ansiForegroundCyan    = "36"
-        ansiForegroundWhite   = "37"
-        ansiForegroundDefault = "39"
-
-        ansiBackgroundBlack   = "40"
-        ansiBackgroundRed     = "41"
-        ansiBackgroundGreen   = "42"
-        ansiBackgroundYellow  = "43"
-        ansiBackgroundBlue    = "44"
-        ansiBackgroundMagenta = "45"
-        ansiBackgroundCyan    = "46"
-        ansiBackgroundWhite   = "47"
-        ansiBackgroundDefault = "49"
-)
-
-type drawType int
-
-const (
-        foreground drawType = iota
-        background
-)
-
-type winColor struct {
-        code     uint16
-        drawType drawType
-}
-
-var colorMap = map[string]winColor{
-        ansiForegroundBlack:   {0, foreground},
-        ansiForegroundRed:     {foregroundRed, foreground},
-        ansiForegroundGreen:   {foregroundGreen, foreground},
-        ansiForegroundYellow:  {foregroundRed | foregroundGreen, foreground},
-        ansiForegroundBlue:    {foregroundBlue, foreground},
-        ansiForegroundMagenta: {foregroundRed | foregroundBlue, foreground},
-        ansiForegroundCyan:    {foregroundGreen | foregroundBlue, foreground},
-        ansiForegroundWhite:   {foregroundRed | foregroundGreen | foregroundBlue, foreground},
-        ansiForegroundDefault: {foregroundRed | foregroundGreen | foregroundBlue, foreground},
-
-        ansiBackgroundBlack:   {0, background},
-        ansiBackgroundRed:     {backgroundRed, background},
-        ansiBackgroundGreen:   {backgroundGreen, background},
-        ansiBackgroundYellow:  {backgroundRed | backgroundGreen, background},
-        ansiBackgroundBlue:    {backgroundBlue, background},
-        ansiBackgroundMagenta: {backgroundRed | backgroundBlue, background},
-        ansiBackgroundCyan:    {backgroundGreen | backgroundBlue, background},
-        ansiBackgroundWhite:   {backgroundRed | backgroundGreen | backgroundBlue, background},
-        ansiBackgroundDefault: {0, background},
-}
-
-var (
-        kernel32                       = syscall.NewLazyDLL("kernel32.dll")
-        procSetConsoleTextAttribute    = kernel32.NewProc("SetConsoleTextAttribute")
-        procGetConsoleScreenBufferInfo = kernel32.NewProc("GetConsoleScreenBufferInfo")
-        defaultAttr                    *textAttributes
-)
-
-func init() {
-        screenInfo := getConsoleScreenBufferInfo(uintptr(syscall.Stdout))
-        if screenInfo != nil {
-                colorMap[ansiForegroundDefault] = winColor{
-                        screenInfo.WAttributes & (foregroundRed | foregroundGreen | foregroundBlue),
-                        foreground,
-                }
-                colorMap[ansiBackgroundDefault] = winColor{
-                        screenInfo.WAttributes & (backgroundRed | backgroundGreen | backgroundBlue),
-                        background,
-                }
-                defaultAttr = convertTextAttr(screenInfo.WAttributes)
-        }
-}
-
-type coord struct {
-        X, Y int16
-}
-
-type smallRect struct {
-        Left, Top, Right, Bottom int16
-}
-
-type consoleScreenBufferInfo struct {
-        DwSize              coord
-        DwCursorPosition    coord
-        WAttributes         uint16
-        SrWindow            smallRect
-        DwMaximumWindowSize coord
-}
-
-func getConsoleScreenBufferInfo(hConsoleOutput uintptr) *consoleScreenBufferInfo {
-        var csbi consoleScreenBufferInfo
-        ret, _, _ := procGetConsoleScreenBufferInfo.Call(
-                hConsoleOutput,
-                uintptr(unsafe.Pointer(&csbi)))
-        if ret == 0 {
-                return nil
-        }
-        return &csbi
-}
-
-func setConsoleTextAttribute(hConsoleOutput uintptr, wAttributes uint16) bool {
-        ret, _, _ := procSetConsoleTextAttribute.Call(
-                hConsoleOutput,
-                uintptr(wAttributes))
-        return ret != 0
-}
-
-type textAttributes struct {
-        foregroundColor     uint16
-        backgroundColor     uint16
-        foregroundIntensity uint16
-        backgroundIntensity uint16
-        underscore          uint16
-        otherAttributes     uint16
-}
-
-func convertTextAttr(winAttr uint16) *textAttributes {
-        fgColor := winAttr & (foregroundRed | foregroundGreen | foregroundBlue)
-        bgColor := winAttr & (backgroundRed | backgroundGreen | backgroundBlue)
-        fgIntensity := winAttr & foregroundIntensity
-        bgIntensity := winAttr & backgroundIntensity
-        underline := winAttr & underscore
-        otherAttributes := winAttr &^ (foregroundMask | backgroundMask | underscore)
-        return &textAttributes{fgColor, bgColor, fgIntensity, bgIntensity, underline, otherAttributes}
-}
-
-func convertWinAttr(textAttr *textAttributes) uint16 {
-        var winAttr uint16 = 0
-        winAttr |= textAttr.foregroundColor
-        winAttr |= textAttr.backgroundColor
-        winAttr |= textAttr.foregroundIntensity
-        winAttr |= textAttr.backgroundIntensity
-        winAttr |= textAttr.underscore
-        winAttr |= textAttr.otherAttributes
-        return winAttr
-}
-
-func changeColor(param []byte) {
-        if defaultAttr == nil {
-                return
-        }
-
-        screenInfo := getConsoleScreenBufferInfo(uintptr(syscall.Stdout))
-        if screenInfo == nil {
-                return
-        }
-
-        winAttr := convertTextAttr(screenInfo.WAttributes)
-        strParam := string(param)
-        if len(strParam) <= 0 {
-                strParam = "0"
-        }
-        csiParam := strings.Split(strParam, string(separatorChar))
-        for _, p := range csiParam {
-                c, ok := colorMap[p]
-                switch {
-                case !ok:
-                        switch p {
-                        case ansiReset:
-                                winAttr.foregroundColor = defaultAttr.foregroundColor
-                                winAttr.backgroundColor = defaultAttr.backgroundColor
-                                winAttr.foregroundIntensity = defaultAttr.foregroundIntensity
-                                winAttr.backgroundIntensity = defaultAttr.backgroundIntensity
-                                winAttr.underscore = 0
-                                winAttr.otherAttributes = 0
-                        case ansiIntensityOn:
-                                winAttr.foregroundIntensity = foregroundIntensity
-                        case ansiIntensityOff:
-                                winAttr.foregroundIntensity = 0
-                        case ansiUnderlineOn:
-                                winAttr.underscore = underscore
-                        case ansiUnderlineOff:
-                                winAttr.underscore = 0
-                        case ansiBlinkOn:
-                                winAttr.backgroundIntensity = backgroundIntensity
-                        case ansiBlinkOff:
-                                winAttr.backgroundIntensity = 0
-                        default:
-                                // unknown code
-                        }
-                case c.drawType == foreground:
-                        winAttr.foregroundColor = c.code
-                case c.drawType == background:
-                        winAttr.backgroundColor = c.code
-                }
-        }
-        winTextAttribute := convertWinAttr(winAttr)
-        setConsoleTextAttribute(uintptr(syscall.Stdout), winTextAttribute)
-}
-
-func parseEscapeSequence(command byte, param []byte) {
-        switch command {
-        case sgrCode:
-                changeColor(param)
-        }
-}
-
-func isParameterChar(b byte) bool {
-        return ('0' <= b && b <= '9') || b == separatorChar
-}
-
-func (cw *ansiColorWriter) Write(p []byte) (int, error) {
-        r, nw, nc, first, last := 0, 0, 0, 0, 0
-        var err error
-        for i, ch := range p {
-                switch cw.state {
-                case outsideCsiCode:
-                        if ch == firstCsiChar {
-                                nc++
-                                cw.state = firstCsiCode
-                        }
-                case firstCsiCode:
-                        switch ch {
-                        case firstCsiChar:
-                                nc++
-                                break
-                        case secondeCsiChar:
-                                nc++
-                                cw.state = secondeCsiCode
-                                last = i - 1
-                        default:
-                                cw.state = outsideCsiCode
-                        }
-                case secondeCsiCode:
-                        nc++
-                        if isParameterChar(ch) {
-                                cw.paramBuf.WriteByte(ch)
-                        } else {
-                                nw, err = cw.w.Write(p[first:last])
-                                r += nw
-                                if err != nil {
-                                        return r, err
-                                }
-                                first = i + 1
-                                param := cw.paramBuf.Bytes()
-                                cw.paramBuf.Reset()
-                                parseEscapeSequence(ch, param)
-                                cw.state = outsideCsiCode
-                        }
-                default:
-                        cw.state = outsideCsiCode
-                }
-        }
-
-        if cw.state == outsideCsiCode {
-                nw, err = cw.w.Write(p[first:len(p)])
-        }
-
-        return r + nw + nc, err
-}
diff --git a/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor_windows_test.go b/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor_windows_test.go
deleted file mode 100644
index 227c870..0000000
--- a/Godeps/_workspace/src/github.com/shiena/ansicolor/ansicolor_windows_test.go
+++ /dev/null
@@ -1,220 +0,0 @@
-// Copyright 2014 shiena Authors. All rights reserved.
-// Use of this source code is governed by a MIT-style
-// license that can be found in the LICENSE file.
-
-// +build windows
-
-package ansicolor_test
-
-import (
-        "bytes"
-        "fmt"
-        "syscall"
-        "testing"
-
-        "github.com/stevenjack/cig/Godeps/_workspace/src/github.com/shiena/ansicolor"
-        . "github.com/stevenjack/cig/Godeps/_workspace/src/github.com/shiena/ansicolor"
-)
-
-func TestWritePlanText(t *testing.T) {
-        inner := bytes.NewBufferString("")
-        w := ansicolor.NewAnsiColorWriter(inner)
-        expected := "plain text"
-        fmt.Fprintf(w, expected)
-        actual := inner.String()
-        if actual != expected {
-                t.Errorf("Get %s, want %s", actual, expected)
-        }
-}
-
-func TestWriteParseText(t *testing.T) {
-        inner := bytes.NewBufferString("")
-        w := ansicolor.NewAnsiColorWriter(inner)
-
-        inputTail := "\x1b[0mtail text"
-        expectedTail := "tail text"
-        fmt.Fprintf(w, inputTail)
-        actualTail := inner.String()
-        inner.Reset()
-        if actualTail != expectedTail {
-                t.Errorf("Get %s, want %s", actualTail, expectedTail)
-        }
-
-        inputHead := "head text\x1b[0m"
-        expectedHead := "head text"
-        fmt.Fprintf(w, inputHead)
-        actualHead := inner.String()
-        inner.Reset()
-        if actualHead != expectedHead {
-                t.Errorf("Get %s, want %s", actualHead, expectedHead)
-        }
-
-        inputBothEnds := "both ends \x1b[0m text"
-        expectedBothEnds := "both ends  text"
-        fmt.Fprintf(w, inputBothEnds)
-        actualBothEnds := inner.String()
-        inner.Reset()
-        if actualBothEnds != expectedBothEnds {
-                t.Errorf("Get %s, want %s", actualBothEnds, expectedBothEnds)
-        }
-
-        inputManyEsc := "\x1b\x1b\x1b\x1b[0m many esc"
-        expectedManyEsc := "\x1b\x1b\x1b many esc"
-        fmt.Fprintf(w, inputManyEsc)
-        actualManyEsc := inner.String()
-        inner.Reset()
-        if actualManyEsc != expectedManyEsc {
-                t.Errorf("Get %s, want %s", actualManyEsc, expectedManyEsc)
-        }
-
-        expectedSplit := "split  text"
-        for _, ch := range "split \x1b[0m text" {
-                fmt.Fprintf(w, string(ch))
-        }
-        actualSplit := inner.String()
-        inner.Reset()
-        if actualSplit != expectedSplit {
-                t.Errorf("Get %s, want %s", actualSplit, expectedSplit)
-        }
-}
-
-type screenNotFoundError struct {
-        error
-}
-
-func writeAnsiColor(expectedText, colorCode string) (actualText string, actualAttributes uint16, err error) {
-        inner := bytes.NewBufferString("")
-        w := ansicolor.NewAnsiColorWriter(inner)
-        fmt.Fprintf(w, "\x1b[%sm%s", colorCode, expectedText)
-
-        actualText = inner.String()
-        screenInfo := GetConsoleScreenBufferInfo(uintptr(syscall.Stdout))
-        if screenInfo != nil {
-                actualAttributes = screenInfo.WAttributes
-        } else {
-                err = &screenNotFoundError{}
-        }
-        return
-}
-
-type testParam struct {
-        text       string
-        attributes uint16
-        ansiColor  string
-}
-
-func TestWriteAnsiColorText(t *testing.T) {
-        screenInfo := GetConsoleScreenBufferInfo(uintptr(syscall.Stdout))
-        if screenInfo == nil {
-                t.Fatal("Could not get ConsoleScreenBufferInfo")
-        }
-        defer ChangeColor(screenInfo.WAttributes)
-        defaultFgColor := screenInfo.WAttributes & uint16(0x0007)
-        defaultBgColor := screenInfo.WAttributes & uint16(0x0070)
-        defaultFgIntensity := screenInfo.WAttributes & uint16(0x0008)
-        defaultBgIntensity := screenInfo.WAttributes & uint16(0x0080)
-
-        fgParam := []testParam{
-                {"foreground black  ", uint16(0x0000 | 0x0000), "30"},
-                {"foreground red    ", uint16(0x0004 | 0x0000), "31"},
-                {"foreground green  ", uint16(0x0002 | 0x0000), "32"},
-                {"foreground yellow ", uint16(0x0006 | 0x0000), "33"},
-                {"foreground blue   ", uint16(0x0001 | 0x0000), "34"},
-                {"foreground magenta", uint16(0x0005 | 0x0000), "35"},
-                {"foreground cyan   ", uint16(0x0003 | 0x0000), "36"},
-                {"foreground white  ", uint16(0x0007 | 0x0000), "37"},
-                {"foreground default", defaultFgColor | 0x0000, "39"},
-        }
-
-        bgParam := []testParam{
-                {"background black  ", uint16(0x0007 | 0x0000), "40"},
-                {"background red    ", uint16(0x0007 | 0x0040), "41"},
-                {"background green  ", uint16(0x0007 | 0x0020), "42"},
-                {"background yellow ", uint16(0x0007 | 0x0060), "43"},
-                {"background blue   ", uint16(0x0007 | 0x0010), "44"},
-                {"background magenta", uint16(0x0007 | 0x0050), "45"},
-                {"background cyan   ", uint16(0x0007 | 0x0030), "46"},
-                {"background white  ", uint16(0x0007 | 0x0070), "47"},
-                {"background default", uint16(0x0007) | defaultBgColor, "49"},
-        }
-
-        resetParam := []testParam{
-                {"all reset", defaultFgColor | defaultBgColor | defaultFgIntensity | defaultBgIntensity, "0"},
-                {"all reset", defaultFgColor | defaultBgColor | defaultFgIntensity | defaultBgIntensity, ""},
-        }
-
-        boldParam := []testParam{
-                {"bold on", uint16(0x0007 | 0x0008), "1"},
-                {"bold off", uint16(0x0007), "21"},
-        }
-
-        underscoreParam := []testParam{
-                {"underscore on", uint16(0x0007 | 0x8000), "4"},
-                {"underscore off", uint16(0x0007), "24"},
-        }
-
-        blinkParam := []testParam{
-                {"blink on", uint16(0x0007 | 0x0080), "5"},
-                {"blink off", uint16(0x0007), "25"},
-        }
-
-        mixedParam := []testParam{
-                {"both black,   bold, underline, blink", uint16(0x0000 | 0x0000 | 0x0008 | 0x8000 | 0x0080), "30;40;1;4;5"},
-                {"both red,     bold, underline, blink", uint16(0x0004 | 0x0040 | 0x0008 | 0x8000 | 0x0080), "31;41;1;4;5"},
-                {"both green,   bold, underline, blink", uint16(0x0002 | 0x0020 | 0x0008 | 0x8000 | 0x0080), "32;42;1;4;5"},
-                {"both yellow,  bold, underline, blink", uint16(0x0006 | 0x0060 | 0x0008 | 0x8000 | 0x0080), "33;43;1;4;5"},
-                {"both blue,    bold, underline, blink", uint16(0x0001 | 0x0010 | 0x0008 | 0x8000 | 0x0080), "34;44;1;4;5"},
-                {"both magenta, bold, underline, blink", uint16(0x0005 | 0x0050 | 0x0008 | 0x8000 | 0x0080), "35;45;1;4;5"},
-                {"both cyan,    bold, underline, blink", uint16(0x0003 | 0x0030 | 0x0008 | 0x8000 | 0x0080), "36;46;1;4;5"},
-                {"both white,   bold, underline, blink", uint16(0x0007 | 0x0070 | 0x0008 | 0x8000 | 0x0080), "37;47;1;4;5"},
-                {"both default, bold, underline, blink", uint16(defaultFgColor | defaultBgColor | 0x0008 | 0x8000 | 0x0080), "39;49;1;4;5"},
-        }
-
-        assertTextAttribute := func(expectedText string, expectedAttributes uint16, ansiColor string) {
-                actualText, actualAttributes, err := writeAnsiColor(expectedText, ansiColor)
-                if actualText != expectedText {
-                        t.Errorf("Get %s, want %s", actualText, expectedText)
-                }
-                if err != nil {
-                        t.Fatal("Could not get ConsoleScreenBufferInfo")
-                }
-                if actualAttributes != expectedAttributes {
-                        t.Errorf("Text: %s, Get 0x%04x, want 0x%04x", expectedText, actualAttributes, expectedAttributes)
-                }
-        }
-
-        for _, v := range fgParam {
-                ResetColor()
-                assertTextAttribute(v.text, v.attributes, v.ansiColor)
-        }
-
-        for _, v := range bgParam {
-                ChangeColor(uint16(0x0070 | 0x0007))
-                assertTextAttribute(v.text, v.attributes, v.ansiColor)
-        }
-
-        for _, v := range resetParam {
-                ChangeColor(uint16(0x0000 | 0x0070 | 0x0008))
-                assertTextAttribute(v.text, v.attributes, v.ansiColor)
-        }
-
-        ResetColor()
-        for _, v := range boldParam {
-                assertTextAttribute(v.text, v.attributes, v.ansiColor)
-        }
-
-        ResetColor()
-        for _, v := range underscoreParam {
-                assertTextAttribute(v.text, v.attributes, v.ansiColor)
-        }
-
-        ResetColor()
-        for _, v := range blinkParam {
-                assertTextAttribute(v.text, v.attributes, v.ansiColor)
-        }
-
-        for _, v := range mixedParam {
-                ResetColor()
-                assertTextAttribute(v.text, v.attributes, v.ansiColor)
-        }
-}
diff --git a/Godeps/_workspace/src/github.com/shiena/ansicolor/example_test.go b/Godeps/_workspace/src/github.com/shiena/ansicolor/example_test.go
deleted file mode 100644
index bcfb28f..0000000
--- a/Godeps/_workspace/src/github.com/shiena/ansicolor/example_test.go
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright 2014 shiena Authors. All rights reserved.
-// Use of this source code is governed by a MIT-style
-// license that can be found in the LICENSE file.
-
-package ansicolor_test
-
-import (
-        "fmt"
-        "os"
-
-        "github.com/stevenjack/cig/Godeps/_workspace/src/github.com/shiena/ansicolor"
-)
-
-func ExampleNewAnsiColorWriter() {
-        w := ansicolor.NewAnsiColorWriter(os.Stdout)
-        text := "%sforeground %sbold%s %sbackground%s\n"
-        fmt.Fprintf(w, text, "\x1b[31m", "\x1b[1m", "\x1b[21m", "\x1b[41;32m", "\x1b[0m")
-        fmt.Fprintf(w, text, "\x1b[32m", "\x1b[1m", "\x1b[21m", "\x1b[42;31m", "\x1b[0m")
-        fmt.Fprintf(w, text, "\x1b[33m", "\x1b[1m", "\x1b[21m", "\x1b[43;34m", "\x1b[0m")
-        fmt.Fprintf(w, text, "\x1b[34m", "\x1b[1m", "\x1b[21m", "\x1b[44;33m", "\x1b[0m")
-        fmt.Fprintf(w, text, "\x1b[35m", "\x1b[1m", "\x1b[21m", "\x1b[45;36m", "\x1b[0m")
-        fmt.Fprintf(w, text, "\x1b[36m", "\x1b[1m", "\x1b[21m", "\x1b[46;35m", "\x1b[0m")
-        fmt.Fprintf(w, text, "\x1b[37m", "\x1b[1m", "\x1b[21m", "\x1b[47;30m", "\x1b[0m")
-}
diff --git a/Godeps/_workspace/src/github.com/shiena/ansicolor/export_test.go b/Godeps/_workspace/src/github.com/shiena/ansicolor/export_test.go
deleted file mode 100644
index e179fe9..0000000
--- a/Godeps/_workspace/src/github.com/shiena/ansicolor/export_test.go
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright 2014 shiena Authors. All rights reserved.
-// Use of this source code is governed by a MIT-style
-// license that can be found in the LICENSE file.
-
-// +build windows
-
-package ansicolor
-
-import "syscall"
-
-var GetConsoleScreenBufferInfo = getConsoleScreenBufferInfo
-
-func ChangeColor(color uint16) {
-        setConsoleTextAttribute(uintptr(syscall.Stdout), color)
-}
-
-func ResetColor() {
-        ChangeColor(uint16(0x0007))
-}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/LICENSE b/Godeps/_workspace/src/gopkg.in/yaml.v2/LICENSE
deleted file mode 100644
index a68e67f..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/LICENSE
+++ /dev/null
@@ -1,188 +0,0 @@
-
-Copyright (c) 2011-2014 - Canonical Inc.
-
-This software is licensed under the LGPLv3, included below.
-
-As a special exception to the GNU Lesser General Public License version 3
-("LGPL3"), the copyright holders of this Library give you permission to
-convey to a third party a Combined Work that links statically or dynamically
-to this Library without providing any Minimal Corresponding Source or
-Minimal Application Code as set out in 4d or providing the installation
-information set out in section 4e, provided that you comply with the other
-provisions of LGPL3 and provided that you meet, for the Application the
-terms and conditions of the license(s) which apply to the Application.
-
-Except as stated in this special exception, the provisions of LGPL3 will
-continue to comply in full to this Library. If you modify this Library, you
-may apply this exception to your version of this Library, but you are not
-obliged to do so. If you do not wish to do so, delete this exception
-statement from your version. This exception does not (and cannot) modify any
-license terms which apply to the Application, with which you must still
-comply.
-
-
-                   GNU LESSER GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-
-  This version of the GNU Lesser General Public License incorporates
-the terms and conditions of version 3 of the GNU General Public
-License, supplemented by the additional permissions listed below.
-
-  0. Additional Definitions.
-
-  As used herein, "this License" refers to version 3 of the GNU Lesser
-General Public License, and the "GNU GPL" refers to version 3 of the GNU
-General Public License.
-
-  "The Library" refers to a covered work governed by this License,
-other than an Application or a Combined Work as defined below.
-
-  An "Application" is any work that makes use of an interface provided
-by the Library, but which is not otherwise based on the Library.
-Defining a subclass of a class defined by the Library is deemed a mode
-of using an interface provided by the Library.
-
-  A "Combined Work" is a work produced by combining or linking an
-Application with the Library.  The particular version of the Library
-with which the Combined Work was made is also called the "Linked
-Version".
-
-  The "Minimal Corresponding Source" for a Combined Work means the
-Corresponding Source for the Combined Work, excluding any source code
-for portions of the Combined Work that, considered in isolation, are
-based on the Application, and not on the Linked Version.
-
-  The "Corresponding Application Code" for a Combined Work means the
-object code and/or source code for the Application, including any data
-and utility programs needed for reproducing the Combined Work from the
-Application, but excluding the System Libraries of the Combined Work.
-
-  1. Exception to Section 3 of the GNU GPL.
-
-  You may convey a covered work under sections 3 and 4 of this License
-without being bound by section 3 of the GNU GPL.
-
-  2. Conveying Modified Versions.
-
-  If you modify a copy of the Library, and, in your modifications, a
-facility refers to a function or data to be supplied by an Application
-that uses the facility (other than as an argument passed when the
-facility is invoked), then you may convey a copy of the modified
-version:
-
-   a) under this License, provided that you make a good faith effort to
-   ensure that, in the event an Application does not supply the
-   function or data, the facility still operates, and performs
-   whatever part of its purpose remains meaningful, or
-
-   b) under the GNU GPL, with none of the additional permissions of
-   this License applicable to that copy.
-
-  3. Object Code Incorporating Material from Library Header Files.
-
-  The object code form of an Application may incorporate material from
-a header file that is part of the Library.  You may convey such object
-code under terms of your choice, provided that, if the incorporated
-material is not limited to numerical parameters, data structure
-layouts and accessors, or small macros, inline functions and templates
-(ten or fewer lines in length), you do both of the following:
-
-   a) Give prominent notice with each copy of the object code that the
-   Library is used in it and that the Library and its use are
-   covered by this License.
-
-   b) Accompany the object code with a copy of the GNU GPL and this license
-   document.
-
-  4. Combined Works.
-
-  You may convey a Combined Work under terms of your choice that,
-taken together, effectively do not restrict modification of the
-portions of the Library contained in the Combined Work and reverse
-engineering for debugging such modifications, if you also do each of
-the following:
-
-   a) Give prominent notice with each copy of the Combined Work that
-   the Library is used in it and that the Library and its use are
-   covered by this License.
-
-   b) Accompany the Combined Work with a copy of the GNU GPL and this license
-   document.
-
-   c) For a Combined Work that displays copyright notices during
-   execution, include the copyright notice for the Library among
-   these notices, as well as a reference directing the user to the
-   copies of the GNU GPL and this license document.
-
-   d) Do one of the following:
-
-       0) Convey the Minimal Corresponding Source under the terms of this
-       License, and the Corresponding Application Code in a form
-       suitable for, and under terms that permit, the user to
-       recombine or relink the Application with a modified version of
-       the Linked Version to produce a modified Combined Work, in the
-       manner specified by section 6 of the GNU GPL for conveying
-       Corresponding Source.
-
-       1) Use a suitable shared library mechanism for linking with the
-       Library.  A suitable mechanism is one that (a) uses at run time
-       a copy of the Library already present on the user's computer
-       system, and (b) will operate properly with a modified version
-       of the Library that is interface-compatible with the Linked
-       Version.
-
-   e) Provide Installation Information, but only if you would otherwise
-   be required to provide such information under section 6 of the
-   GNU GPL, and only to the extent that such information is
-   necessary to install and execute a modified version of the
-   Combined Work produced by recombining or relinking the
-   Application with a modified version of the Linked Version. (If
-   you use option 4d0, the Installation Information must accompany
-   the Minimal Corresponding Source and Corresponding Application
-   Code. If you use option 4d1, you must provide the Installation
-   Information in the manner specified by section 6 of the GNU GPL
-   for conveying Corresponding Source.)
-
-  5. Combined Libraries.
-
-  You may place library facilities that are a work based on the
-Library side by side in a single library together with other library
-facilities that are not Applications and are not covered by this
-License, and convey such a combined library under terms of your
-choice, if you do both of the following:
-
-   a) Accompany the combined library with a copy of the same work based
-   on the Library, uncombined with any other library facilities,
-   conveyed under the terms of this License.
-
-   b) Give prominent notice with the combined library that part of it
-   is a work based on the Library, and explaining where to find the
-   accompanying uncombined form of the same work.
-
-  6. Revised Versions of the GNU Lesser General Public License.
-
-  The Free Software Foundation may publish revised and/or new versions
-of the GNU Lesser General Public License from time to time. Such new
-versions will be similar in spirit to the present version, but may
-differ in detail to address new problems or concerns.
-
-  Each version is given a distinguishing version number. If the
-Library as you received it specifies that a certain numbered version
-of the GNU Lesser General Public License "or any later version"
-applies to it, you have the option of following the terms and
-conditions either of that published version or of any later version
-published by the Free Software Foundation. If the Library as you
-received it does not specify a version number of the GNU Lesser
-General Public License, you may choose any version of the GNU Lesser
-General Public License ever published by the Free Software Foundation.
-
-  If the Library as you received it specifies that a proxy can decide
-whether future versions of the GNU Lesser General Public License shall
-apply, that proxy's public statement of acceptance of any version is
-permanent authorization for you to choose that version for the
-Library.
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/LICENSE.libyaml b/Godeps/_workspace/src/gopkg.in/yaml.v2/LICENSE.libyaml
deleted file mode 100644
index 8da58fb..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/LICENSE.libyaml
+++ /dev/null
@@ -1,31 +0,0 @@
-The following files were ported to Go from C files of libyaml, and thus
-are still covered by their original copyright and license:
-
-    apic.go
-    emitterc.go
-    parserc.go
-    readerc.go
-    scannerc.go
-    writerc.go
-    yamlh.go
-    yamlprivateh.go
-
-Copyright (c) 2006 Kirill Simonov
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of
-this software and associated documentation files (the "Software"), to deal in
-the Software without restriction, including without limitation the rights to
-use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-of the Software, and to permit persons to whom the Software is furnished to do
-so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/README.md b/Godeps/_workspace/src/gopkg.in/yaml.v2/README.md
deleted file mode 100644
index 03837cb..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/README.md
+++ /dev/null
@@ -1,127 +0,0 @@
-# YAML support for the Go language
-
-Introduction
-------------
-
-The yaml package enables Go programs to comfortably encode and decode YAML
-values. It was developed within [Canonical](https://www.canonical.com) as
-part of the [juju](https://juju.ubuntu.com) project, and is based on a
-pure Go port of the well-known [libyaml](http://pyyaml.org/wiki/LibYAML)
-C library to parse and generate YAML data quickly and reliably.
-
-Compatibility
--------------
-
-The yaml package supports most of YAML 1.1 and 1.2, including support for
-anchors, tags, map merging, etc. Multi-document unmarshalling is not yet
-implemented, and base-60 floats from YAML 1.1 are purposefully not
-supported since they're a poor design and are gone in YAML 1.2.
-
-Installation and usage
-----------------------
-
-The import path for the package is *gopkg.in/yaml.v2*.
-
-To install it, run:
-
-    go get gopkg.in/yaml.v2
-
-API documentation
------------------
-
-If opened in a browser, the import path itself leads to the API documentation:
-
-  * [https://gopkg.in/yaml.v2](https://gopkg.in/yaml.v2)
-
-API stability
--------------
-
-The package API for yaml v2 will remain stable as described in [gopkg.in](https://gopkg.in).
-
-
-License
--------
-
-The yaml package is licensed under the LGPL with an exception that allows it to be linked statically. Please see the LICENSE file for details.
-
-
-Example
--------
-
-```Go
-package main
-
-import (
-        "fmt"
-        "log"
-
-        "gopkg.in/yaml.v2"
-)
-
-var data = `
-a: Easy!
-b:
-  c: 2
-  d: [3, 4]
-`
-
-type T struct {
-        A string
-        B struct{C int; D []int ",flow"}
-}
-
-func main() {
-        t := T{}
-
-        err := yaml.Unmarshal([]byte(data), &t)
-        if err != nil {
-                log.Fatalf("error: %v", err)
-        }
-        fmt.Printf("--- t:\n%v\n\n", t)
-
-        d, err := yaml.Marshal(&t)
-        if err != nil {
-                log.Fatalf("error: %v", err)
-        }
-        fmt.Printf("--- t dump:\n%s\n\n", string(d))
-
-        m := make(map[interface{}]interface{})
-
-        err = yaml.Unmarshal([]byte(data), &m)
-        if err != nil {
-                log.Fatalf("error: %v", err)
-        }
-        fmt.Printf("--- m:\n%v\n\n", m)
-
-        d, err = yaml.Marshal(&m)
-        if err != nil {
-                log.Fatalf("error: %v", err)
-        }
-        fmt.Printf("--- m dump:\n%s\n\n", string(d))
-}
-```
-
-This example will generate the following output:
-
-```
---- t:
-{Easy! {2 [3 4]}}
-
---- t dump:
-a: Easy!
-b:
-  c: 2
-  d: [3, 4]
-
-
---- m:
-map[a:Easy! b:map[c:2 d:[3 4]]]
-
---- m dump:
-a: Easy!
-b:
-  c: 2
-  d:
-  - 3
-  - 4
-```
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/apic.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/apic.go
deleted file mode 100644
index ef3fba1..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/apic.go
+++ /dev/null
@@ -1,742 +0,0 @@
-package yaml
-
-import (
-        "io"
-        "os"
-)
-
-func yaml_insert_token(parser *yaml_parser_t, pos int, token *yaml_token_t) {
-        //fmt.Println("yaml_insert_token", "pos:", pos, "typ:", token.typ, "head:", parser.tokens_head, "len:", len(parser.tokens))
-
-        // Check if we can move the queue at the beginning of the buffer.
-        if parser.tokens_head > 0 && len(parser.tokens) == cap(parser.tokens) {
-                if parser.tokens_head != len(parser.tokens) {
-                        copy(parser.tokens, parser.tokens[parser.tokens_head:])
-                }
-                parser.tokens = parser.tokens[:len(parser.tokens)-parser.tokens_head]
-                parser.tokens_head = 0
-        }
-        parser.tokens = append(parser.tokens, *token)
-        if pos < 0 {
-                return
-        }
-        copy(parser.tokens[parser.tokens_head+pos+1:], parser.tokens[parser.tokens_head+pos:])
-        parser.tokens[parser.tokens_head+pos] = *token
-}
-
-// Create a new parser object.
-func yaml_parser_initialize(parser *yaml_parser_t) bool {
-        *parser = yaml_parser_t{
-                raw_buffer: make([]byte, 0, input_raw_buffer_size),
-                buffer:     make([]byte, 0, input_buffer_size),
-        }
-        return true
-}
-
-// Destroy a parser object.
-func yaml_parser_delete(parser *yaml_parser_t) {
-        *parser = yaml_parser_t{}
-}
-
-// String read handler.
-func yaml_string_read_handler(parser *yaml_parser_t, buffer []byte) (n int, err error) {
-        if parser.input_pos == len(parser.input) {
-                return 0, io.EOF
-        }
-        n = copy(buffer, parser.input[parser.input_pos:])
-        parser.input_pos += n
-        return n, nil
-}
-
-// File read handler.
-func yaml_file_read_handler(parser *yaml_parser_t, buffer []byte) (n int, err error) {
-        return parser.input_file.Read(buffer)
-}
-
-// Set a string input.
-func yaml_parser_set_input_string(parser *yaml_parser_t, input []byte) {
-        if parser.read_handler != nil {
-                panic("must set the input source only once")
-        }
-        parser.read_handler = yaml_string_read_handler
-        parser.input = input
-        parser.input_pos = 0
-}
-
-// Set a file input.
-func yaml_parser_set_input_file(parser *yaml_parser_t, file *os.File) {
-        if parser.read_handler != nil {
-                panic("must set the input source only once")
-        }
-        parser.read_handler = yaml_file_read_handler
-        parser.input_file = file
-}
-
-// Set the source encoding.
-func yaml_parser_set_encoding(parser *yaml_parser_t, encoding yaml_encoding_t) {
-        if parser.encoding != yaml_ANY_ENCODING {
-                panic("must set the encoding only once")
-        }
-        parser.encoding = encoding
-}
-
-// Create a new emitter object.
-func yaml_emitter_initialize(emitter *yaml_emitter_t) bool {
-        *emitter = yaml_emitter_t{
-                buffer:     make([]byte, output_buffer_size),
-                raw_buffer: make([]byte, 0, output_raw_buffer_size),
-                states:     make([]yaml_emitter_state_t, 0, initial_stack_size),
-                events:     make([]yaml_event_t, 0, initial_queue_size),
-        }
-        return true
-}
-
-// Destroy an emitter object.
-func yaml_emitter_delete(emitter *yaml_emitter_t) {
-        *emitter = yaml_emitter_t{}
-}
-
-// String write handler.
-func yaml_string_write_handler(emitter *yaml_emitter_t, buffer []byte) error {
-        *emitter.output_buffer = append(*emitter.output_buffer, buffer...)
-        return nil
-}
-
-// File write handler.
-func yaml_file_write_handler(emitter *yaml_emitter_t, buffer []byte) error {
-        _, err := emitter.output_file.Write(buffer)
-        return err
-}
-
-// Set a string output.
-func yaml_emitter_set_output_string(emitter *yaml_emitter_t, output_buffer *[]byte) {
-        if emitter.write_handler != nil {
-                panic("must set the output target only once")
-        }
-        emitter.write_handler = yaml_string_write_handler
-        emitter.output_buffer = output_buffer
-}
-
-// Set a file output.
-func yaml_emitter_set_output_file(emitter *yaml_emitter_t, file io.Writer) {
-        if emitter.write_handler != nil {
-                panic("must set the output target only once")
-        }
-        emitter.write_handler = yaml_file_write_handler
-        emitter.output_file = file
-}
-
-// Set the output encoding.
-func yaml_emitter_set_encoding(emitter *yaml_emitter_t, encoding yaml_encoding_t) {
-        if emitter.encoding != yaml_ANY_ENCODING {
-                panic("must set the output encoding only once")
-        }
-        emitter.encoding = encoding
-}
-
-// Set the canonical output style.
-func yaml_emitter_set_canonical(emitter *yaml_emitter_t, canonical bool) {
-        emitter.canonical = canonical
-}
-
-//// Set the indentation increment.
-func yaml_emitter_set_indent(emitter *yaml_emitter_t, indent int) {
-        if indent < 2 || indent > 9 {
-                indent = 2
-        }
-        emitter.best_indent = indent
-}
-
-// Set the preferred line width.
-func yaml_emitter_set_width(emitter *yaml_emitter_t, width int) {
-        if width < 0 {
-                width = -1
-        }
-        emitter.best_width = width
-}
-
-// Set if unescaped non-ASCII characters are allowed.
-func yaml_emitter_set_unicode(emitter *yaml_emitter_t, unicode bool) {
-        emitter.unicode = unicode
-}
-
-// Set the preferred line break character.
-func yaml_emitter_set_break(emitter *yaml_emitter_t, line_break yaml_break_t) {
-        emitter.line_break = line_break
-}
-
-///*
-// * Destroy a token object.
-// */
-//
-//YAML_DECLARE(void)
-//yaml_token_delete(yaml_token_t *token)
-//{
-//    assert(token);  // Non-NULL token object expected.
-//
-//    switch (token.type)
-//    {
-//        case YAML_TAG_DIRECTIVE_TOKEN:
-//            yaml_free(token.data.tag_directive.handle);
-//            yaml_free(token.data.tag_directive.prefix);
-//            break;
-//
-//        case YAML_ALIAS_TOKEN:
-//            yaml_free(token.data.alias.value);
-//            break;
-//
-//        case YAML_ANCHOR_TOKEN:
-//            yaml_free(token.data.anchor.value);
-//            break;
-//
-//        case YAML_TAG_TOKEN:
-//            yaml_free(token.data.tag.handle);
-//            yaml_free(token.data.tag.suffix);
-//            break;
-//
-//        case YAML_SCALAR_TOKEN:
-//            yaml_free(token.data.scalar.value);
-//            break;
-//
-//        default:
-//            break;
-//    }
-//
-//    memset(token, 0, sizeof(yaml_token_t));
-//}
-//
-///*
-// * Check if a string is a valid UTF-8 sequence.
-// *
-// * Check 'reader.c' for more details on UTF-8 encoding.
-// */
-//
-//static int
-//yaml_check_utf8(yaml_char_t *start, size_t length)
-//{
-//    yaml_char_t *end = start+length;
-//    yaml_char_t *pointer = start;
-//
-//    while (pointer < end) {
-//        unsigned char octet;
-//        unsigned int width;
-//        unsigned int value;
-//        size_t k;
-//
-//        octet = pointer[0];
-//        width = (octet & 0x80) == 0x00 ? 1 :
-//                (octet & 0xE0) == 0xC0 ? 2 :
-//                (octet & 0xF0) == 0xE0 ? 3 :
-//                (octet & 0xF8) == 0xF0 ? 4 : 0;
-//        value = (octet & 0x80) == 0x00 ? octet & 0x7F :
-//                (octet & 0xE0) == 0xC0 ? octet & 0x1F :
-//                (octet & 0xF0) == 0xE0 ? octet & 0x0F :
-//                (octet & 0xF8) == 0xF0 ? octet & 0x07 : 0;
-//        if (!width) return 0;
-//        if (pointer+width > end) return 0;
-//        for (k = 1; k < width; k ++) {
-//            octet = pointer[k];
-//            if ((octet & 0xC0) != 0x80) return 0;
-//            value = (value << 6) + (octet & 0x3F);
-//        }
-//        if (!((width == 1) ||
-//            (width == 2 && value >= 0x80) ||
-//            (width == 3 && value >= 0x800) ||
-//            (width == 4 && value >= 0x10000))) return 0;
-//
-//        pointer += width;
-//    }
-//
-//    return 1;
-//}
-//
-
-// Create STREAM-START.
-func yaml_stream_start_event_initialize(event *yaml_event_t, encoding yaml_encoding_t) bool {
-        *event = yaml_event_t{
-                typ:      yaml_STREAM_START_EVENT,
-                encoding: encoding,
-        }
-        return true
-}
-
-// Create STREAM-END.
-func yaml_stream_end_event_initialize(event *yaml_event_t) bool {
-        *event = yaml_event_t{
-                typ: yaml_STREAM_END_EVENT,
-        }
-        return true
-}
-
-// Create DOCUMENT-START.
-func yaml_document_start_event_initialize(event *yaml_event_t, version_directive *yaml_version_directive_t,
-        tag_directives []yaml_tag_directive_t, implicit bool) bool {
-        *event = yaml_event_t{
-                typ:               yaml_DOCUMENT_START_EVENT,
-                version_directive: version_directive,
-                tag_directives:    tag_directives,
-                implicit:          implicit,
-        }
-        return true
-}
-
-// Create DOCUMENT-END.
-func yaml_document_end_event_initialize(event *yaml_event_t, implicit bool) bool {
-        *event = yaml_event_t{
-                typ:      yaml_DOCUMENT_END_EVENT,
-                implicit: implicit,
-        }
-        return true
-}
-
-///*
-// * Create ALIAS.
-// */
-//
-//YAML_DECLARE(int)
-//yaml_alias_event_initialize(event *yaml_event_t, anchor *yaml_char_t)
-//{
-//    mark yaml_mark_t = { 0, 0, 0 }
-//    anchor_copy *yaml_char_t = NULL
-//
-//    assert(event) // Non-NULL event object is expected.
-//    assert(anchor) // Non-NULL anchor is expected.
-//
-//    if (!yaml_check_utf8(anchor, strlen((char *)anchor))) return 0
-//
-//    anchor_copy = yaml_strdup(anchor)
-//    if (!anchor_copy)
-//        return 0
-//
-//    ALIAS_EVENT_INIT(*event, anchor_copy, mark, mark)
-//
-//    return 1
-//}
-
-// Create SCALAR.
-func yaml_scalar_event_initialize(event *yaml_event_t, anchor, tag, value []byte, plain_implicit, quoted_implicit bool, style yaml_scalar_style_t) bool {
-        *event = yaml_event_t{
-                typ:             yaml_SCALAR_EVENT,
-                anchor:          anchor,
-                tag:             tag,
-                value:           value,
-                implicit:        plain_implicit,
-                quoted_implicit: quoted_implicit,
-                style:           yaml_style_t(style),
-        }
-        return true
-}
-
-// Create SEQUENCE-START.
-func yaml_sequence_start_event_initialize(event *yaml_event_t, anchor, tag []byte, implicit bool, style yaml_sequence_style_t) bool {
-        *event = yaml_event_t{
-                typ:      yaml_SEQUENCE_START_EVENT,
-                anchor:   anchor,
-                tag:      tag,
-                implicit: implicit,
-                style:    yaml_style_t(style),
-        }
-        return true
-}
-
-// Create SEQUENCE-END.
-func yaml_sequence_end_event_initialize(event *yaml_event_t) bool {
-        *event = yaml_event_t{
-                typ: yaml_SEQUENCE_END_EVENT,
-        }
-        return true
-}
-
-// Create MAPPING-START.
-func yaml_mapping_start_event_initialize(event *yaml_event_t, anchor, tag []byte, implicit bool, style yaml_mapping_style_t) bool {
-        *event = yaml_event_t{
-                typ:      yaml_MAPPING_START_EVENT,
-                anchor:   anchor,
-                tag:      tag,
-                implicit: implicit,
-                style:    yaml_style_t(style),
-        }
-        return true
-}
-
-// Create MAPPING-END.
-func yaml_mapping_end_event_initialize(event *yaml_event_t) bool {
-        *event = yaml_event_t{
-                typ: yaml_MAPPING_END_EVENT,
-        }
-        return true
-}
-
-// Destroy an event object.
-func yaml_event_delete(event *yaml_event_t) {
-        *event = yaml_event_t{}
-}
-
-///*
-// * Create a document object.
-// */
-//
-//YAML_DECLARE(int)
-//yaml_document_initialize(document *yaml_document_t,
-//        version_directive *yaml_version_directive_t,
-//        tag_directives_start *yaml_tag_directive_t,
-//        tag_directives_end *yaml_tag_directive_t,
-//        start_implicit int, end_implicit int)
-//{
-//    struct {
-//        error yaml_error_type_t
-//    } context
-//    struct {
-//        start *yaml_node_t
-//        end *yaml_node_t
-//        top *yaml_node_t
-//    } nodes = { NULL, NULL, NULL }
-//    version_directive_copy *yaml_version_directive_t = NULL
-//    struct {
-//        start *yaml_tag_directive_t
-//        end *yaml_tag_directive_t
-//        top *yaml_tag_directive_t
-//    } tag_directives_copy = { NULL, NULL, NULL }
-//    value yaml_tag_directive_t = { NULL, NULL }
-//    mark yaml_mark_t = { 0, 0, 0 }
-//
-//    assert(document) // Non-NULL document object is expected.
-//    assert((tag_directives_start && tag_directives_end) ||
-//            (tag_directives_start == tag_directives_end))
-//                            // Valid tag directives are expected.
-//
-//    if (!STACK_INIT(&context, nodes, INITIAL_STACK_SIZE)) goto error
-//
-//    if (version_directive) {
-//        version_directive_copy = yaml_malloc(sizeof(yaml_version_directive_t))
-//        if (!version_directive_copy) goto error
-//        version_directive_copy.major = version_directive.major
-//        version_directive_copy.minor = version_directive.minor
-//    }
-//
-//    if (tag_directives_start != tag_directives_end) {
-//        tag_directive *yaml_tag_directive_t
-//        if (!STACK_INIT(&context, tag_directives_copy, INITIAL_STACK_SIZE))
-//            goto error
-//        for (tag_directive = tag_directives_start
-//                tag_directive != tag_directives_end; tag_directive ++) {
-//            assert(tag_directive.handle)
-//            assert(tag_directive.prefix)
-//            if (!yaml_check_utf8(tag_directive.handle,
-//                        strlen((char *)tag_directive.handle)))
-//                goto error
-//            if (!yaml_check_utf8(tag_directive.prefix,
-//                        strlen((char *)tag_directive.prefix)))
-//                goto error
-//            value.handle = yaml_strdup(tag_directive.handle)
-//            value.prefix = yaml_strdup(tag_directive.prefix)
-//            if (!value.handle || !value.prefix) goto error
-//            if (!PUSH(&context, tag_directives_copy, value))
-//                goto error
-//            value.handle = NULL
-//            value.prefix = NULL
-//        }
-//    }
-//
-//    DOCUMENT_INIT(*document, nodes.start, nodes.end, version_directive_copy,
-//            tag_directives_copy.start, tag_directives_copy.top,
-//            start_implicit, end_implicit, mark, mark)
-//
-//    return 1
-//
-//error:
-//    STACK_DEL(&context, nodes)
-//    yaml_free(version_directive_copy)
-//    while (!STACK_EMPTY(&context, tag_directives_copy)) {
-//        value yaml_tag_directive_t = POP(&context, tag_directives_copy)
-//        yaml_free(value.handle)
-//        yaml_free(value.prefix)
-//    }
-//    STACK_DEL(&context, tag_directives_copy)
-//    yaml_free(value.handle)
-//    yaml_free(value.prefix)
-//
-//    return 0
-//}
-//
-///*
-// * Destroy a document object.
-// */
-//
-//YAML_DECLARE(void)
-//yaml_document_delete(document *yaml_document_t)
-//{
-//    struct {
-//        error yaml_error_type_t
-//    } context
-//    tag_directive *yaml_tag_directive_t
-//
-//    context.error = YAML_NO_ERROR // Eliminate a compliler warning.
-//
-//    assert(document) // Non-NULL document object is expected.
-//
-//    while (!STACK_EMPTY(&context, document.nodes)) {
-//        node yaml_node_t = POP(&context, document.nodes)
-//        yaml_free(node.tag)
-//        switch (node.type) {
-//            case YAML_SCALAR_NODE:
-//                yaml_free(node.data.scalar.value)
-//                break
-//            case YAML_SEQUENCE_NODE:
-//                STACK_DEL(&context, node.data.sequence.items)
-//                break
-//            case YAML_MAPPING_NODE:
-//                STACK_DEL(&context, node.data.mapping.pairs)
-//                break
-//            default:
-//                assert(0) // Should not happen.
-//        }
-//    }
-//    STACK_DEL(&context, document.nodes)
-//
-//    yaml_free(document.version_directive)
-//    for (tag_directive = document.tag_directives.start
-//            tag_directive != document.tag_directives.end
-//            tag_directive++) {
-//        yaml_free(tag_directive.handle)
-//        yaml_free(tag_directive.prefix)
-//    }
-//    yaml_free(document.tag_directives.start)
-//
-//    memset(document, 0, sizeof(yaml_document_t))
-//}
-//
-///**
-// * Get a document node.
-// */
-//
-//YAML_DECLARE(yaml_node_t *)
-//yaml_document_get_node(document *yaml_document_t, index int)
-//{
-//    assert(document) // Non-NULL document object is expected.
-//
-//    if (index > 0 && document.nodes.start + index <= document.nodes.top) {
-//        return document.nodes.start + index - 1
-//    }
-//    return NULL
-//}
-//
-///**
-// * Get the root object.
-// */
-//
-//YAML_DECLARE(yaml_node_t *)
-//yaml_document_get_root_node(document *yaml_document_t)
-//{
-//    assert(document) // Non-NULL document object is expected.
-//
-//    if (document.nodes.top != document.nodes.start) {
-//        return document.nodes.start
-//    }
-//    return NULL
-//}
-//
-///*
-// * Add a scalar node to a document.
-// */
-//
-//YAML_DECLARE(int)
-//yaml_document_add_scalar(document *yaml_document_t,
-//        tag *yaml_char_t, value *yaml_char_t, length int,
-//        style yaml_scalar_style_t)
-//{
-//    struct {
-//        error yaml_error_type_t
-//    } context
-//    mark yaml_mark_t = { 0, 0, 0 }
-//    tag_copy *yaml_char_t = NULL
-//    value_copy *yaml_char_t = NULL
-//    node yaml_node_t
-//
-//    assert(document) // Non-NULL document object is expected.
-//    assert(value) // Non-NULL value is expected.
-//
-//    if (!tag) {
-//        tag = (yaml_char_t *)YAML_DEFAULT_SCALAR_TAG
-//    }
-//
-//    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error
-//    tag_copy = yaml_strdup(tag)
-//    if (!tag_copy) goto error
-//
-//    if (length < 0) {
-//        length = strlen((char *)value)
-//    }
-//
-//    if (!yaml_check_utf8(value, length)) goto error
-//    value_copy = yaml_malloc(length+1)
-//    if (!value_copy) goto error
-//    memcpy(value_copy, value, length)
-//    value_copy[length] = '\0'
-//
-//    SCALAR_NODE_INIT(node, tag_copy, value_copy, length, style, mark, mark)
-//    if (!PUSH(&context, document.nodes, node)) goto error
-//
-//    return document.nodes.top - document.nodes.start
-//
-//error:
-//    yaml_free(tag_copy)
-//    yaml_free(value_copy)
-//
-//    return 0
-//}
-//
-///*
-// * Add a sequence node to a document.
-// */
-//
-//YAML_DECLARE(int)
-//yaml_document_add_sequence(document *yaml_document_t,
-//        tag *yaml_char_t, style yaml_sequence_style_t)
-//{
-//    struct {
-//        error yaml_error_type_t
-//    } context
-//    mark yaml_mark_t = { 0, 0, 0 }
-//    tag_copy *yaml_char_t = NULL
-//    struct {
-//        start *yaml_node_item_t
-//        end *yaml_node_item_t
-//        top *yaml_node_item_t
-//    } items = { NULL, NULL, NULL }
-//    node yaml_node_t
-//
-//    assert(document) // Non-NULL document object is expected.
-//
-//    if (!tag) {
-//        tag = (yaml_char_t *)YAML_DEFAULT_SEQUENCE_TAG
-//    }
-//
-//    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error
-//    tag_copy = yaml_strdup(tag)
-//    if (!tag_copy) goto error
-//
-//    if (!STACK_INIT(&context, items, INITIAL_STACK_SIZE)) goto error
-//
-//    SEQUENCE_NODE_INIT(node, tag_copy, items.start, items.end,
-//            style, mark, mark)
-//    if (!PUSH(&context, document.nodes, node)) goto error
-//
-//    return document.nodes.top - document.nodes.start
-//
-//error:
-//    STACK_DEL(&context, items)
-//    yaml_free(tag_copy)
-//
-//    return 0
-//}
-//
-///*
-// * Add a mapping node to a document.
-// */
-//
-//YAML_DECLARE(int)
-//yaml_document_add_mapping(document *yaml_document_t,
-//        tag *yaml_char_t, style yaml_mapping_style_t)
-//{
-//    struct {
-//        error yaml_error_type_t
-//    } context
-//    mark yaml_mark_t = { 0, 0, 0 }
-//    tag_copy *yaml_char_t = NULL
-//    struct {
-//        start *yaml_node_pair_t
-//        end *yaml_node_pair_t
-//        top *yaml_node_pair_t
-//    } pairs = { NULL, NULL, NULL }
-//    node yaml_node_t
-//
-//    assert(document) // Non-NULL document object is expected.
-//
-//    if (!tag) {
-//        tag = (yaml_char_t *)YAML_DEFAULT_MAPPING_TAG
-//    }
-//
-//    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error
-//    tag_copy = yaml_strdup(tag)
-//    if (!tag_copy) goto error
-//
-//    if (!STACK_INIT(&context, pairs, INITIAL_STACK_SIZE)) goto error
-//
-//    MAPPING_NODE_INIT(node, tag_copy, pairs.start, pairs.end,
-//            style, mark, mark)
-//    if (!PUSH(&context, document.nodes, node)) goto error
-//
-//    return document.nodes.top - document.nodes.start
-//
-//error:
-//    STACK_DEL(&context, pairs)
-//    yaml_free(tag_copy)
-//
-//    return 0
-//}
-//
-///*
-// * Append an item to a sequence node.
-// */
-//
-//YAML_DECLARE(int)
-//yaml_document_append_sequence_item(document *yaml_document_t,
-//        sequence int, item int)
-//{
-//    struct {
-//        error yaml_error_type_t
-//    } context
-//
-//    assert(document) // Non-NULL document is required.
-//    assert(sequence > 0
-//            && document.nodes.start + sequence <= document.nodes.top)
-//                            // Valid sequence id is required.
-//    assert(document.nodes.start[sequence-1].type == YAML_SEQUENCE_NODE)
-//                            // A sequence node is required.
-//    assert(item > 0 && document.nodes.start + item <= document.nodes.top)
-//                            // Valid item id is required.
-//
-//    if (!PUSH(&context,
-//                document.nodes.start[sequence-1].data.sequence.items, item))
-//        return 0
-//
-//    return 1
-//}
-//
-///*
-// * Append a pair of a key and a value to a mapping node.
-// */
-//
-//YAML_DECLARE(int)
-//yaml_document_append_mapping_pair(document *yaml_document_t,
-//        mapping int, key int, value int)
-//{
-//    struct {
-//        error yaml_error_type_t
-//    } context
-//
-//    pair yaml_node_pair_t
-//
-//    assert(document) // Non-NULL document is required.
-//    assert(mapping > 0
-//            && document.nodes.start + mapping <= document.nodes.top)
-//                            // Valid mapping id is required.
-//    assert(document.nodes.start[mapping-1].type == YAML_MAPPING_NODE)
-//                            // A mapping node is required.
-//    assert(key > 0 && document.nodes.start + key <= document.nodes.top)
-//                            // Valid key id is required.
-//    assert(value > 0 && document.nodes.start + value <= document.nodes.top)
-//                            // Valid value id is required.
-//
-//    pair.key = key
-//    pair.value = value
-//
-//    if (!PUSH(&context,
-//                document.nodes.start[mapping-1].data.mapping.pairs, pair))
-//        return 0
-//
-//    return 1
-//}
-//
-//
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/decode.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/decode.go
deleted file mode 100644
index 36ee5d6..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/decode.go
+++ /dev/null
@@ -1,665 +0,0 @@
-package yaml
-
-import (
-        "encoding"
-        "encoding/base64"
-        "fmt"
-        "math"
-        "reflect"
-        "strconv"
-        "time"
-)
-
-const (
-        documentNode = 1 << iota
-        mappingNode
-        sequenceNode
-        scalarNode
-        aliasNode
-)
-
-type node struct {
-        kind         int
-        line, column int
-        tag          string
-        value        string
-        implicit     bool
-        children     []*node
-        anchors      map[string]*node
-}
-
-// ----------------------------------------------------------------------------
-// Parser, produces a node tree out of a libyaml event stream.
-
-type parser struct {
-        parser  yaml_parser_t
-        event   yaml_event_t
-        doc     *node
-}
-
-func newParser(b []byte) *parser {
-        p := parser{}
-        if !yaml_parser_initialize(&p.parser) {
-                panic("failed to initialize YAML emitter")
-        }
-
-        if len(b) == 0 {
-                b = []byte{'\n'}
-        }
-
-        yaml_parser_set_input_string(&p.parser, b)
-
-        p.skip()
-        if p.event.typ != yaml_STREAM_START_EVENT {
-                panic("expected stream start event, got " + strconv.Itoa(int(p.event.typ)))
-        }
-        p.skip()
-        return &p
-}
-
-func (p *parser) destroy() {
-        if p.event.typ != yaml_NO_EVENT {
-                yaml_event_delete(&p.event)
-        }
-        yaml_parser_delete(&p.parser)
-}
-
-func (p *parser) skip() {
-        if p.event.typ != yaml_NO_EVENT {
-                if p.event.typ == yaml_STREAM_END_EVENT {
-                        failf("attempted to go past the end of stream; corrupted value?")
-                }
-                yaml_event_delete(&p.event)
-        }
-        if !yaml_parser_parse(&p.parser, &p.event) {
-                p.fail()
-        }
-}
-
-func (p *parser) fail() {
-        var where string
-        var line int
-        if p.parser.problem_mark.line != 0 {
-                line = p.parser.problem_mark.line
-        } else if p.parser.context_mark.line != 0 {
-                line = p.parser.context_mark.line
-        }
-        if line != 0 {
-                where = "line " + strconv.Itoa(line) + ": "
-        }
-        var msg string
-        if len(p.parser.problem) > 0 {
-                msg = p.parser.problem
-        } else {
-                msg = "unknown problem parsing YAML content"
-        }
-        failf("%s%s", where, msg)
-}
-
-func (p *parser) anchor(n *node, anchor []byte) {
-        if anchor != nil {
-                p.doc.anchors[string(anchor)] = n
-        }
-}
-
-func (p *parser) parse() *node {
-        switch p.event.typ {
-        case yaml_SCALAR_EVENT:
-                return p.scalar()
-        case yaml_ALIAS_EVENT:
-                return p.alias()
-        case yaml_MAPPING_START_EVENT:
-                return p.mapping()
-        case yaml_SEQUENCE_START_EVENT:
-                return p.sequence()
-        case yaml_DOCUMENT_START_EVENT:
-                return p.document()
-        case yaml_STREAM_END_EVENT:
-                // Happens when attempting to decode an empty buffer.
-                return nil
-        default:
-                panic("attempted to parse unknown event: " + strconv.Itoa(int(p.event.typ)))
-        }
-        panic("unreachable")
-}
-
-func (p *parser) node(kind int) *node {
-        return &node{
-                kind:   kind,
-                line:   p.event.start_mark.line,
-                column: p.event.start_mark.column,
-        }
-}
-
-func (p *parser) document() *node {
-        n := p.node(documentNode)
-        n.anchors = make(map[string]*node)
-        p.doc = n
-        p.skip()
-        n.children = append(n.children, p.parse())
-        if p.event.typ != yaml_DOCUMENT_END_EVENT {
-                panic("expected end of document event but got " + strconv.Itoa(int(p.event.typ)))
-        }
-        p.skip()
-        return n
-}
-
-func (p *parser) alias() *node {
-        n := p.node(aliasNode)
-        n.value = string(p.event.anchor)
-        p.skip()
-        return n
-}
-
-func (p *parser) scalar() *node {
-        n := p.node(scalarNode)
-        n.value = string(p.event.value)
-        n.tag = string(p.event.tag)
-        n.implicit = p.event.implicit
-        p.anchor(n, p.event.anchor)
-        p.skip()
-        return n
-}
-
-func (p *parser) sequence() *node {
-        n := p.node(sequenceNode)
-        p.anchor(n, p.event.anchor)
-        p.skip()
-        for p.event.typ != yaml_SEQUENCE_END_EVENT {
-                n.children = append(n.children, p.parse())
-        }
-        p.skip()
-        return n
-}
-
-func (p *parser) mapping() *node {
-        n := p.node(mappingNode)
-        p.anchor(n, p.event.anchor)
-        p.skip()
-        for p.event.typ != yaml_MAPPING_END_EVENT {
-                n.children = append(n.children, p.parse(), p.parse())
-        }
-        p.skip()
-        return n
-}
-
-// ----------------------------------------------------------------------------
-// Decoder, unmarshals a node into a provided value.
-
-type decoder struct {
-        doc     *node
-        aliases map[string]bool
-        mapType reflect.Type
-        terrors []string
-}
-
-var (
-        mapItemType = reflect.TypeOf(MapItem{})
-        durationType = reflect.TypeOf(time.Duration(0))
-        defaultMapType = reflect.TypeOf(map[interface{}]interface{}{})
-        ifaceType = defaultMapType.Elem()
-)
-
-func newDecoder() *decoder {
-        d := &decoder{mapType: defaultMapType}
-        d.aliases = make(map[string]bool)
-        return d
-}
-
-func (d *decoder) terror(n *node, tag string, out reflect.Value) {
-        if n.tag != "" {
-                tag = n.tag
-        }
-        value := n.value
-        if tag != yaml_SEQ_TAG && tag != yaml_MAP_TAG {
-                if len(value) > 10 {
-                        value = " `" + value[:7] + "...`"
-                } else {
-                        value = " `" + value + "`"
-                }
-        }
-        d.terrors = append(d.terrors, fmt.Sprintf("line %d: cannot unmarshal %s%s into %s", n.line+1, shortTag(tag), value, out.Type()))
-}
-
-func (d *decoder) callUnmarshaler(n *node, u Unmarshaler) (good bool) {
-        terrlen := len(d.terrors)
-        err := u.UnmarshalYAML(func(v interface{}) (err error) {
-                defer handleErr(&err)
-                d.unmarshal(n, reflect.ValueOf(v))
-                if len(d.terrors) > terrlen {
-                        issues := d.terrors[terrlen:]
-                        d.terrors = d.terrors[:terrlen]
-                        return &TypeError{issues}
-                }
-                return nil
-        })
-        if e, ok := err.(*TypeError); ok {
-                d.terrors = append(d.terrors, e.Errors...)
-                return false
-        }
-        if err != nil {
-                fail(err)
-        }
-        return true
-}
-
-// d.prepare initializes and dereferences pointers and calls UnmarshalYAML
-// if a value is found to implement it.
-// It returns the initialized and dereferenced out value, whether
-// unmarshalling was already done by UnmarshalYAML, and if so whether
-// its types unmarshalled appropriately.
-//
-// If n holds a null value, prepare returns before doing anything.
-func (d *decoder) prepare(n *node, out reflect.Value) (newout reflect.Value, unmarshaled, good bool) {
-        if n.tag == yaml_NULL_TAG || n.kind == scalarNode && n.tag == "" && (n.value == "null" || n.value == "") {
-                return out, false, false
-        }
-        again := true
-        for again {
-                again = false
-                if out.Kind() == reflect.Ptr {
-                        if out.IsNil() {
-                                out.Set(reflect.New(out.Type().Elem()))
-                        }
-                        out = out.Elem()
-                        again = true
-                }
-                if out.CanAddr() {
-                        if u, ok := out.Addr().Interface().(Unmarshaler); ok {
-                                good = d.callUnmarshaler(n, u)
-                                return out, true, good
-                        }
-                }
-        }
-        return out, false, false
-}
-
-func (d *decoder) unmarshal(n *node, out reflect.Value) (good bool) {
-        switch n.kind {
-        case documentNode:
-                return d.document(n, out)
-        case aliasNode:
-                return d.alias(n, out)
-        }
-        out, unmarshaled, good := d.prepare(n, out)
-        if unmarshaled {
-                return good
-        }
-        switch n.kind {
-        case scalarNode:
-                good = d.scalar(n, out)
-        case mappingNode:
-                good = d.mapping(n, out)
-        case sequenceNode:
-                good = d.sequence(n, out)
-        default:
-                panic("internal error: unknown node kind: " + strconv.Itoa(n.kind))
-        }
-        return good
-}
-
-func (d *decoder) document(n *node, out reflect.Value) (good bool) {
-        if len(n.children) == 1 {
-                d.doc = n
-                d.unmarshal(n.children[0], out)
-                return true
-        }
-        return false
-}
-
-func (d *decoder) alias(n *node, out reflect.Value) (good bool) {
-        an, ok := d.doc.anchors[n.value]
-        if !ok {
-                failf("unknown anchor '%s' referenced", n.value)
-        }
-        if d.aliases[n.value] {
-                failf("anchor '%s' value contains itself", n.value)
-        }
-        d.aliases[n.value] = true
-        good = d.unmarshal(an, out)
-        delete(d.aliases, n.value)
-        return good
-}
-
-var zeroValue reflect.Value
-
-func resetMap(out reflect.Value) {
-        for _, k := range out.MapKeys() {
-                out.SetMapIndex(k, zeroValue)
-        }
-}
-
-func (d *decoder) scalar(n *node, out reflect.Value) (good bool) {
-        var tag string
-        var resolved interface{}
-        if n.tag == "" && !n.implicit {
-                tag = yaml_STR_TAG
-                resolved = n.value
-        } else {
-                tag, resolved = resolve(n.tag, n.value)
-                if tag == yaml_BINARY_TAG {
-                        data, err := base64.StdEncoding.DecodeString(resolved.(string))
-                        if err != nil {
-                                failf("!!binary value contains invalid base64 data")
-                        }
-                        resolved = string(data)
-                }
-        }
-        if resolved == nil {
-                if out.Kind() == reflect.Map && !out.CanAddr() {
-                        resetMap(out)
-                } else {
-                        out.Set(reflect.Zero(out.Type()))
-                }
-                return true
-        }
-        if s, ok := resolved.(string); ok && out.CanAddr() {
-                if u, ok := out.Addr().Interface().(encoding.TextUnmarshaler); ok {
-                        err := u.UnmarshalText([]byte(s))
-                        if err != nil {
-                                fail(err)
-                        }
-                        return true
-                }
-        }
-        switch out.Kind() {
-        case reflect.String:
-                if tag == yaml_BINARY_TAG {
-                        out.SetString(resolved.(string))
-                        good = true
-                } else if resolved != nil {
-                        out.SetString(n.value)
-                        good = true
-                }
-        case reflect.Interface:
-                if resolved == nil {
-                        out.Set(reflect.Zero(out.Type()))
-                } else {
-                        out.Set(reflect.ValueOf(resolved))
-                }
-                good = true
-        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
-                switch resolved := resolved.(type) {
-                case int:
-                        if !out.OverflowInt(int64(resolved)) {
-                                out.SetInt(int64(resolved))
-                                good = true
-                        }
-                case int64:
-                        if !out.OverflowInt(resolved) {
-                                out.SetInt(resolved)
-                                good = true
-                        }
-                case uint64:
-                        if resolved <= math.MaxInt64 && !out.OverflowInt(int64(resolved)) {
-                                out.SetInt(int64(resolved))
-                                good = true
-                        }
-                case float64:
-                        if resolved <= math.MaxInt64 && !out.OverflowInt(int64(resolved)) {
-                                out.SetInt(int64(resolved))
-                                good = true
-                        }
-                case string:
-                        if out.Type() == durationType {
-                                d, err := time.ParseDuration(resolved)
-                                if err == nil {
-                                        out.SetInt(int64(d))
-                                        good = true
-                                }
-                        }
-                }
-        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
-                switch resolved := resolved.(type) {
-                case int:
-                        if resolved >= 0 && !out.OverflowUint(uint64(resolved)) {
-                                out.SetUint(uint64(resolved))
-                                good = true
-                        }
-                case int64:
-                        if resolved >= 0 && !out.OverflowUint(uint64(resolved)) {
-                                out.SetUint(uint64(resolved))
-                                good = true
-                        }
-                case uint64:
-                        if !out.OverflowUint(uint64(resolved)) {
-                                out.SetUint(uint64(resolved))
-                                good = true
-                        }
-                case float64:
-                        if resolved <= math.MaxUint64 && !out.OverflowUint(uint64(resolved)) {
-                                out.SetUint(uint64(resolved))
-                                good = true
-                        }
-                }
-        case reflect.Bool:
-                switch resolved := resolved.(type) {
-                case bool:
-                        out.SetBool(resolved)
-                        good = true
-                }
-        case reflect.Float32, reflect.Float64:
-                switch resolved := resolved.(type) {
-                case int:
-                        out.SetFloat(float64(resolved))
-                        good = true
-                case int64:
-                        out.SetFloat(float64(resolved))
-                        good = true
-                case uint64:
-                        out.SetFloat(float64(resolved))
-                        good = true
-                case float64:
-                        out.SetFloat(resolved)
-                        good = true
-                }
-        case reflect.Ptr:
-                if out.Type().Elem() == reflect.TypeOf(resolved) {
-                        // TODO DOes this make sense? When is out a Ptr except when decoding a nil value?
-                        elem := reflect.New(out.Type().Elem())
-                        elem.Elem().Set(reflect.ValueOf(resolved))
-                        out.Set(elem)
-                        good = true
-                }
-        }
-        if !good {
-                d.terror(n, tag, out)
-        }
-        return good
-}
-
-func settableValueOf(i interface{}) reflect.Value {
-        v := reflect.ValueOf(i)
-        sv := reflect.New(v.Type()).Elem()
-        sv.Set(v)
-        return sv
-}
-
-func (d *decoder) sequence(n *node, out reflect.Value) (good bool) {
-        var iface reflect.Value
-        switch out.Kind() {
-        case reflect.Slice:
-                // okay
-        case reflect.Interface:
-                // No type hints. Will have to use a generic sequence.
-                iface = out
-                out = settableValueOf(make([]interface{}, 0))
-        default:
-                d.terror(n, yaml_SEQ_TAG, out)
-                return false
-        }
-        et := out.Type().Elem()
-
-        l := len(n.children)
-        for i := 0; i < l; i++ {
-                e := reflect.New(et).Elem()
-                if ok := d.unmarshal(n.children[i], e); ok {
-                        out.Set(reflect.Append(out, e))
-                }
-        }
-        if iface.IsValid() {
-                iface.Set(out)
-        }
-        return true
-}
-
-
-
-func (d *decoder) mapping(n *node, out reflect.Value) (good bool) {
-        switch out.Kind() {
-        case reflect.Struct:
-                return d.mappingStruct(n, out)
-        case reflect.Slice:
-                return d.mappingSlice(n, out)
-        case reflect.Map:
-                // okay
-        case reflect.Interface:
-                if d.mapType.Kind() == reflect.Map {
-                        iface := out
-                        out = reflect.MakeMap(d.mapType)
-                        iface.Set(out)
-                } else {
-                        slicev := reflect.New(d.mapType).Elem()
-                        if !d.mappingSlice(n, slicev) {
-                                return false
-                        }
-                        out.Set(slicev)
-                        return true
-                }
-        default:
-                d.terror(n, yaml_MAP_TAG, out)
-                return false
-        }
-        outt := out.Type()
-        kt := outt.Key()
-        et := outt.Elem()
-
-        mapType := d.mapType
-        if outt.Key() == ifaceType && outt.Elem() == ifaceType {
-                d.mapType = outt
-        }
-
-        if out.IsNil() {
-                out.Set(reflect.MakeMap(outt))
-        }
-        l := len(n.children)
-        for i := 0; i < l; i += 2 {
-                if isMerge(n.children[i]) {
-                        d.merge(n.children[i+1], out)
-                        continue
-                }
-                k := reflect.New(kt).Elem()
-                if d.unmarshal(n.children[i], k) {
-                        kkind := k.Kind()
-                        if kkind == reflect.Interface {
-                                kkind = k.Elem().Kind()
-                        }
-                        if kkind == reflect.Map || kkind == reflect.Slice {
-                                failf("invalid map key: %#v", k.Interface())
-                        }
-                        e := reflect.New(et).Elem()
-                        if d.unmarshal(n.children[i+1], e) {
-                                out.SetMapIndex(k, e)
-                        }
-                }
-        }
-        d.mapType = mapType
-        return true
-}
-
-func (d *decoder) mappingSlice(n *node, out reflect.Value) (good bool) {
-        outt := out.Type()
-        if outt.Elem() != mapItemType {
-                d.terror(n, yaml_MAP_TAG, out)
-                return false
-        }
-
-        mapType := d.mapType
-        d.mapType = outt
-
-        var slice []MapItem
-        var l = len(n.children)
-        for i := 0; i < l; i += 2 {
-                if isMerge(n.children[i]) {
-                        d.merge(n.children[i+1], out)
-                        continue
-                }
-                item := MapItem{}
-                k := reflect.ValueOf(&item.Key).Elem()
-                if d.unmarshal(n.children[i], k) {
-                        v := reflect.ValueOf(&item.Value).Elem()
-                        if d.unmarshal(n.children[i+1], v) {
-                                slice = append(slice, item)
-                        }
-                }
-        }
-        out.Set(reflect.ValueOf(slice))
-        d.mapType = mapType
-        return true
-}
-
-func (d *decoder) mappingStruct(n *node, out reflect.Value) (good bool) {
-        sinfo, err := getStructInfo(out.Type())
-        if err != nil {
-                panic(err)
-        }
-        name := settableValueOf("")
-        l := len(n.children)
-        for i := 0; i < l; i += 2 {
-                ni := n.children[i]
-                if isMerge(ni) {
-                        d.merge(n.children[i+1], out)
-                        continue
-                }
-                if !d.unmarshal(ni, name) {
-                        continue
-                }
-                if info, ok := sinfo.FieldsMap[name.String()]; ok {
-                        var field reflect.Value
-                        if info.Inline == nil {
-                                field = out.Field(info.Num)
-                        } else {
-                                field = out.FieldByIndex(info.Inline)
-                        }
-                        d.unmarshal(n.children[i+1], field)
-                }
-        }
-        return true
-}
-
-func failWantMap() {
-        failf("map merge requires map or sequence of maps as the value")
-}
-
-func (d *decoder) merge(n *node, out reflect.Value) {
-        switch n.kind {
-        case mappingNode:
-                d.unmarshal(n, out)
-        case aliasNode:
-                an, ok := d.doc.anchors[n.value]
-                if ok && an.kind != mappingNode {
-                        failWantMap()
-                }
-                d.unmarshal(n, out)
-        case sequenceNode:
-                // Step backwards as earlier nodes take precedence.
-                for i := len(n.children) - 1; i >= 0; i-- {
-                        ni := n.children[i]
-                        if ni.kind == aliasNode {
-                                an, ok := d.doc.anchors[ni.value]
-                                if ok && an.kind != mappingNode {
-                                        failWantMap()
-                                }
-                        } else if ni.kind != mappingNode {
-                                failWantMap()
-                        }
-                        d.unmarshal(ni, out)
-                }
-        default:
-                failWantMap()
-        }
-}
-
-func isMerge(n *node) bool {
-        return n.kind == scalarNode && n.value == "<<" && (n.implicit == true || n.tag == yaml_MERGE_TAG)
-}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/decode_test.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/decode_test.go
deleted file mode 100644
index d630094..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/decode_test.go
+++ /dev/null
@@ -1,902 +0,0 @@
-package yaml_test
-
-import (
-        "errors"
-        . "gopkg.in/check.v1"
-        "github.com/stevenjack/cig/Godeps/_workspace/src/gopkg.in/yaml.v2"
-        "math"
-        "net"
-        "reflect"
-        "strings"
-        "time"
-)
-
-var unmarshalIntTest = 123
-
-var unmarshalTests = []struct {
-        data  string
-        value interface{}
-}{
-        {
-                "",
-                &struct{}{},
-        }, {
-                "{}", &struct{}{},
-        }, {
-                "v: hi",
-                map[string]string{"v": "hi"},
-        }, {
-                "v: hi", map[string]interface{}{"v": "hi"},
-        }, {
-                "v: true",
-                map[string]string{"v": "true"},
-        }, {
-                "v: true",
-                map[string]interface{}{"v": true},
-        }, {
-                "v: 10",
-                map[string]interface{}{"v": 10},
-        }, {
-                "v: 0b10",
-                map[string]interface{}{"v": 2},
-        }, {
-                "v: 0xA",
-                map[string]interface{}{"v": 10},
-        }, {
-                "v: 4294967296",
-                map[string]int64{"v": 4294967296},
-        }, {
-                "v: 0.1",
-                map[string]interface{}{"v": 0.1},
-        }, {
-                "v: .1",
-                map[string]interface{}{"v": 0.1},
-        }, {
-                "v: .Inf",
-                map[string]interface{}{"v": math.Inf(+1)},
-        }, {
-                "v: -.Inf",
-                map[string]interface{}{"v": math.Inf(-1)},
-        }, {
-                "v: -10",
-                map[string]interface{}{"v": -10},
-        }, {
-                "v: -.1",
-                map[string]interface{}{"v": -0.1},
-        },
-
-        // Simple values.
-        {
-                "123",
-                &unmarshalIntTest,
-        },
-
-        // Floats from spec
-        {
-                "canonical: 6.8523e+5",
-                map[string]interface{}{"canonical": 6.8523e+5},
-        }, {
-                "expo: 685.230_15e+03",
-                map[string]interface{}{"expo": 685.23015e+03},
-        }, {
-                "fixed: 685_230.15",
-                map[string]interface{}{"fixed": 685230.15},
-        }, {
-                "neginf: -.inf",
-                map[string]interface{}{"neginf": math.Inf(-1)},
-        }, {
-                "fixed: 685_230.15",
-                map[string]float64{"fixed": 685230.15},
-        },
-        //{"sexa: 190:20:30.15", map[string]interface{}{"sexa": 0}}, // Unsupported
-        //{"notanum: .NaN", map[string]interface{}{"notanum": math.NaN()}}, // Equality of NaN fails.
-
-        // Bools from spec
-        {
-                "canonical: y",
-                map[string]interface{}{"canonical": true},
-        }, {
-                "answer: NO",
-                map[string]interface{}{"answer": false},
-        }, {
-                "logical: True",
-                map[string]interface{}{"logical": true},
-        }, {
-                "option: on",
-                map[string]interface{}{"option": true},
-        }, {
-                "option: on",
-                map[string]bool{"option": true},
-        },
-        // Ints from spec
-        {
-                "canonical: 685230",
-                map[string]interface{}{"canonical": 685230},
-        }, {
-                "decimal: +685_230",
-                map[string]interface{}{"decimal": 685230},
-        }, {
-                "octal: 02472256",
-                map[string]interface{}{"octal": 685230},
-        }, {
-                "hexa: 0x_0A_74_AE",
-                map[string]interface{}{"hexa": 685230},
-        }, {
-                "bin: 0b1010_0111_0100_1010_1110",
-                map[string]interface{}{"bin": 685230},
-        }, {
-                "bin: -0b101010",
-                map[string]interface{}{"bin": -42},
-        }, {
-                "decimal: +685_230",
-                map[string]int{"decimal": 685230},
-        },
-
-        //{"sexa: 190:20:30", map[string]interface{}{"sexa": 0}}, // Unsupported
-
-        // Nulls from spec
-        {
-                "empty:",
-                map[string]interface{}{"empty": nil},
-        }, {
-                "canonical: ~",
-                map[string]interface{}{"canonical": nil},
-        }, {
-                "english: null",
-                map[string]interface{}{"english": nil},
-        }, {
-                "~: null key",
-                map[interface{}]string{nil: "null key"},
-        }, {
-                "empty:",
-                map[string]*bool{"empty": nil},
-        },
-
-        // Flow sequence
-        {
-                "seq: [A,B]",
-                map[string]interface{}{"seq": []interface{}{"A", "B"}},
-        }, {
-                "seq: [A,B,C,]",
-                map[string][]string{"seq": []string{"A", "B", "C"}},
-        }, {
-                "seq: [A,1,C]",
-                map[string][]string{"seq": []string{"A", "1", "C"}},
-        }, {
-                "seq: [A,1,C]",
-                map[string][]int{"seq": []int{1}},
-        }, {
-                "seq: [A,1,C]",
-                map[string]interface{}{"seq": []interface{}{"A", 1, "C"}},
-        },
-        // Block sequence
-        {
-                "seq:\n - A\n - B",
-                map[string]interface{}{"seq": []interface{}{"A", "B"}},
-        }, {
-                "seq:\n - A\n - B\n - C",
-                map[string][]string{"seq": []string{"A", "B", "C"}},
-        }, {
-                "seq:\n - A\n - 1\n - C",
-                map[string][]string{"seq": []string{"A", "1", "C"}},
-        }, {
-                "seq:\n - A\n - 1\n - C",
-                map[string][]int{"seq": []int{1}},
-        }, {
-                "seq:\n - A\n - 1\n - C",
-                map[string]interface{}{"seq": []interface{}{"A", 1, "C"}},
-        },
-
-        // Literal block scalar
-        {
-                "scalar: | # Comment\n\n literal\n\n \ttext\n\n",
-                map[string]string{"scalar": "\nliteral\n\n\ttext\n"},
-        },
-
-        // Folded block scalar
-        {
-                "scalar: > # Comment\n\n folded\n line\n \n next\n line\n  * one\n  * two\n\n last\n line\n\n",
-                map[string]string{"scalar": "\nfolded line\nnext line\n * one\n * two\n\nlast line\n"},
-        },
-
-        // Map inside interface with no type hints.
-        {
-                "a: {b: c}",
-                map[interface{}]interface{}{"a": map[interface{}]interface{}{"b": "c"}},
-        },
-
-        // Structs and type conversions.
-        {
-                "hello: world",
-                &struct{ Hello string }{"world"},
-        }, {
-                "a: {b: c}",
-                &struct{ A struct{ B string } }{struct{ B string }{"c"}},
-        }, {
-                "a: {b: c}",
-                &struct{ A *struct{ B string } }{&struct{ B string }{"c"}},
-        }, {
-                "a: {b: c}",
-                &struct{ A map[string]string }{map[string]string{"b": "c"}},
-        }, {
-                "a: {b: c}",
-                &struct{ A *map[string]string }{&map[string]string{"b": "c"}},
-        }, {
-                "a:",
-                &struct{ A map[string]string }{},
-        }, {
-                "a: 1",
-                &struct{ A int }{1},
-        }, {
-                "a: 1",
-                &struct{ A float64 }{1},
-        }, {
-                "a: 1.0",
-                &struct{ A int }{1},
-        }, {
-                "a: 1.0",
-                &struct{ A uint }{1},
-        }, {
-                "a: [1, 2]",
-                &struct{ A []int }{[]int{1, 2}},
-        }, {
-                "a: 1",
-                &struct{ B int }{0},
-        }, {
-                "a: 1",
-                &struct {
-                        B int "a"
-                }{1},
-        }, {
-                "a: y",
-                &struct{ A bool }{true},
-        },
-
-        // Some cross type conversions
-        {
-                "v: 42",
-                map[string]uint{"v": 42},
-        }, {
-                "v: -42",
-                map[string]uint{},
-        }, {
-                "v: 4294967296",
-                map[string]uint64{"v": 4294967296},
-        }, {
-                "v: -4294967296",
-                map[string]uint64{},
-        },
-
-        // int
-        {
-                "int_max: 2147483647",
-                map[string]int{"int_max": math.MaxInt32},
-        },
-        {
-                "int_min: -2147483648",
-                map[string]int{"int_min": math.MinInt32},
-        },
-        {
-                "int_overflow: 9223372036854775808", // math.MaxInt64 + 1
-                map[string]int{},
-        },
-
-        // int64
-        {
-                "int64_max: 9223372036854775807",
-                map[string]int64{"int64_max": math.MaxInt64},
-        },
-        {
-                "int64_max_base2: 0b111111111111111111111111111111111111111111111111111111111111111",
-                map[string]int64{"int64_max_base2": math.MaxInt64},
-        },
-        {
-                "int64_min: -9223372036854775808",
-                map[string]int64{"int64_min": math.MinInt64},
-        },
-        {
-                "int64_neg_base2: -0b111111111111111111111111111111111111111111111111111111111111111",
-                map[string]int64{"int64_neg_base2": -math.MaxInt64},
-        },
-        {
-                "int64_overflow: 9223372036854775808", // math.MaxInt64 + 1
-                map[string]int64{},
-        },
-
-        // uint
-        {
-                "uint_min: 0",
-                map[string]uint{"uint_min": 0},
-        },
-        {
-                "uint_max: 4294967295",
-                map[string]uint{"uint_max": math.MaxUint32},
-        },
-        {
-                "uint_underflow: -1",
-                map[string]uint{},
-        },
-
-        // uint64
-        {
-                "uint64_min: 0",
-                map[string]uint{"uint64_min": 0},
-        },
-        {
-                "uint64_max: 18446744073709551615",
-                map[string]uint64{"uint64_max": math.MaxUint64},
-        },
-        {
-                "uint64_max_base2: 0b1111111111111111111111111111111111111111111111111111111111111111",
-                map[string]uint64{"uint64_max_base2": math.MaxUint64},
-        },
-        {
-                "uint64_maxint64: 9223372036854775807",
-                map[string]uint64{"uint64_maxint64": math.MaxInt64},
-        },
-        {
-                "uint64_underflow: -1",
-                map[string]uint64{},
-        },
-
-        // float32
-        {
-                "float32_max: 3.40282346638528859811704183484516925440e+38",
-                map[string]float32{"float32_max": math.MaxFloat32},
-        },
-        {
-                "float32_nonzero: 1.401298464324817070923729583289916131280e-45",
-                map[string]float32{"float32_nonzero": math.SmallestNonzeroFloat32},
-        },
-        {
-                "float32_maxuint64: 18446744073709551615",
-                map[string]float32{"float32_maxuint64": float32(math.MaxUint64)},
-        },
-        {
-                "float32_maxuint64+1: 18446744073709551616",
-                map[string]float32{"float32_maxuint64+1": float32(math.MaxUint64 + 1)},
-        },
-
-        // float64
-        {
-                "float64_max: 1.797693134862315708145274237317043567981e+308",
-                map[string]float64{"float64_max": math.MaxFloat64},
-        },
-        {
-                "float64_nonzero: 4.940656458412465441765687928682213723651e-324",
-                map[string]float64{"float64_nonzero": math.SmallestNonzeroFloat64},
-        },
-        {
-                "float64_maxuint64: 18446744073709551615",
-                map[string]float64{"float64_maxuint64": float64(math.MaxUint64)},
-        },
-        {
-                "float64_maxuint64+1: 18446744073709551616",
-                map[string]float64{"float64_maxuint64+1": float64(math.MaxUint64 + 1)},
-        },
-
-        // Overflow cases.
-        {
-                "v: 4294967297",
-                map[string]int32{},
-        }, {
-                "v: 128",
-                map[string]int8{},
-        },
-
-        // Quoted values.
-        {
-                "'1': '\"2\"'",
-                map[interface{}]interface{}{"1": "\"2\""},
-        }, {
-                "v:\n- A\n- 'B\n\n  C'\n",
-                map[string][]string{"v": []string{"A", "B\nC"}},
-        },
-
-        // Explicit tags.
-        {
-                "v: !!float '1.1'",
-                map[string]interface{}{"v": 1.1},
-        }, {
-                "v: !!null ''",
-                map[string]interface{}{"v": nil},
-        }, {
-                "%TAG !y! tag:yaml.org,2002:\n---\nv: !y!int '1'",
-                map[string]interface{}{"v": 1},
-        },
-
-        // Anchors and aliases.
-        {
-                "a: &x 1\nb: &y 2\nc: *x\nd: *y\n",
-                &struct{ A, B, C, D int }{1, 2, 1, 2},
-        }, {
-                "a: &a {c: 1}\nb: *a",
-                &struct {
-                        A, B struct {
-                                C int
-                        }
-                }{struct{ C int }{1}, struct{ C int }{1}},
-        }, {
-                "a: &a [1, 2]\nb: *a",
-                &struct{ B []int }{[]int{1, 2}},
-        },
-
-        // Bug #1133337
-        {
-                "foo: ''",
-                map[string]*string{"foo": new(string)},
-        }, {
-                "foo: null",
-                map[string]string{"foo": ""},
-        }, {
-                "foo: null",
-                map[string]interface{}{"foo": nil},
-        },
-
-        // Ignored field
-        {
-                "a: 1\nb: 2\n",
-                &struct {
-                        A int
-                        B int "-"
-                }{1, 0},
-        },
-
-        // Bug #1191981
-        {
-                "" +
-                        "%YAML 1.1\n" +
-                        "--- !!str\n" +
-                        `"Generic line break (no glyph)\n\` + "\n" +
-                        ` Generic line break (glyphed)\n\` + "\n" +
-                        ` Line separator\u2028\` + "\n" +
-                        ` Paragraph separator\u2029"` + "\n",
-                "" +
-                        "Generic line break (no glyph)\n" +
-                        "Generic line break (glyphed)\n" +
-                        "Line separator\u2028Paragraph separator\u2029",
-        },
-
-        // Struct inlining
-        {
-                "a: 1\nb: 2\nc: 3\n",
-                &struct {
-                        A int
-                        C inlineB `yaml:",inline"`
-                }{1, inlineB{2, inlineC{3}}},
-        },
-
-        // bug 1243827
-        {
-                "a: -b_c",
-                map[string]interface{}{"a": "-b_c"},
-        },
-        {
-                "a: +b_c",
-                map[string]interface{}{"a": "+b_c"},
-        },
-        {
-                "a: 50cent_of_dollar",
-                map[string]interface{}{"a": "50cent_of_dollar"},
-        },
-
-        // Duration
-        {
-                "a: 3s",
-                map[string]time.Duration{"a": 3 * time.Second},
-        },
-
-        // Issue #24.
-        {
-                "a: <foo>",
-                map[string]string{"a": "<foo>"},
-        },
-
-        // Base 60 floats are obsolete and unsupported.
-        {
-                "a: 1:1\n",
-                map[string]string{"a": "1:1"},
-        },
-
-        // Binary data.
-        {
-                "a: !!binary gIGC\n",
-                map[string]string{"a": "\x80\x81\x82"},
-        }, {
-                "a: !!binary |\n  " + strings.Repeat("kJCQ", 17) + "kJ\n  CQ\n",
-                map[string]string{"a": strings.Repeat("\x90", 54)},
-        }, {
-                "a: !!binary |\n  " + strings.Repeat("A", 70) + "\n  ==\n",
-                map[string]string{"a": strings.Repeat("\x00", 52)},
-        },
-
-        // Ordered maps.
-        {
-                "{b: 2, a: 1, d: 4, c: 3, sub: {e: 5}}",
-                &yaml.MapSlice{{"b", 2}, {"a", 1}, {"d", 4}, {"c", 3}, {"sub", yaml.MapSlice{{"e", 5}}}},
-        },
-
-        // Issue #39.
-        {
-                "a:\n b:\n  c: d\n",
-                map[string]struct{ B interface{} }{"a": {map[interface{}]interface{}{"c": "d"}}},
-        },
-
-        // Custom map type.
-        {
-                "a: {b: c}",
-                M{"a": M{"b": "c"}},
-        },
-
-        // Support encoding.TextUnmarshaler.
-        {
-                "a: 1.2.3.4\n",
-                map[string]net.IP{"a": net.IPv4(1, 2, 3, 4)},
-        },
-}
-
-type M map[interface{}]interface{}
-
-type inlineB struct {
-        B       int
-        inlineC `yaml:",inline"`
-}
-
-type inlineC struct {
-        C int
-}
-
-func (s *S) TestUnmarshal(c *C) {
-        for _, item := range unmarshalTests {
-                t := reflect.ValueOf(item.value).Type()
-                var value interface{}
-                switch t.Kind() {
-                case reflect.Map:
-                        value = reflect.MakeMap(t).Interface()
-                case reflect.String:
-                        value = reflect.New(t).Interface()
-                case reflect.Ptr:
-                        value = reflect.New(t.Elem()).Interface()
-                default:
-                        c.Fatalf("missing case for %s", t)
-                }
-                err := yaml.Unmarshal([]byte(item.data), value)
-                if _, ok := err.(*yaml.TypeError); !ok {
-                        c.Assert(err, IsNil)
-                }
-                if t.Kind() == reflect.String {
-                        c.Assert(*value.(*string), Equals, item.value)
-                } else {
-                        c.Assert(value, DeepEquals, item.value)
-                }
-        }
-}
-
-func (s *S) TestUnmarshalNaN(c *C) {
-        value := map[string]interface{}{}
-        err := yaml.Unmarshal([]byte("notanum: .NaN"), &value)
-        c.Assert(err, IsNil)
-        c.Assert(math.IsNaN(value["notanum"].(float64)), Equals, true)
-}
-
-var unmarshalErrorTests = []struct {
-        data, error string
-}{
-        {"v: !!float 'error'", "yaml: cannot decode !!str `error` as a !!float"},
-        {"v: [A,", "yaml: line 1: did not find expected node content"},
-        {"v:\n- [A,", "yaml: line 2: did not find expected node content"},
-        {"a: *b\n", "yaml: unknown anchor 'b' referenced"},
-        {"a: &a\n  b: *a\n", "yaml: anchor 'a' value contains itself"},
-        {"value: -", "yaml: block sequence entries are not allowed in this context"},
-        {"a: !!binary ==", "yaml: !!binary value contains invalid base64 data"},
-        {"{[.]}", `yaml: invalid map key: \[\]interface \{\}\{"\."\}`},
-        {"{{.}}", `yaml: invalid map key: map\[interface\ \{\}\]interface \{\}\{".":interface \{\}\(nil\)\}`},
-}
-
-func (s *S) TestUnmarshalErrors(c *C) {
-        for _, item := range unmarshalErrorTests {
-                var value interface{}
-                err := yaml.Unmarshal([]byte(item.data), &value)
-                c.Assert(err, ErrorMatches, item.error, Commentf("Partial unmarshal: %#v", value))
-        }
-}
-
-var unmarshalerTests = []struct {
-        data, tag string
-        value     interface{}
-}{
-        {"_: {hi: there}", "!!map", map[interface{}]interface{}{"hi": "there"}},
-        {"_: [1,A]", "!!seq", []interface{}{1, "A"}},
-        {"_: 10", "!!int", 10},
-        {"_: null", "!!null", nil},
-        {`_: BAR!`, "!!str", "BAR!"},
-        {`_: "BAR!"`, "!!str", "BAR!"},
-        {"_: !!foo 'BAR!'", "!!foo", "BAR!"},
-}
-
-var unmarshalerResult = map[int]error{}
-
-type unmarshalerType struct {
-        value interface{}
-}
-
-func (o *unmarshalerType) UnmarshalYAML(unmarshal func(v interface{}) error) error {
-        if err := unmarshal(&o.value); err != nil {
-                return err
-        }
-        if i, ok := o.value.(int); ok {
-                if result, ok := unmarshalerResult[i]; ok {
-                        return result
-                }
-        }
-        return nil
-}
-
-type unmarshalerPointer struct {
-        Field *unmarshalerType "_"
-}
-
-type unmarshalerValue struct {
-        Field unmarshalerType "_"
-}
-
-func (s *S) TestUnmarshalerPointerField(c *C) {
-        for _, item := range unmarshalerTests {
-                obj := &unmarshalerPointer{}
-                err := yaml.Unmarshal([]byte(item.data), obj)
-                c.Assert(err, IsNil)
-                if item.value == nil {
-                        c.Assert(obj.Field, IsNil)
-                } else {
-                        c.Assert(obj.Field, NotNil, Commentf("Pointer not initialized (%#v)", item.value))
-                        c.Assert(obj.Field.value, DeepEquals, item.value)
-                }
-        }
-}
-
-func (s *S) TestUnmarshalerValueField(c *C) {
-        for _, item := range unmarshalerTests {
-                obj := &unmarshalerValue{}
-                err := yaml.Unmarshal([]byte(item.data), obj)
-                c.Assert(err, IsNil)
-                c.Assert(obj.Field, NotNil, Commentf("Pointer not initialized (%#v)", item.value))
-                c.Assert(obj.Field.value, DeepEquals, item.value)
-        }
-}
-
-func (s *S) TestUnmarshalerWholeDocument(c *C) {
-        obj := &unmarshalerType{}
-        err := yaml.Unmarshal([]byte(unmarshalerTests[0].data), obj)
-        c.Assert(err, IsNil)
-        value, ok := obj.value.(map[interface{}]interface{})
-        c.Assert(ok, Equals, true, Commentf("value: %#v", obj.value))
-        c.Assert(value["_"], DeepEquals, unmarshalerTests[0].value)
-}
-
-func (s *S) TestUnmarshalerTypeError(c *C) {
-        unmarshalerResult[2] = &yaml.TypeError{[]string{"foo"}}
-        unmarshalerResult[4] = &yaml.TypeError{[]string{"bar"}}
-        defer func() {
-                delete(unmarshalerResult, 2)
-                delete(unmarshalerResult, 4)
-        }()
-
-        type T struct {
-                Before int
-                After  int
-                M      map[string]*unmarshalerType
-        }
-        var v T
-        data := `{before: A, m: {abc: 1, def: 2, ghi: 3, jkl: 4}, after: B}`
-        err := yaml.Unmarshal([]byte(data), &v)
-        c.Assert(err, ErrorMatches, ""+
-                "yaml: unmarshal errors:\n"+
-                "  line 1: cannot unmarshal !!str `A` into int\n"+
-                "  foo\n"+
-                "  bar\n"+
-                "  line 1: cannot unmarshal !!str `B` into int")
-        c.Assert(v.M["abc"], NotNil)
-        c.Assert(v.M["def"], IsNil)
-        c.Assert(v.M["ghi"], NotNil)
-        c.Assert(v.M["jkl"], IsNil)
-
-        c.Assert(v.M["abc"].value, Equals, 1)
-        c.Assert(v.M["ghi"].value, Equals, 3)
-}
-
-type proxyTypeError struct{}
-
-func (v *proxyTypeError) UnmarshalYAML(unmarshal func(interface{}) error) error {
-        var s string
-        var a int32
-        var b int64
-        if err := unmarshal(&s); err != nil {
-                panic(err)
-        }
-        if s == "a" {
-                if err := unmarshal(&b); err == nil {
-                        panic("should have failed")
-                }
-                return unmarshal(&a)
-        }
-        if err := unmarshal(&a); err == nil {
-                panic("should have failed")
-        }
-        return unmarshal(&b)
-}
-
-func (s *S) TestUnmarshalerTypeErrorProxying(c *C) {
-        type T struct {
-                Before int
-                After  int
-                M      map[string]*proxyTypeError
-        }
-        var v T
-        data := `{before: A, m: {abc: a, def: b}, after: B}`
-        err := yaml.Unmarshal([]byte(data), &v)
-        c.Assert(err, ErrorMatches, ""+
-                "yaml: unmarshal errors:\n"+
-                "  line 1: cannot unmarshal !!str `A` into int\n"+
-                "  line 1: cannot unmarshal !!str `a` into int32\n"+
-                "  line 1: cannot unmarshal !!str `b` into int64\n"+
-                "  line 1: cannot unmarshal !!str `B` into int")
-}
-
-type failingUnmarshaler struct{}
-
-var failingErr = errors.New("failingErr")
-
-func (ft *failingUnmarshaler) UnmarshalYAML(unmarshal func(interface{}) error) error {
-        return failingErr
-}
-
-func (s *S) TestUnmarshalerError(c *C) {
-        err := yaml.Unmarshal([]byte("a: b"), &failingUnmarshaler{})
-        c.Assert(err, Equals, failingErr)
-}
-
-// From http://yaml.org/type/merge.html
-var mergeTests = `
-anchors:
-  list:
-    - &CENTER { "x": 1, "y": 2 }
-    - &LEFT   { "x": 0, "y": 2 }
-    - &BIG    { "r": 10 }
-    - &SMALL  { "r": 1 }
-
-# All the following maps are equal:
-
-plain:
-  # Explicit keys
-  "x": 1
-  "y": 2
-  "r": 10
-  label: center/big
-
-mergeOne:
-  # Merge one map
-  << : *CENTER
-  "r": 10
-  label: center/big
-
-mergeMultiple:
-  # Merge multiple maps
-  << : [ *CENTER, *BIG ]
-  label: center/big
-
-override:
-  # Override
-  << : [ *BIG, *LEFT, *SMALL ]
-  "x": 1
-  label: center/big
-
-shortTag:
-  # Explicit short merge tag
-  !!merge "<<" : [ *CENTER, *BIG ]
-  label: center/big
-
-longTag:
-  # Explicit merge long tag
-  !<tag:yaml.org,2002:merge> "<<" : [ *CENTER, *BIG ]
-  label: center/big
-
-inlineMap:
-  # Inlined map
-  << : {"x": 1, "y": 2, "r": 10}
-  label: center/big
-
-inlineSequenceMap:
-  # Inlined map in sequence
-  << : [ *CENTER, {"r": 10} ]
-  label: center/big
-`
-
-func (s *S) TestMerge(c *C) {
-        var want = map[interface{}]interface{}{
-                "x":     1,
-                "y":     2,
-                "r":     10,
-                "label": "center/big",
-        }
-
-        var m map[interface{}]interface{}
-        err := yaml.Unmarshal([]byte(mergeTests), &m)
-        c.Assert(err, IsNil)
-        for name, test := range m {
-                if name == "anchors" {
-                        continue
-                }
-                c.Assert(test, DeepEquals, want, Commentf("test %q failed", name))
-        }
-}
-
-func (s *S) TestMergeStruct(c *C) {
-        type Data struct {
-                X, Y, R int
-                Label   string
-        }
-        want := Data{1, 2, 10, "center/big"}
-
-        var m map[string]Data
-        err := yaml.Unmarshal([]byte(mergeTests), &m)
-        c.Assert(err, IsNil)
-        for name, test := range m {
-                if name == "anchors" {
-                        continue
-                }
-                c.Assert(test, Equals, want, Commentf("test %q failed", name))
-        }
-}
-
-var unmarshalNullTests = []func() interface{}{
-        func() interface{} { var v interface{}; v = "v"; return &v },
-        func() interface{} { var s = "s"; return &s },
-        func() interface{} { var s = "s"; sptr := &s; return &sptr },
-        func() interface{} { var i = 1; return &i },
-        func() interface{} { var i = 1; iptr := &i; return &iptr },
-        func() interface{} { m := map[string]int{"s": 1}; return &m },
-        func() interface{} { m := map[string]int{"s": 1}; return m },
-}
-
-func (s *S) TestUnmarshalNull(c *C) {
-        for _, test := range unmarshalNullTests {
-                item := test()
-                zero := reflect.Zero(reflect.TypeOf(item).Elem()).Interface()
-                err := yaml.Unmarshal([]byte("null"), item)
-                c.Assert(err, IsNil)
-                if reflect.TypeOf(item).Kind() == reflect.Map {
-                        c.Assert(reflect.ValueOf(item).Interface(), DeepEquals, reflect.MakeMap(reflect.TypeOf(item)).Interface())
-                } else {
-                        c.Assert(reflect.ValueOf(item).Elem().Interface(), DeepEquals, zero)
-                }
-        }
-}
-
-//var data []byte
-//func init() {
-//	var err error
-//	data, err = ioutil.ReadFile("/tmp/file.yaml")
-//	if err != nil {
-//		panic(err)
-//	}
-//}
-//
-//func (s *S) BenchmarkUnmarshal(c *C) {
-//	var err error
-//	for i := 0; i < c.N; i++ {
-//		var v map[string]interface{}
-//		err = yaml.Unmarshal(data, &v)
-//	}
-//	if err != nil {
-//		panic(err)
-//	}
-//}
-//
-//func (s *S) BenchmarkMarshal(c *C) {
-//	var v map[string]interface{}
-//	yaml.Unmarshal(data, &v)
-//	c.ResetTimer()
-//	for i := 0; i < c.N; i++ {
-//		yaml.Marshal(&v)
-//	}
-//}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/emitterc.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/emitterc.go
deleted file mode 100644
index 9c37ba6..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/emitterc.go
+++ /dev/null
@@ -1,1685 +0,0 @@
-package yaml
-
-import (
-        "bytes"
-)
-
-// Flush the buffer if needed.
-func flush(emitter *yaml_emitter_t) bool {
-        if emitter.buffer_pos+5 >= len(emitter.buffer) {
-                return yaml_emitter_flush(emitter)
-        }
-        return true
-}
-
-// Put a character to the output buffer.
-func put(emitter *yaml_emitter_t, value byte) bool {
-        if emitter.buffer_pos+5 >= len(emitter.buffer) && !yaml_emitter_flush(emitter) {
-                return false
-        }
-        emitter.buffer[emitter.buffer_pos] = value
-        emitter.buffer_pos++
-        emitter.column++
-        return true
-}
-
-// Put a line break to the output buffer.
-func put_break(emitter *yaml_emitter_t) bool {
-        if emitter.buffer_pos+5 >= len(emitter.buffer) && !yaml_emitter_flush(emitter) {
-                return false
-        }
-        switch emitter.line_break {
-        case yaml_CR_BREAK:
-                emitter.buffer[emitter.buffer_pos] = '\r'
-                emitter.buffer_pos += 1
-        case yaml_LN_BREAK:
-                emitter.buffer[emitter.buffer_pos] = '\n'
-                emitter.buffer_pos += 1
-        case yaml_CRLN_BREAK:
-                emitter.buffer[emitter.buffer_pos+0] = '\r'
-                emitter.buffer[emitter.buffer_pos+1] = '\n'
-                emitter.buffer_pos += 2
-        default:
-                panic("unknown line break setting")
-        }
-        emitter.column = 0
-        emitter.line++
-        return true
-}
-
-// Copy a character from a string into buffer.
-func write(emitter *yaml_emitter_t, s []byte, i *int) bool {
-        if emitter.buffer_pos+5 >= len(emitter.buffer) && !yaml_emitter_flush(emitter) {
-                return false
-        }
-        p := emitter.buffer_pos
-        w := width(s[*i])
-        switch w {
-        case 4:
-                emitter.buffer[p+3] = s[*i+3]
-                fallthrough
-        case 3:
-                emitter.buffer[p+2] = s[*i+2]
-                fallthrough
-        case 2:
-                emitter.buffer[p+1] = s[*i+1]
-                fallthrough
-        case 1:
-                emitter.buffer[p+0] = s[*i+0]
-        default:
-                panic("unknown character width")
-        }
-        emitter.column++
-        emitter.buffer_pos += w
-        *i += w
-        return true
-}
-
-// Write a whole string into buffer.
-func write_all(emitter *yaml_emitter_t, s []byte) bool {
-        for i := 0; i < len(s); {
-                if !write(emitter, s, &i) {
-                        return false
-                }
-        }
-        return true
-}
-
-// Copy a line break character from a string into buffer.
-func write_break(emitter *yaml_emitter_t, s []byte, i *int) bool {
-        if s[*i] == '\n' {
-                if !put_break(emitter) {
-                        return false
-                }
-                *i++
-        } else {
-                if !write(emitter, s, i) {
-                        return false
-                }
-                emitter.column = 0
-                emitter.line++
-        }
-        return true
-}
-
-// Set an emitter error and return false.
-func yaml_emitter_set_emitter_error(emitter *yaml_emitter_t, problem string) bool {
-        emitter.error = yaml_EMITTER_ERROR
-        emitter.problem = problem
-        return false
-}
-
-// Emit an event.
-func yaml_emitter_emit(emitter *yaml_emitter_t, event *yaml_event_t) bool {
-        emitter.events = append(emitter.events, *event)
-        for !yaml_emitter_need_more_events(emitter) {
-                event := &emitter.events[emitter.events_head]
-                if !yaml_emitter_analyze_event(emitter, event) {
-                        return false
-                }
-                if !yaml_emitter_state_machine(emitter, event) {
-                        return false
-                }
-                yaml_event_delete(event)
-                emitter.events_head++
-        }
-        return true
-}
-
-// Check if we need to accumulate more events before emitting.
-//
-// We accumulate extra
-//  - 1 event for DOCUMENT-START
-//  - 2 events for SEQUENCE-START
-//  - 3 events for MAPPING-START
-//
-func yaml_emitter_need_more_events(emitter *yaml_emitter_t) bool {
-        if emitter.events_head == len(emitter.events) {
-                return true
-        }
-        var accumulate int
-        switch emitter.events[emitter.events_head].typ {
-        case yaml_DOCUMENT_START_EVENT:
-                accumulate = 1
-                break
-        case yaml_SEQUENCE_START_EVENT:
-                accumulate = 2
-                break
-        case yaml_MAPPING_START_EVENT:
-                accumulate = 3
-                break
-        default:
-                return false
-        }
-        if len(emitter.events)-emitter.events_head > accumulate {
-                return false
-        }
-        var level int
-        for i := emitter.events_head; i < len(emitter.events); i++ {
-                switch emitter.events[i].typ {
-                case yaml_STREAM_START_EVENT, yaml_DOCUMENT_START_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT:
-                        level++
-                case yaml_STREAM_END_EVENT, yaml_DOCUMENT_END_EVENT, yaml_SEQUENCE_END_EVENT, yaml_MAPPING_END_EVENT:
-                        level--
-                }
-                if level == 0 {
-                        return false
-                }
-        }
-        return true
-}
-
-// Append a directive to the directives stack.
-func yaml_emitter_append_tag_directive(emitter *yaml_emitter_t, value *yaml_tag_directive_t, allow_duplicates bool) bool {
-        for i := 0; i < len(emitter.tag_directives); i++ {
-                if bytes.Equal(value.handle, emitter.tag_directives[i].handle) {
-                        if allow_duplicates {
-                                return true
-                        }
-                        return yaml_emitter_set_emitter_error(emitter, "duplicate %TAG directive")
-                }
-        }
-
-        // [Go] Do we actually need to copy this given garbage collection
-        // and the lack of deallocating destructors?
-        tag_copy := yaml_tag_directive_t{
-                handle: make([]byte, len(value.handle)),
-                prefix: make([]byte, len(value.prefix)),
-        }
-        copy(tag_copy.handle, value.handle)
-        copy(tag_copy.prefix, value.prefix)
-        emitter.tag_directives = append(emitter.tag_directives, tag_copy)
-        return true
-}
-
-// Increase the indentation level.
-func yaml_emitter_increase_indent(emitter *yaml_emitter_t, flow, indentless bool) bool {
-        emitter.indents = append(emitter.indents, emitter.indent)
-        if emitter.indent < 0 {
-                if flow {
-                        emitter.indent = emitter.best_indent
-                } else {
-                        emitter.indent = 0
-                }
-        } else if !indentless {
-                emitter.indent += emitter.best_indent
-        }
-        return true
-}
-
-// State dispatcher.
-func yaml_emitter_state_machine(emitter *yaml_emitter_t, event *yaml_event_t) bool {
-        switch emitter.state {
-        default:
-        case yaml_EMIT_STREAM_START_STATE:
-                return yaml_emitter_emit_stream_start(emitter, event)
-
-        case yaml_EMIT_FIRST_DOCUMENT_START_STATE:
-                return yaml_emitter_emit_document_start(emitter, event, true)
-
-        case yaml_EMIT_DOCUMENT_START_STATE:
-                return yaml_emitter_emit_document_start(emitter, event, false)
-
-        case yaml_EMIT_DOCUMENT_CONTENT_STATE:
-                return yaml_emitter_emit_document_content(emitter, event)
-
-        case yaml_EMIT_DOCUMENT_END_STATE:
-                return yaml_emitter_emit_document_end(emitter, event)
-
-        case yaml_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE:
-                return yaml_emitter_emit_flow_sequence_item(emitter, event, true)
-
-        case yaml_EMIT_FLOW_SEQUENCE_ITEM_STATE:
-                return yaml_emitter_emit_flow_sequence_item(emitter, event, false)
-
-        case yaml_EMIT_FLOW_MAPPING_FIRST_KEY_STATE:
-                return yaml_emitter_emit_flow_mapping_key(emitter, event, true)
-
-        case yaml_EMIT_FLOW_MAPPING_KEY_STATE:
-                return yaml_emitter_emit_flow_mapping_key(emitter, event, false)
-
-        case yaml_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE:
-                return yaml_emitter_emit_flow_mapping_value(emitter, event, true)
-
-        case yaml_EMIT_FLOW_MAPPING_VALUE_STATE:
-                return yaml_emitter_emit_flow_mapping_value(emitter, event, false)
-
-        case yaml_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE:
-                return yaml_emitter_emit_block_sequence_item(emitter, event, true)
-
-        case yaml_EMIT_BLOCK_SEQUENCE_ITEM_STATE:
-                return yaml_emitter_emit_block_sequence_item(emitter, event, false)
-
-        case yaml_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE:
-                return yaml_emitter_emit_block_mapping_key(emitter, event, true)
-
-        case yaml_EMIT_BLOCK_MAPPING_KEY_STATE:
-                return yaml_emitter_emit_block_mapping_key(emitter, event, false)
-
-        case yaml_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE:
-                return yaml_emitter_emit_block_mapping_value(emitter, event, true)
-
-        case yaml_EMIT_BLOCK_MAPPING_VALUE_STATE:
-                return yaml_emitter_emit_block_mapping_value(emitter, event, false)
-
-        case yaml_EMIT_END_STATE:
-                return yaml_emitter_set_emitter_error(emitter, "expected nothing after STREAM-END")
-        }
-        panic("invalid emitter state")
-}
-
-// Expect STREAM-START.
-func yaml_emitter_emit_stream_start(emitter *yaml_emitter_t, event *yaml_event_t) bool {
-        if event.typ != yaml_STREAM_START_EVENT {
-                return yaml_emitter_set_emitter_error(emitter, "expected STREAM-START")
-        }
-        if emitter.encoding == yaml_ANY_ENCODING {
-                emitter.encoding = event.encoding
-                if emitter.encoding == yaml_ANY_ENCODING {
-                        emitter.encoding = yaml_UTF8_ENCODING
-                }
-        }
-        if emitter.best_indent < 2 || emitter.best_indent > 9 {
-                emitter.best_indent = 2
-        }
-        if emitter.best_width >= 0 && emitter.best_width <= emitter.best_indent*2 {
-                emitter.best_width = 80
-        }
-        if emitter.best_width < 0 {
-                emitter.best_width = 1<<31 - 1
-        }
-        if emitter.line_break == yaml_ANY_BREAK {
-                emitter.line_break = yaml_LN_BREAK
-        }
-
-        emitter.indent = -1
-        emitter.line = 0
-        emitter.column = 0
-        emitter.whitespace = true
-        emitter.indention = true
-
-        if emitter.encoding != yaml_UTF8_ENCODING {
-                if !yaml_emitter_write_bom(emitter) {
-                        return false
-                }
-        }
-        emitter.state = yaml_EMIT_FIRST_DOCUMENT_START_STATE
-        return true
-}
-
-// Expect DOCUMENT-START or STREAM-END.
-func yaml_emitter_emit_document_start(emitter *yaml_emitter_t, event *yaml_event_t, first bool) bool {
-
-        if event.typ == yaml_DOCUMENT_START_EVENT {
-
-                if event.version_directive != nil {
-                        if !yaml_emitter_analyze_version_directive(emitter, event.version_directive) {
-                                return false
-                        }
-                }
-
-                for i := 0; i < len(event.tag_directives); i++ {
-                        tag_directive := &event.tag_directives[i]
-                        if !yaml_emitter_analyze_tag_directive(emitter, tag_directive) {
-                                return false
-                        }
-                        if !yaml_emitter_append_tag_directive(emitter, tag_directive, false) {
-                                return false
-                        }
-                }
-
-                for i := 0; i < len(default_tag_directives); i++ {
-                        tag_directive := &default_tag_directives[i]
-                        if !yaml_emitter_append_tag_directive(emitter, tag_directive, true) {
-                                return false
-                        }
-                }
-
-                implicit := event.implicit
-                if !first || emitter.canonical {
-                        implicit = false
-                }
-
-                if emitter.open_ended && (event.version_directive != nil || len(event.tag_directives) > 0) {
-                        if !yaml_emitter_write_indicator(emitter, []byte("..."), true, false, false) {
-                                return false
-                        }
-                        if !yaml_emitter_write_indent(emitter) {
-                                return false
-                        }
-                }
-
-                if event.version_directive != nil {
-                        implicit = false
-                        if !yaml_emitter_write_indicator(emitter, []byte("%YAML"), true, false, false) {
-                                return false
-                        }
-                        if !yaml_emitter_write_indicator(emitter, []byte("1.1"), true, false, false) {
-                                return false
-                        }
-                        if !yaml_emitter_write_indent(emitter) {
-                                return false
-                        }
-                }
-
-                if len(event.tag_directives) > 0 {
-                        implicit = false
-                        for i := 0; i < len(event.tag_directives); i++ {
-                                tag_directive := &event.tag_directives[i]
-                                if !yaml_emitter_write_indicator(emitter, []byte("%TAG"), true, false, false) {
-                                        return false
-                                }
-                                if !yaml_emitter_write_tag_handle(emitter, tag_directive.handle) {
-                                        return false
-                                }
-                                if !yaml_emitter_write_tag_content(emitter, tag_directive.prefix, true) {
-                                        return false
-                                }
-                                if !yaml_emitter_write_indent(emitter) {
-                                        return false
-                                }
-                        }
-                }
-
-                if yaml_emitter_check_empty_document(emitter) {
-                        implicit = false
-                }
-                if !implicit {
-                        if !yaml_emitter_write_indent(emitter) {
-                                return false
-                        }
-                        if !yaml_emitter_write_indicator(emitter, []byte("---"), true, false, false) {
-                                return false
-                        }
-                        if emitter.canonical {
-                                if !yaml_emitter_write_indent(emitter) {
-                                        return false
-                                }
-                        }
-                }
-
-                emitter.state = yaml_EMIT_DOCUMENT_CONTENT_STATE
-                return true
-        }
-
-        if event.typ == yaml_STREAM_END_EVENT {
-                if emitter.open_ended {
-                        if !yaml_emitter_write_indicator(emitter, []byte("..."), true, false, false) {
-                                return false
-                        }
-                        if !yaml_emitter_write_indent(emitter) {
-                                return false
-                        }
-                }
-                if !yaml_emitter_flush(emitter) {
-                        return false
-                }
-                emitter.state = yaml_EMIT_END_STATE
-                return true
-        }
-
-        return yaml_emitter_set_emitter_error(emitter, "expected DOCUMENT-START or STREAM-END")
-}
-
-// Expect the root node.
-func yaml_emitter_emit_document_content(emitter *yaml_emitter_t, event *yaml_event_t) bool {
-        emitter.states = append(emitter.states, yaml_EMIT_DOCUMENT_END_STATE)
-        return yaml_emitter_emit_node(emitter, event, true, false, false, false)
-}
-
-// Expect DOCUMENT-END.
-func yaml_emitter_emit_document_end(emitter *yaml_emitter_t, event *yaml_event_t) bool {
-        if event.typ != yaml_DOCUMENT_END_EVENT {
-                return yaml_emitter_set_emitter_error(emitter, "expected DOCUMENT-END")
-        }
-        if !yaml_emitter_write_indent(emitter) {
-                return false
-        }
-        if !event.implicit {
-                // [Go] Allocate the slice elsewhere.
-                if !yaml_emitter_write_indicator(emitter, []byte("..."), true, false, false) {
-                        return false
-                }
-                if !yaml_emitter_write_indent(emitter) {
-                        return false
-                }
-        }
-        if !yaml_emitter_flush(emitter) {
-                return false
-        }
-        emitter.state = yaml_EMIT_DOCUMENT_START_STATE
-        emitter.tag_directives = emitter.tag_directives[:0]
-        return true
-}
-
-// Expect a flow item node.
-func yaml_emitter_emit_flow_sequence_item(emitter *yaml_emitter_t, event *yaml_event_t, first bool) bool {
-        if first {
-                if !yaml_emitter_write_indicator(emitter, []byte{'['}, true, true, false) {
-                        return false
-                }
-                if !yaml_emitter_increase_indent(emitter, true, false) {
-                        return false
-                }
-                emitter.flow_level++
-        }
-
-        if event.typ == yaml_SEQUENCE_END_EVENT {
-                emitter.flow_level--
-                emitter.indent = emitter.indents[len(emitter.indents)-1]
-                emitter.indents = emitter.indents[:len(emitter.indents)-1]
-                if emitter.canonical && !first {
-                        if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
-                                return false
-                        }
-                        if !yaml_emitter_write_indent(emitter) {
-                                return false
-                        }
-                }
-                if !yaml_emitter_write_indicator(emitter, []byte{']'}, false, false, false) {
-                        return false
-                }
-                emitter.state = emitter.states[len(emitter.states)-1]
-                emitter.states = emitter.states[:len(emitter.states)-1]
-
-                return true
-        }
-
-        if !first {
-                if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
-                        return false
-                }
-        }
-
-        if emitter.canonical || emitter.column > emitter.best_width {
-                if !yaml_emitter_write_indent(emitter) {
-                        return false
-                }
-        }
-        emitter.states = append(emitter.states, yaml_EMIT_FLOW_SEQUENCE_ITEM_STATE)
-        return yaml_emitter_emit_node(emitter, event, false, true, false, false)
-}
-
-// Expect a flow key node.
-func yaml_emitter_emit_flow_mapping_key(emitter *yaml_emitter_t, event *yaml_event_t, first bool) bool {
-        if first {
-                if !yaml_emitter_write_indicator(emitter, []byte{'{'}, true, true, false) {
-                        return false
-                }
-                if !yaml_emitter_increase_indent(emitter, true, false) {
-                        return false
-                }
-                emitter.flow_level++
-        }
-
-        if event.typ == yaml_MAPPING_END_EVENT {
-                emitter.flow_level--
-                emitter.indent = emitter.indents[len(emitter.indents)-1]
-                emitter.indents = emitter.indents[:len(emitter.indents)-1]
-                if emitter.canonical && !first {
-                        if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
-                                return false
-                        }
-                        if !yaml_emitter_write_indent(emitter) {
-                                return false
-                        }
-                }
-                if !yaml_emitter_write_indicator(emitter, []byte{'}'}, false, false, false) {
-                        return false
-                }
-                emitter.state = emitter.states[len(emitter.states)-1]
-                emitter.states = emitter.states[:len(emitter.states)-1]
-                return true
-        }
-
-        if !first {
-                if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
-                        return false
-                }
-        }
-        if emitter.canonical || emitter.column > emitter.best_width {
-                if !yaml_emitter_write_indent(emitter) {
-                        return false
-                }
-        }
-
-        if !emitter.canonical && yaml_emitter_check_simple_key(emitter) {
-                emitter.states = append(emitter.states, yaml_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE)
-                return yaml_emitter_emit_node(emitter, event, false, false, true, true)
-        }
-        if !yaml_emitter_write_indicator(emitter, []byte{'?'}, true, false, false) {
-                return false
-        }
-        emitter.states = append(emitter.states, yaml_EMIT_FLOW_MAPPING_VALUE_STATE)
-        return yaml_emitter_emit_node(emitter, event, false, false, true, false)
-}
-
-// Expect a flow value node.
-func yaml_emitter_emit_flow_mapping_value(emitter *yaml_emitter_t, event *yaml_event_t, simple bool) bool {
-        if simple {
-                if !yaml_emitter_write_indicator(emitter, []byte{':'}, false, false, false) {
-                        return false
-                }
-        } else {
-                if emitter.canonical || emitter.column > emitter.best_width {
-                        if !yaml_emitter_write_indent(emitter) {
-                                return false
-                        }
-                }
-                if !yaml_emitter_write_indicator(emitter, []byte{':'}, true, false, false) {
-                        return false
-                }
-        }
-        emitter.states = append(emitter.states, yaml_EMIT_FLOW_MAPPING_KEY_STATE)
-        return yaml_emitter_emit_node(emitter, event, false, false, true, false)
-}
-
-// Expect a block item node.
-func yaml_emitter_emit_block_sequence_item(emitter *yaml_emitter_t, event *yaml_event_t, first bool) bool {
-        if first {
-                if !yaml_emitter_increase_indent(emitter, false, emitter.mapping_context && !emitter.indention) {
-                        return false
-                }
-        }
-        if event.typ == yaml_SEQUENCE_END_EVENT {
-                emitter.indent = emitter.indents[len(emitter.indents)-1]
-                emitter.indents = emitter.indents[:len(emitter.indents)-1]
-                emitter.state = emitter.states[len(emitter.states)-1]
-                emitter.states = emitter.states[:len(emitter.states)-1]
-                return true
-        }
-        if !yaml_emitter_write_indent(emitter) {
-                return false
-        }
-        if !yaml_emitter_write_indicator(emitter, []byte{'-'}, true, false, true) {
-                return false
-        }
-        emitter.states = append(emitter.states, yaml_EMIT_BLOCK_SEQUENCE_ITEM_STATE)
-        return yaml_emitter_emit_node(emitter, event, false, true, false, false)
-}
-
-// Expect a block key node.
-func yaml_emitter_emit_block_mapping_key(emitter *yaml_emitter_t, event *yaml_event_t, first bool) bool {
-        if first {
-                if !yaml_emitter_increase_indent(emitter, false, false) {
-                        return false
-                }
-        }
-        if event.typ == yaml_MAPPING_END_EVENT {
-                emitter.indent = emitter.indents[len(emitter.indents)-1]
-                emitter.indents = emitter.indents[:len(emitter.indents)-1]
-                emitter.state = emitter.states[len(emitter.states)-1]
-                emitter.states = emitter.states[:len(emitter.states)-1]
-                return true
-        }
-        if !yaml_emitter_write_indent(emitter) {
-                return false
-        }
-        if yaml_emitter_check_simple_key(emitter) {
-                emitter.states = append(emitter.states, yaml_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE)
-                return yaml_emitter_emit_node(emitter, event, false, false, true, true)
-        }
-        if !yaml_emitter_write_indicator(emitter, []byte{'?'}, true, false, true) {
-                return false
-        }
-        emitter.states = append(emitter.states, yaml_EMIT_BLOCK_MAPPING_VALUE_STATE)
-        return yaml_emitter_emit_node(emitter, event, false, false, true, false)
-}
-
-// Expect a block value node.
-func yaml_emitter_emit_block_mapping_value(emitter *yaml_emitter_t, event *yaml_event_t, simple bool) bool {
-        if simple {
-                if !yaml_emitter_write_indicator(emitter, []byte{':'}, false, false, false) {
-                        return false
-                }
-        } else {
-                if !yaml_emitter_write_indent(emitter) {
-                        return false
-                }
-                if !yaml_emitter_write_indicator(emitter, []byte{':'}, true, false, true) {
-                        return false
-                }
-        }
-        emitter.states = append(emitter.states, yaml_EMIT_BLOCK_MAPPING_KEY_STATE)
-        return yaml_emitter_emit_node(emitter, event, false, false, true, false)
-}
-
-// Expect a node.
-func yaml_emitter_emit_node(emitter *yaml_emitter_t, event *yaml_event_t,
-        root bool, sequence bool, mapping bool, simple_key bool) bool {
-
-        emitter.root_context = root
-        emitter.sequence_context = sequence
-        emitter.mapping_context = mapping
-        emitter.simple_key_context = simple_key
-
-        switch event.typ {
-        case yaml_ALIAS_EVENT:
-                return yaml_emitter_emit_alias(emitter, event)
-        case yaml_SCALAR_EVENT:
-                return yaml_emitter_emit_scalar(emitter, event)
-        case yaml_SEQUENCE_START_EVENT:
-                return yaml_emitter_emit_sequence_start(emitter, event)
-        case yaml_MAPPING_START_EVENT:
-                return yaml_emitter_emit_mapping_start(emitter, event)
-        default:
-                return yaml_emitter_set_emitter_error(emitter,
-                        "expected SCALAR, SEQUENCE-START, MAPPING-START, or ALIAS")
-        }
-        return false
-}
-
-// Expect ALIAS.
-func yaml_emitter_emit_alias(emitter *yaml_emitter_t, event *yaml_event_t) bool {
-        if !yaml_emitter_process_anchor(emitter) {
-                return false
-        }
-        emitter.state = emitter.states[len(emitter.states)-1]
-        emitter.states = emitter.states[:len(emitter.states)-1]
-        return true
-}
-
-// Expect SCALAR.
-func yaml_emitter_emit_scalar(emitter *yaml_emitter_t, event *yaml_event_t) bool {
-        if !yaml_emitter_select_scalar_style(emitter, event) {
-                return false
-        }
-        if !yaml_emitter_process_anchor(emitter) {
-                return false
-        }
-        if !yaml_emitter_process_tag(emitter) {
-                return false
-        }
-        if !yaml_emitter_increase_indent(emitter, true, false) {
-                return false
-        }
-        if !yaml_emitter_process_scalar(emitter) {
-                return false
-        }
-        emitter.indent = emitter.indents[len(emitter.indents)-1]
-        emitter.indents = emitter.indents[:len(emitter.indents)-1]
-        emitter.state = emitter.states[len(emitter.states)-1]
-        emitter.states = emitter.states[:len(emitter.states)-1]
-        return true
-}
-
-// Expect SEQUENCE-START.
-func yaml_emitter_emit_sequence_start(emitter *yaml_emitter_t, event *yaml_event_t) bool {
-        if !yaml_emitter_process_anchor(emitter) {
-                return false
-        }
-        if !yaml_emitter_process_tag(emitter) {
-                return false
-        }
-        if emitter.flow_level > 0 || emitter.canonical || event.sequence_style() == yaml_FLOW_SEQUENCE_STYLE ||
-                yaml_emitter_check_empty_sequence(emitter) {
-                emitter.state = yaml_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE
-        } else {
-                emitter.state = yaml_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE
-        }
-        return true
-}
-
-// Expect MAPPING-START.
-func yaml_emitter_emit_mapping_start(emitter *yaml_emitter_t, event *yaml_event_t) bool {
-        if !yaml_emitter_process_anchor(emitter) {
-                return false
-        }
-        if !yaml_emitter_process_tag(emitter) {
-                return false
-        }
-        if emitter.flow_level > 0 || emitter.canonical || event.mapping_style() == yaml_FLOW_MAPPING_STYLE ||
-                yaml_emitter_check_empty_mapping(emitter) {
-                emitter.state = yaml_EMIT_FLOW_MAPPING_FIRST_KEY_STATE
-        } else {
-                emitter.state = yaml_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE
-        }
-        return true
-}
-
-// Check if the document content is an empty scalar.
-func yaml_emitter_check_empty_document(emitter *yaml_emitter_t) bool {
-        return false // [Go] Huh?
-}
-
-// Check if the next events represent an empty sequence.
-func yaml_emitter_check_empty_sequence(emitter *yaml_emitter_t) bool {
-        if len(emitter.events)-emitter.events_head < 2 {
-                return false
-        }
-        return emitter.events[emitter.events_head].typ == yaml_SEQUENCE_START_EVENT &&
-                emitter.events[emitter.events_head+1].typ == yaml_SEQUENCE_END_EVENT
-}
-
-// Check if the next events represent an empty mapping.
-func yaml_emitter_check_empty_mapping(emitter *yaml_emitter_t) bool {
-        if len(emitter.events)-emitter.events_head < 2 {
-                return false
-        }
-        return emitter.events[emitter.events_head].typ == yaml_MAPPING_START_EVENT &&
-                emitter.events[emitter.events_head+1].typ == yaml_MAPPING_END_EVENT
-}
-
-// Check if the next node can be expressed as a simple key.
-func yaml_emitter_check_simple_key(emitter *yaml_emitter_t) bool {
-        length := 0
-        switch emitter.events[emitter.events_head].typ {
-        case yaml_ALIAS_EVENT:
-                length += len(emitter.anchor_data.anchor)
-        case yaml_SCALAR_EVENT:
-                if emitter.scalar_data.multiline {
-                        return false
-                }
-                length += len(emitter.anchor_data.anchor) +
-                        len(emitter.tag_data.handle) +
-                        len(emitter.tag_data.suffix) +
-                        len(emitter.scalar_data.value)
-        case yaml_SEQUENCE_START_EVENT:
-                if !yaml_emitter_check_empty_sequence(emitter) {
-                        return false
-                }
-                length += len(emitter.anchor_data.anchor) +
-                        len(emitter.tag_data.handle) +
-                        len(emitter.tag_data.suffix)
-        case yaml_MAPPING_START_EVENT:
-                if !yaml_emitter_check_empty_mapping(emitter) {
-                        return false
-                }
-                length += len(emitter.anchor_data.anchor) +
-                        len(emitter.tag_data.handle) +
-                        len(emitter.tag_data.suffix)
-        default:
-                return false
-        }
-        return length <= 128
-}
-
-// Determine an acceptable scalar style.
-func yaml_emitter_select_scalar_style(emitter *yaml_emitter_t, event *yaml_event_t) bool {
-
-        no_tag := len(emitter.tag_data.handle) == 0 && len(emitter.tag_data.suffix) == 0
-        if no_tag && !event.implicit && !event.quoted_implicit {
-                return yaml_emitter_set_emitter_error(emitter, "neither tag nor implicit flags are specified")
-        }
-
-        style := event.scalar_style()
-        if style == yaml_ANY_SCALAR_STYLE {
-                style = yaml_PLAIN_SCALAR_STYLE
-        }
-        if emitter.canonical {
-                style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
-        }
-        if emitter.simple_key_context && emitter.scalar_data.multiline {
-                style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
-        }
-
-        if style == yaml_PLAIN_SCALAR_STYLE {
-                if emitter.flow_level > 0 && !emitter.scalar_data.flow_plain_allowed ||
-                        emitter.flow_level == 0 && !emitter.scalar_data.block_plain_allowed {
-                        style = yaml_SINGLE_QUOTED_SCALAR_STYLE
-                }
-                if len(emitter.scalar_data.value) == 0 && (emitter.flow_level > 0 || emitter.simple_key_context) {
-                        style = yaml_SINGLE_QUOTED_SCALAR_STYLE
-                }
-                if no_tag && !event.implicit {
-                        style = yaml_SINGLE_QUOTED_SCALAR_STYLE
-                }
-        }
-        if style == yaml_SINGLE_QUOTED_SCALAR_STYLE {
-                if !emitter.scalar_data.single_quoted_allowed {
-                        style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
-                }
-        }
-        if style == yaml_LITERAL_SCALAR_STYLE || style == yaml_FOLDED_SCALAR_STYLE {
-                if !emitter.scalar_data.block_allowed || emitter.flow_level > 0 || emitter.simple_key_context {
-                        style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
-                }
-        }
-
-        if no_tag && !event.quoted_implicit && style != yaml_PLAIN_SCALAR_STYLE {
-                emitter.tag_data.handle = []byte{'!'}
-        }
-        emitter.scalar_data.style = style
-        return true
-}
-
-// Write an achor.
-func yaml_emitter_process_anchor(emitter *yaml_emitter_t) bool {
-        if emitter.anchor_data.anchor == nil {
-                return true
-        }
-        c := []byte{'&'}
-        if emitter.anchor_data.alias {
-                c[0] = '*'
-        }
-        if !yaml_emitter_write_indicator(emitter, c, true, false, false) {
-                return false
-        }
-        return yaml_emitter_write_anchor(emitter, emitter.anchor_data.anchor)
-}
-
-// Write a tag.
-func yaml_emitter_process_tag(emitter *yaml_emitter_t) bool {
-        if len(emitter.tag_data.handle) == 0 && len(emitter.tag_data.suffix) == 0 {
-                return true
-        }
-        if len(emitter.tag_data.handle) > 0 {
-                if !yaml_emitter_write_tag_handle(emitter, emitter.tag_data.handle) {
-                        return false
-                }
-                if len(emitter.tag_data.suffix) > 0 {
-                        if !yaml_emitter_write_tag_content(emitter, emitter.tag_data.suffix, false) {
-                                return false
-                        }
-                }
-        } else {
-                // [Go] Allocate these slices elsewhere.
-                if !yaml_emitter_write_indicator(emitter, []byte("!<"), true, false, false) {
-                        return false
-                }
-                if !yaml_emitter_write_tag_content(emitter, emitter.tag_data.suffix, false) {
-                        return false
-                }
-                if !yaml_emitter_write_indicator(emitter, []byte{'>'}, false, false, false) {
-                        return false
-                }
-        }
-        return true
-}
-
-// Write a scalar.
-func yaml_emitter_process_scalar(emitter *yaml_emitter_t) bool {
-        switch emitter.scalar_data.style {
-        case yaml_PLAIN_SCALAR_STYLE:
-                return yaml_emitter_write_plain_scalar(emitter, emitter.scalar_data.value, !emitter.simple_key_context)
-
-        case yaml_SINGLE_QUOTED_SCALAR_STYLE:
-                return yaml_emitter_write_single_quoted_scalar(emitter, emitter.scalar_data.value, !emitter.simple_key_context)
-
-        case yaml_DOUBLE_QUOTED_SCALAR_STYLE:
-                return yaml_emitter_write_double_quoted_scalar(emitter, emitter.scalar_data.value, !emitter.simple_key_context)
-
-        case yaml_LITERAL_SCALAR_STYLE:
-                return yaml_emitter_write_literal_scalar(emitter, emitter.scalar_data.value)
-
-        case yaml_FOLDED_SCALAR_STYLE:
-                return yaml_emitter_write_folded_scalar(emitter, emitter.scalar_data.value)
-        }
-        panic("unknown scalar style")
-}
-
-// Check if a %YAML directive is valid.
-func yaml_emitter_analyze_version_directive(emitter *yaml_emitter_t, version_directive *yaml_version_directive_t) bool {
-        if version_directive.major != 1 || version_directive.minor != 1 {
-                return yaml_emitter_set_emitter_error(emitter, "incompatible %YAML directive")
-        }
-        return true
-}
-
-// Check if a %TAG directive is valid.
-func yaml_emitter_analyze_tag_directive(emitter *yaml_emitter_t, tag_directive *yaml_tag_directive_t) bool {
-        handle := tag_directive.handle
-        prefix := tag_directive.prefix
-        if len(handle) == 0 {
-                return yaml_emitter_set_emitter_error(emitter, "tag handle must not be empty")
-        }
-        if handle[0] != '!' {
-                return yaml_emitter_set_emitter_error(emitter, "tag handle must start with '!'")
-        }
-        if handle[len(handle)-1] != '!' {
-                return yaml_emitter_set_emitter_error(emitter, "tag handle must end with '!'")
-        }
-        for i := 1; i < len(handle)-1; i += width(handle[i]) {
-                if !is_alpha(handle, i) {
-                        return yaml_emitter_set_emitter_error(emitter, "tag handle must contain alphanumerical characters only")
-                }
-        }
-        if len(prefix) == 0 {
-                return yaml_emitter_set_emitter_error(emitter, "tag prefix must not be empty")
-        }
-        return true
-}
-
-// Check if an anchor is valid.
-func yaml_emitter_analyze_anchor(emitter *yaml_emitter_t, anchor []byte, alias bool) bool {
-        if len(anchor) == 0 {
-                problem := "anchor value must not be empty"
-                if alias {
-                        problem = "alias value must not be empty"
-                }
-                return yaml_emitter_set_emitter_error(emitter, problem)
-        }
-        for i := 0; i < len(anchor); i += width(anchor[i]) {
-                if !is_alpha(anchor, i) {
-                        problem := "anchor value must contain alphanumerical characters only"
-                        if alias {
-                                problem = "alias value must contain alphanumerical characters only"
-                        }
-                        return yaml_emitter_set_emitter_error(emitter, problem)
-                }
-        }
-        emitter.anchor_data.anchor = anchor
-        emitter.anchor_data.alias = alias
-        return true
-}
-
-// Check if a tag is valid.
-func yaml_emitter_analyze_tag(emitter *yaml_emitter_t, tag []byte) bool {
-        if len(tag) == 0 {
-                return yaml_emitter_set_emitter_error(emitter, "tag value must not be empty")
-        }
-        for i := 0; i < len(emitter.tag_directives); i++ {
-                tag_directive := &emitter.tag_directives[i]
-                if bytes.HasPrefix(tag, tag_directive.prefix) {
-                        emitter.tag_data.handle = tag_directive.handle
-                        emitter.tag_data.suffix = tag[len(tag_directive.prefix):]
-                        return true
-                }
-        }
-        emitter.tag_data.suffix = tag
-        return true
-}
-
-// Check if a scalar is valid.
-func yaml_emitter_analyze_scalar(emitter *yaml_emitter_t, value []byte) bool {
-        var (
-                block_indicators   = false
-                flow_indicators    = false
-                line_breaks        = false
-                special_characters = false
-
-                leading_space  = false
-                leading_break  = false
-                trailing_space = false
-                trailing_break = false
-                break_space    = false
-                space_break    = false
-
-                preceeded_by_whitespace = false
-                followed_by_whitespace  = false
-                previous_space          = false
-                previous_break          = false
-        )
-
-        emitter.scalar_data.value = value
-
-        if len(value) == 0 {
-                emitter.scalar_data.multiline = false
-                emitter.scalar_data.flow_plain_allowed = false
-                emitter.scalar_data.block_plain_allowed = true
-                emitter.scalar_data.single_quoted_allowed = true
-                emitter.scalar_data.block_allowed = false
-                return true
-        }
-
-        if len(value) >= 3 && ((value[0] == '-' && value[1] == '-' && value[2] == '-') || (value[0] == '.' && value[1] == '.' && value[2] == '.')) {
-                block_indicators = true
-                flow_indicators = true
-        }
-
-        preceeded_by_whitespace = true
-        for i, w := 0, 0; i < len(value); i += w {
-                w = width(value[0])
-                followed_by_whitespace = i+w >= len(value) || is_blank(value, i+w)
-
-                if i == 0 {
-                        switch value[i] {
-                        case '#', ',', '[', ']', '{', '}', '&', '*', '!', '|', '>', '\'', '"', '%', '@', '`':
-                                flow_indicators = true
-                                block_indicators = true
-                        case '?', ':':
-                                flow_indicators = true
-                                if followed_by_whitespace {
-                                        block_indicators = true
-                                }
-                        case '-':
-                                if followed_by_whitespace {
-                                        flow_indicators = true
-                                        block_indicators = true
-                                }
-                        }
-                } else {
-                        switch value[i] {
-                        case ',', '?', '[', ']', '{', '}':
-                                flow_indicators = true
-                        case ':':
-                                flow_indicators = true
-                                if followed_by_whitespace {
-                                        block_indicators = true
-                                }
-                        case '#':
-                                if preceeded_by_whitespace {
-                                        flow_indicators = true
-                                        block_indicators = true
-                                }
-                        }
-                }
-
-                if !is_printable(value, i) || !is_ascii(value, i) && !emitter.unicode {
-                        special_characters = true
-                }
-                if is_space(value, i) {
-                        if i == 0 {
-                                leading_space = true
-                        }
-                        if i+width(value[i]) == len(value) {
-                                trailing_space = true
-                        }
-                        if previous_break {
-                                break_space = true
-                        }
-                        previous_space = true
-                        previous_break = false
-                } else if is_break(value, i) {
-                        line_breaks = true
-                        if i == 0 {
-                                leading_break = true
-                        }
-                        if i+width(value[i]) == len(value) {
-                                trailing_break = true
-                        }
-                        if previous_space {
-                                space_break = true
-                        }
-                        previous_space = false
-                        previous_break = true
-                } else {
-                        previous_space = false
-                        previous_break = false
-                }
-
-                // [Go]: Why 'z'? Couldn't be the end of the string as that's the loop condition.
-                preceeded_by_whitespace = is_blankz(value, i)
-        }
-
-        emitter.scalar_data.multiline = line_breaks
-        emitter.scalar_data.flow_plain_allowed = true
-        emitter.scalar_data.block_plain_allowed = true
-        emitter.scalar_data.single_quoted_allowed = true
-        emitter.scalar_data.block_allowed = true
-
-        if leading_space || leading_break || trailing_space || trailing_break {
-                emitter.scalar_data.flow_plain_allowed = false
-                emitter.scalar_data.block_plain_allowed = false
-        }
-        if trailing_space {
-                emitter.scalar_data.block_allowed = false
-        }
-        if break_space {
-                emitter.scalar_data.flow_plain_allowed = false
-                emitter.scalar_data.block_plain_allowed = false
-                emitter.scalar_data.single_quoted_allowed = false
-        }
-        if space_break || special_characters {
-                emitter.scalar_data.flow_plain_allowed = false
-                emitter.scalar_data.block_plain_allowed = false
-                emitter.scalar_data.single_quoted_allowed = false
-                emitter.scalar_data.block_allowed = false
-        }
-        if line_breaks {
-                emitter.scalar_data.flow_plain_allowed = false
-                emitter.scalar_data.block_plain_allowed = false
-        }
-        if flow_indicators {
-                emitter.scalar_data.flow_plain_allowed = false
-        }
-        if block_indicators {
-                emitter.scalar_data.block_plain_allowed = false
-        }
-        return true
-}
-
-// Check if the event data is valid.
-func yaml_emitter_analyze_event(emitter *yaml_emitter_t, event *yaml_event_t) bool {
-
-        emitter.anchor_data.anchor = nil
-        emitter.tag_data.handle = nil
-        emitter.tag_data.suffix = nil
-        emitter.scalar_data.value = nil
-
-        switch event.typ {
-        case yaml_ALIAS_EVENT:
-                if !yaml_emitter_analyze_anchor(emitter, event.anchor, true) {
-                        return false
-                }
-
-        case yaml_SCALAR_EVENT:
-                if len(event.anchor) > 0 {
-                        if !yaml_emitter_analyze_anchor(emitter, event.anchor, false) {
-                                return false
-                        }
-                }
-                if len(event.tag) > 0 && (emitter.canonical || (!event.implicit && !event.quoted_implicit)) {
-                        if !yaml_emitter_analyze_tag(emitter, event.tag) {
-                                return false
-                        }
-                }
-                if !yaml_emitter_analyze_scalar(emitter, event.value) {
-                        return false
-                }
-
-        case yaml_SEQUENCE_START_EVENT:
-                if len(event.anchor) > 0 {
-                        if !yaml_emitter_analyze_anchor(emitter, event.anchor, false) {
-                                return false
-                        }
-                }
-                if len(event.tag) > 0 && (emitter.canonical || !event.implicit) {
-                        if !yaml_emitter_analyze_tag(emitter, event.tag) {
-                                return false
-                        }
-                }
-
-        case yaml_MAPPING_START_EVENT:
-                if len(event.anchor) > 0 {
-                        if !yaml_emitter_analyze_anchor(emitter, event.anchor, false) {
-                                return false
-                        }
-                }
-                if len(event.tag) > 0 && (emitter.canonical || !event.implicit) {
-                        if !yaml_emitter_analyze_tag(emitter, event.tag) {
-                                return false
-                        }
-                }
-        }
-        return true
-}
-
-// Write the BOM character.
-func yaml_emitter_write_bom(emitter *yaml_emitter_t) bool {
-        if !flush(emitter) {
-                return false
-        }
-        pos := emitter.buffer_pos
-        emitter.buffer[pos+0] = '\xEF'
-        emitter.buffer[pos+1] = '\xBB'
-        emitter.buffer[pos+2] = '\xBF'
-        emitter.buffer_pos += 3
-        return true
-}
-
-func yaml_emitter_write_indent(emitter *yaml_emitter_t) bool {
-        indent := emitter.indent
-        if indent < 0 {
-                indent = 0
-        }
-        if !emitter.indention || emitter.column > indent || (emitter.column == indent && !emitter.whitespace) {
-                if !put_break(emitter) {
-                        return false
-                }
-        }
-        for emitter.column < indent {
-                if !put(emitter, ' ') {
-                        return false
-                }
-        }
-        emitter.whitespace = true
-        emitter.indention = true
-        return true
-}
-
-func yaml_emitter_write_indicator(emitter *yaml_emitter_t, indicator []byte, need_whitespace, is_whitespace, is_indention bool) bool {
-        if need_whitespace && !emitter.whitespace {
-                if !put(emitter, ' ') {
-                        return false
-                }
-        }
-        if !write_all(emitter, indicator) {
-                return false
-        }
-        emitter.whitespace = is_whitespace
-        emitter.indention = (emitter.indention && is_indention)
-        emitter.open_ended = false
-        return true
-}
-
-func yaml_emitter_write_anchor(emitter *yaml_emitter_t, value []byte) bool {
-        if !write_all(emitter, value) {
-                return false
-        }
-        emitter.whitespace = false
-        emitter.indention = false
-        return true
-}
-
-func yaml_emitter_write_tag_handle(emitter *yaml_emitter_t, value []byte) bool {
-        if !emitter.whitespace {
-                if !put(emitter, ' ') {
-                        return false
-                }
-        }
-        if !write_all(emitter, value) {
-                return false
-        }
-        emitter.whitespace = false
-        emitter.indention = false
-        return true
-}
-
-func yaml_emitter_write_tag_content(emitter *yaml_emitter_t, value []byte, need_whitespace bool) bool {
-        if need_whitespace && !emitter.whitespace {
-                if !put(emitter, ' ') {
-                        return false
-                }
-        }
-        for i := 0; i < len(value); {
-                var must_write bool
-                switch value[i] {
-                case ';', '/', '?', ':', '@', '&', '=', '+', '$', ',', '_', '.', '~', '*', '\'', '(', ')', '[', ']':
-                        must_write = true
-                default:
-                        must_write = is_alpha(value, i)
-                }
-                if must_write {
-                        if !write(emitter, value, &i) {
-                                return false
-                        }
-                } else {
-                        w := width(value[i])
-                        for k := 0; k < w; k++ {
-                                octet := value[i]
-                                i++
-                                if !put(emitter, '%') {
-                                        return false
-                                }
-
-                                c := octet >> 4
-                                if c < 10 {
-                                        c += '0'
-                                } else {
-                                        c += 'A' - 10
-                                }
-                                if !put(emitter, c) {
-                                        return false
-                                }
-
-                                c = octet & 0x0f
-                                if c < 10 {
-                                        c += '0'
-                                } else {
-                                        c += 'A' - 10
-                                }
-                                if !put(emitter, c) {
-                                        return false
-                                }
-                        }
-                }
-        }
-        emitter.whitespace = false
-        emitter.indention = false
-        return true
-}
-
-func yaml_emitter_write_plain_scalar(emitter *yaml_emitter_t, value []byte, allow_breaks bool) bool {
-        if !emitter.whitespace {
-                if !put(emitter, ' ') {
-                        return false
-                }
-        }
-
-        spaces := false
-        breaks := false
-        for i := 0; i < len(value); {
-                if is_space(value, i) {
-                        if allow_breaks && !spaces && emitter.column > emitter.best_width && !is_space(value, i+1) {
-                                if !yaml_emitter_write_indent(emitter) {
-                                        return false
-                                }
-                                i += width(value[i])
-                        } else {
-                                if !write(emitter, value, &i) {
-                                        return false
-                                }
-                        }
-                        spaces = true
-                } else if is_break(value, i) {
-                        if !breaks && value[i] == '\n' {
-                                if !put_break(emitter) {
-                                        return false
-                                }
-                        }
-                        if !write_break(emitter, value, &i) {
-                                return false
-                        }
-                        emitter.indention = true
-                        breaks = true
-                } else {
-                        if breaks {
-                                if !yaml_emitter_write_indent(emitter) {
-                                        return false
-                                }
-                        }
-                        if !write(emitter, value, &i) {
-                                return false
-                        }
-                        emitter.indention = false
-                        spaces = false
-                        breaks = false
-                }
-        }
-
-        emitter.whitespace = false
-        emitter.indention = false
-        if emitter.root_context {
-                emitter.open_ended = true
-        }
-
-        return true
-}
-
-func yaml_emitter_write_single_quoted_scalar(emitter *yaml_emitter_t, value []byte, allow_breaks bool) bool {
-
-        if !yaml_emitter_write_indicator(emitter, []byte{'\''}, true, false, false) {
-                return false
-        }
-
-        spaces := false
-        breaks := false
-        for i := 0; i < len(value); {
-                if is_space(value, i) {
-                        if allow_breaks && !spaces && emitter.column > emitter.best_width && i > 0 && i < len(value)-1 && !is_space(value, i+1) {
-                                if !yaml_emitter_write_indent(emitter) {
-                                        return false
-                                }
-                                i += width(value[i])
-                        } else {
-                                if !write(emitter, value, &i) {
-                                        return false
-                                }
-                        }
-                        spaces = true
-                } else if is_break(value, i) {
-                        if !breaks && value[i] == '\n' {
-                                if !put_break(emitter) {
-                                        return false
-                                }
-                        }
-                        if !write_break(emitter, value, &i) {
-                                return false
-                        }
-                        emitter.indention = true
-                        breaks = true
-                } else {
-                        if breaks {
-                                if !yaml_emitter_write_indent(emitter) {
-                                        return false
-                                }
-                        }
-                        if value[i] == '\'' {
-                                if !put(emitter, '\'') {
-                                        return false
-                                }
-                        }
-                        if !write(emitter, value, &i) {
-                                return false
-                        }
-                        emitter.indention = false
-                        spaces = false
-                        breaks = false
-                }
-        }
-        if !yaml_emitter_write_indicator(emitter, []byte{'\''}, false, false, false) {
-                return false
-        }
-        emitter.whitespace = false
-        emitter.indention = false
-        return true
-}
-
-func yaml_emitter_write_double_quoted_scalar(emitter *yaml_emitter_t, value []byte, allow_breaks bool) bool {
-        spaces := false
-        if !yaml_emitter_write_indicator(emitter, []byte{'"'}, true, false, false) {
-                return false
-        }
-
-        for i := 0; i < len(value); {
-                if !is_printable(value, i) || (!emitter.unicode && !is_ascii(value, i)) ||
-                        is_bom(value, i) || is_break(value, i) ||
-                        value[i] == '"' || value[i] == '\\' {
-
-                        octet := value[i]
-
-                        var w int
-                        var v rune
-                        switch {
-                        case octet&0x80 == 0x00:
-                                w, v = 1, rune(octet&0x7F)
-                        case octet&0xE0 == 0xC0:
-                                w, v = 2, rune(octet&0x1F)
-                        case octet&0xF0 == 0xE0:
-                                w, v = 3, rune(octet&0x0F)
-                        case octet&0xF8 == 0xF0:
-                                w, v = 4, rune(octet&0x07)
-                        }
-                        for k := 1; k < w; k++ {
-                                octet = value[i+k]
-                                v = (v << 6) + (rune(octet) & 0x3F)
-                        }
-                        i += w
-
-                        if !put(emitter, '\\') {
-                                return false
-                        }
-
-                        var ok bool
-                        switch v {
-                        case 0x00:
-                                ok = put(emitter, '0')
-                        case 0x07:
-                                ok = put(emitter, 'a')
-                        case 0x08:
-                                ok = put(emitter, 'b')
-                        case 0x09:
-                                ok = put(emitter, 't')
-                        case 0x0A:
-                                ok = put(emitter, 'n')
-                        case 0x0b:
-                                ok = put(emitter, 'v')
-                        case 0x0c:
-                                ok = put(emitter, 'f')
-                        case 0x0d:
-                                ok = put(emitter, 'r')
-                        case 0x1b:
-                                ok = put(emitter, 'e')
-                        case 0x22:
-                                ok = put(emitter, '"')
-                        case 0x5c:
-                                ok = put(emitter, '\\')
-                        case 0x85:
-                                ok = put(emitter, 'N')
-                        case 0xA0:
-                                ok = put(emitter, '_')
-                        case 0x2028:
-                                ok = put(emitter, 'L')
-                        case 0x2029:
-                                ok = put(emitter, 'P')
-                        default:
-                                if v <= 0xFF {
-                                        ok = put(emitter, 'x')
-                                        w = 2
-                                } else if v <= 0xFFFF {
-                                        ok = put(emitter, 'u')
-                                        w = 4
-                                } else {
-                                        ok = put(emitter, 'U')
-                                        w = 8
-                                }
-                                for k := (w - 1) * 4; ok && k >= 0; k -= 4 {
-                                        digit := byte((v >> uint(k)) & 0x0F)
-                                        if digit < 10 {
-                                                ok = put(emitter, digit+'0')
-                                        } else {
-                                                ok = put(emitter, digit+'A'-10)
-                                        }
-                                }
-                        }
-                        if !ok {
-                                return false
-                        }
-                        spaces = false
-                } else if is_space(value, i) {
-                        if allow_breaks && !spaces && emitter.column > emitter.best_width && i > 0 && i < len(value)-1 {
-                                if !yaml_emitter_write_indent(emitter) {
-                                        return false
-                                }
-                                if is_space(value, i+1) {
-                                        if !put(emitter, '\\') {
-                                                return false
-                                        }
-                                }
-                                i += width(value[i])
-                        } else if !write(emitter, value, &i) {
-                                return false
-                        }
-                        spaces = true
-                } else {
-                        if !write(emitter, value, &i) {
-                                return false
-                        }
-                        spaces = false
-                }
-        }
-        if !yaml_emitter_write_indicator(emitter, []byte{'"'}, false, false, false) {
-                return false
-        }
-        emitter.whitespace = false
-        emitter.indention = false
-        return true
-}
-
-func yaml_emitter_write_block_scalar_hints(emitter *yaml_emitter_t, value []byte) bool {
-        if is_space(value, 0) || is_break(value, 0) {
-                indent_hint := []byte{'0' + byte(emitter.best_indent)}
-                if !yaml_emitter_write_indicator(emitter, indent_hint, false, false, false) {
-                        return false
-                }
-        }
-
-        emitter.open_ended = false
-
-        var chomp_hint [1]byte
-        if len(value) == 0 {
-                chomp_hint[0] = '-'
-        } else {
-                i := len(value) - 1
-                for value[i]&0xC0 == 0x80 {
-                        i--
-                }
-                if !is_break(value, i) {
-                        chomp_hint[0] = '-'
-                } else if i == 0 {
-                        chomp_hint[0] = '+'
-                        emitter.open_ended = true
-                } else {
-                        i--
-                        for value[i]&0xC0 == 0x80 {
-                                i--
-                        }
-                        if is_break(value, i) {
-                                chomp_hint[0] = '+'
-                                emitter.open_ended = true
-                        }
-                }
-        }
-        if chomp_hint[0] != 0 {
-                if !yaml_emitter_write_indicator(emitter, chomp_hint[:], false, false, false) {
-                        return false
-                }
-        }
-        return true
-}
-
-func yaml_emitter_write_literal_scalar(emitter *yaml_emitter_t, value []byte) bool {
-        if !yaml_emitter_write_indicator(emitter, []byte{'|'}, true, false, false) {
-                return false
-        }
-        if !yaml_emitter_write_block_scalar_hints(emitter, value) {
-                return false
-        }
-        if !put_break(emitter) {
-                return false
-        }
-        emitter.indention = true
-        emitter.whitespace = true
-        breaks := true
-        for i := 0; i < len(value); {
-                if is_break(value, i) {
-                        if !write_break(emitter, value, &i) {
-                                return false
-                        }
-                        emitter.indention = true
-                        breaks = true
-                } else {
-                        if breaks {
-                                if !yaml_emitter_write_indent(emitter) {
-                                        return false
-                                }
-                        }
-                        if !write(emitter, value, &i) {
-                                return false
-                        }
-                        emitter.indention = false
-                        breaks = false
-                }
-        }
-
-        return true
-}
-
-func yaml_emitter_write_folded_scalar(emitter *yaml_emitter_t, value []byte) bool {
-        if !yaml_emitter_write_indicator(emitter, []byte{'>'}, true, false, false) {
-                return false
-        }
-        if !yaml_emitter_write_block_scalar_hints(emitter, value) {
-                return false
-        }
-
-        if !put_break(emitter) {
-                return false
-        }
-        emitter.indention = true
-        emitter.whitespace = true
-
-        breaks := true
-        leading_spaces := true
-        for i := 0; i < len(value); {
-                if is_break(value, i) {
-                        if !breaks && !leading_spaces && value[i] == '\n' {
-                                k := 0
-                                for is_break(value, k) {
-                                        k += width(value[k])
-                                }
-                                if !is_blankz(value, k) {
-                                        if !put_break(emitter) {
-                                                return false
-                                        }
-                                }
-                        }
-                        if !write_break(emitter, value, &i) {
-                                return false
-                        }
-                        emitter.indention = true
-                        breaks = true
-                } else {
-                        if breaks {
-                                if !yaml_emitter_write_indent(emitter) {
-                                        return false
-                                }
-                                leading_spaces = is_blank(value, i)
-                        }
-                        if !breaks && is_space(value, i) && !is_space(value, i+1) && emitter.column > emitter.best_width {
-                                if !yaml_emitter_write_indent(emitter) {
-                                        return false
-                                }
-                                i += width(value[i])
-                        } else {
-                                if !write(emitter, value, &i) {
-                                        return false
-                                }
-                        }
-                        emitter.indention = false
-                        breaks = false
-                }
-        }
-        return true
-}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/encode.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/encode.go
deleted file mode 100644
index 7f8b796..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/encode.go
+++ /dev/null
@@ -1,290 +0,0 @@
-package yaml
-
-import (
-        "encoding"
-        "reflect"
-        "regexp"
-        "sort"
-        "strconv"
-        "strings"
-        "time"
-)
-
-type encoder struct {
-        emitter yaml_emitter_t
-        event   yaml_event_t
-        out     []byte
-        flow    bool
-}
-
-func newEncoder() (e *encoder) {
-        e = &encoder{}
-        e.must(yaml_emitter_initialize(&e.emitter))
-        yaml_emitter_set_output_string(&e.emitter, &e.out)
-        yaml_emitter_set_unicode(&e.emitter, true)
-        e.must(yaml_stream_start_event_initialize(&e.event, yaml_UTF8_ENCODING))
-        e.emit()
-        e.must(yaml_document_start_event_initialize(&e.event, nil, nil, true))
-        e.emit()
-        return e
-}
-
-func (e *encoder) finish() {
-        e.must(yaml_document_end_event_initialize(&e.event, true))
-        e.emit()
-        e.emitter.open_ended = false
-        e.must(yaml_stream_end_event_initialize(&e.event))
-        e.emit()
-}
-
-func (e *encoder) destroy() {
-        yaml_emitter_delete(&e.emitter)
-}
-
-func (e *encoder) emit() {
-        // This will internally delete the e.event value.
-        if !yaml_emitter_emit(&e.emitter, &e.event) && e.event.typ != yaml_DOCUMENT_END_EVENT && e.event.typ != yaml_STREAM_END_EVENT {
-                e.must(false)
-        }
-}
-
-func (e *encoder) must(ok bool) {
-        if !ok {
-                msg := e.emitter.problem
-                if msg == "" {
-                        msg = "unknown problem generating YAML content"
-                }
-                failf("%s", msg)
-        }
-}
-
-func (e *encoder) marshal(tag string, in reflect.Value) {
-        if !in.IsValid() {
-                e.nilv()
-                return
-        }
-        iface := in.Interface()
-        if m, ok := iface.(Marshaler); ok {
-                v, err := m.MarshalYAML()
-                if err != nil {
-                        fail(err)
-                }
-                if v == nil {
-                        e.nilv()
-                        return
-                }
-                in = reflect.ValueOf(v)
-        }
-        if m, ok := iface.(encoding.TextMarshaler); ok {
-                text, err := m.MarshalText()
-                if err != nil {
-                        fail(err)
-                }
-                in = reflect.ValueOf(string(text))
-        }
-        switch in.Kind() {
-        case reflect.Interface:
-                if in.IsNil() {
-                        e.nilv()
-                } else {
-                        e.marshal(tag, in.Elem())
-                }
-        case reflect.Map:
-                e.mapv(tag, in)
-        case reflect.Ptr:
-                if in.IsNil() {
-                        e.nilv()
-                } else {
-                        e.marshal(tag, in.Elem())
-                }
-        case reflect.Struct:
-                e.structv(tag, in)
-        case reflect.Slice:
-                if in.Type().Elem() == mapItemType {
-                        e.itemsv(tag, in)
-                } else {
-                        e.slicev(tag, in)
-                }
-        case reflect.String:
-                e.stringv(tag, in)
-        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
-                if in.Type() == durationType {
-                        e.stringv(tag, reflect.ValueOf(iface.(time.Duration).String()))
-                } else {
-                        e.intv(tag, in)
-                }
-        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
-                e.uintv(tag, in)
-        case reflect.Float32, reflect.Float64:
-                e.floatv(tag, in)
-        case reflect.Bool:
-                e.boolv(tag, in)
-        default:
-                panic("cannot marshal type: " + in.Type().String())
-        }
-}
-
-func (e *encoder) mapv(tag string, in reflect.Value) {
-        e.mappingv(tag, func() {
-                keys := keyList(in.MapKeys())
-                sort.Sort(keys)
-                for _, k := range keys {
-                        e.marshal("", k)
-                        e.marshal("", in.MapIndex(k))
-                }
-        })
-}
-
-func (e *encoder) itemsv(tag string, in reflect.Value) {
-        e.mappingv(tag, func() {
-                slice := in.Convert(reflect.TypeOf([]MapItem{})).Interface().([]MapItem)
-                for _, item := range slice {
-                        e.marshal("", reflect.ValueOf(item.Key))
-                        e.marshal("", reflect.ValueOf(item.Value))
-                }
-        })
-}
-
-func (e *encoder) structv(tag string, in reflect.Value) {
-        sinfo, err := getStructInfo(in.Type())
-        if err != nil {
-                panic(err)
-        }
-        e.mappingv(tag, func() {
-                for _, info := range sinfo.FieldsList {
-                        var value reflect.Value
-                        if info.Inline == nil {
-                                value = in.Field(info.Num)
-                        } else {
-                                value = in.FieldByIndex(info.Inline)
-                        }
-                        if info.OmitEmpty && isZero(value) {
-                                continue
-                        }
-                        e.marshal("", reflect.ValueOf(info.Key))
-                        e.flow = info.Flow
-                        e.marshal("", value)
-                }
-        })
-}
-
-func (e *encoder) mappingv(tag string, f func()) {
-        implicit := tag == ""
-        style := yaml_BLOCK_MAPPING_STYLE
-        if e.flow {
-                e.flow = false
-                style = yaml_FLOW_MAPPING_STYLE
-        }
-        e.must(yaml_mapping_start_event_initialize(&e.event, nil, []byte(tag), implicit, style))
-        e.emit()
-        f()
-        e.must(yaml_mapping_end_event_initialize(&e.event))
-        e.emit()
-}
-
-func (e *encoder) slicev(tag string, in reflect.Value) {
-        implicit := tag == ""
-        style := yaml_BLOCK_SEQUENCE_STYLE
-        if e.flow {
-                e.flow = false
-                style = yaml_FLOW_SEQUENCE_STYLE
-        }
-        e.must(yaml_sequence_start_event_initialize(&e.event, nil, []byte(tag), implicit, style))
-        e.emit()
-        n := in.Len()
-        for i := 0; i < n; i++ {
-                e.marshal("", in.Index(i))
-        }
-        e.must(yaml_sequence_end_event_initialize(&e.event))
-        e.emit()
-}
-
-// isBase60 returns whether s is in base 60 notation as defined in YAML 1.1.
-//
-// The base 60 float notation in YAML 1.1 is a terrible idea and is unsupported
-// in YAML 1.2 and by this package, but these should be marshalled quoted for
-// the time being for compatibility with other parsers.
-func isBase60Float(s string) (result bool) {
-        // Fast path.
-        if s == "" {
-                return false
-        }
-        c := s[0]
-        if !(c == '+' || c == '-' || c >= '0' && c <= '9') || strings.IndexByte(s, ':') < 0 {
-                return false
-        }
-        // Do the full match.
-        return base60float.MatchString(s)
-}
-
-// From http://yaml.org/type/float.html, except the regular expression there
-// is bogus. In practice parsers do not enforce the "\.[0-9_]*" suffix.
-var base60float = regexp.MustCompile(`^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+(?:\.[0-9_]*)?$`)
-
-func (e *encoder) stringv(tag string, in reflect.Value) {
-        var style yaml_scalar_style_t
-        s := in.String()
-        rtag, rs := resolve("", s)
-        if rtag == yaml_BINARY_TAG {
-                if tag == "" || tag == yaml_STR_TAG {
-                        tag = rtag
-                        s = rs.(string)
-                } else if tag == yaml_BINARY_TAG {
-                        failf("explicitly tagged !!binary data must be base64-encoded")
-                } else {
-                        failf("cannot marshal invalid UTF-8 data as %s", shortTag(tag))
-                }
-        }
-        if tag == "" && (rtag != yaml_STR_TAG || isBase60Float(s)) {
-                style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
-        } else if strings.Contains(s, "\n") {
-                style = yaml_LITERAL_SCALAR_STYLE
-        } else {
-                style = yaml_PLAIN_SCALAR_STYLE
-        }
-        e.emitScalar(s, "", tag, style)
-}
-
-func (e *encoder) boolv(tag string, in reflect.Value) {
-        var s string
-        if in.Bool() {
-                s = "true"
-        } else {
-                s = "false"
-        }
-        e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE)
-}
-
-func (e *encoder) intv(tag string, in reflect.Value) {
-        s := strconv.FormatInt(in.Int(), 10)
-        e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE)
-}
-
-func (e *encoder) uintv(tag string, in reflect.Value) {
-        s := strconv.FormatUint(in.Uint(), 10)
-        e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE)
-}
-
-func (e *encoder) floatv(tag string, in reflect.Value) {
-        // FIXME: Handle 64 bits here.
-        s := strconv.FormatFloat(float64(in.Float()), 'g', -1, 32)
-        switch s {
-        case "+Inf":
-                s = ".inf"
-        case "-Inf":
-                s = "-.inf"
-        case "NaN":
-                s = ".nan"
-        }
-        e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE)
-}
-
-func (e *encoder) nilv() {
-        e.emitScalar("null", "", "", yaml_PLAIN_SCALAR_STYLE)
-}
-
-func (e *encoder) emitScalar(value, anchor, tag string, style yaml_scalar_style_t) {
-        implicit := tag == ""
-        e.must(yaml_scalar_event_initialize(&e.event, []byte(anchor), []byte(tag), []byte(value), implicit, implicit, style))
-        e.emit()
-}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/encode_test.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/encode_test.go
deleted file mode 100644
index 5a965b3..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/encode_test.go
+++ /dev/null
@@ -1,434 +0,0 @@
-package yaml_test
-
-import (
-        "fmt"
-        "math"
-        "strconv"
-        "strings"
-        "time"
-
-        . "gopkg.in/check.v1"
-        "github.com/stevenjack/cig/Godeps/_workspace/src/gopkg.in/yaml.v2"
-        "net"
-)
-
-var marshalIntTest = 123
-
-var marshalTests = []struct {
-        value interface{}
-        data  string
-}{
-        {
-                nil,
-                "null\n",
-        }, {
-                &struct{}{},
-                "{}\n",
-        }, {
-                map[string]string{"v": "hi"},
-                "v: hi\n",
-        }, {
-                map[string]interface{}{"v": "hi"},
-                "v: hi\n",
-        }, {
-                map[string]string{"v": "true"},
-                "v: \"true\"\n",
-        }, {
-                map[string]string{"v": "false"},
-                "v: \"false\"\n",
-        }, {
-                map[string]interface{}{"v": true},
-                "v: true\n",
-        }, {
-                map[string]interface{}{"v": false},
-                "v: false\n",
-        }, {
-                map[string]interface{}{"v": 10},
-                "v: 10\n",
-        }, {
-                map[string]interface{}{"v": -10},
-                "v: -10\n",
-        }, {
-                map[string]uint{"v": 42},
-                "v: 42\n",
-        }, {
-                map[string]interface{}{"v": int64(4294967296)},
-                "v: 4294967296\n",
-        }, {
-                map[string]int64{"v": int64(4294967296)},
-                "v: 4294967296\n",
-        }, {
-                map[string]uint64{"v": 4294967296},
-                "v: 4294967296\n",
-        }, {
-                map[string]interface{}{"v": "10"},
-                "v: \"10\"\n",
-        }, {
-                map[string]interface{}{"v": 0.1},
-                "v: 0.1\n",
-        }, {
-                map[string]interface{}{"v": float64(0.1)},
-                "v: 0.1\n",
-        }, {
-                map[string]interface{}{"v": -0.1},
-                "v: -0.1\n",
-        }, {
-                map[string]interface{}{"v": math.Inf(+1)},
-                "v: .inf\n",
-        }, {
-                map[string]interface{}{"v": math.Inf(-1)},
-                "v: -.inf\n",
-        }, {
-                map[string]interface{}{"v": math.NaN()},
-                "v: .nan\n",
-        }, {
-                map[string]interface{}{"v": nil},
-                "v: null\n",
-        }, {
-                map[string]interface{}{"v": ""},
-                "v: \"\"\n",
-        }, {
-                map[string][]string{"v": []string{"A", "B"}},
-                "v:\n- A\n- B\n",
-        }, {
-                map[string][]string{"v": []string{"A", "B\nC"}},
-                "v:\n- A\n- |-\n  B\n  C\n",
-        }, {
-                map[string][]interface{}{"v": []interface{}{"A", 1, map[string][]int{"B": []int{2, 3}}}},
-                "v:\n- A\n- 1\n- B:\n  - 2\n  - 3\n",
-        }, {
-                map[string]interface{}{"a": map[interface{}]interface{}{"b": "c"}},
-                "a:\n  b: c\n",
-        }, {
-                map[string]interface{}{"a": "-"},
-                "a: '-'\n",
-        },
-
-        // Simple values.
-        {
-                &marshalIntTest,
-                "123\n",
-        },
-
-        // Structures
-        {
-                &struct{ Hello string }{"world"},
-                "hello: world\n",
-        }, {
-                &struct {
-                        A struct {
-                                B string
-                        }
-                }{struct{ B string }{"c"}},
-                "a:\n  b: c\n",
-        }, {
-                &struct {
-                        A *struct {
-                                B string
-                        }
-                }{&struct{ B string }{"c"}},
-                "a:\n  b: c\n",
-        }, {
-                &struct {
-                        A *struct {
-                                B string
-                        }
-                }{},
-                "a: null\n",
-        }, {
-                &struct{ A int }{1},
-                "a: 1\n",
-        }, {
-                &struct{ A []int }{[]int{1, 2}},
-                "a:\n- 1\n- 2\n",
-        }, {
-                &struct {
-                        B int "a"
-                }{1},
-                "a: 1\n",
-        }, {
-                &struct{ A bool }{true},
-                "a: true\n",
-        },
-
-        // Conditional flag
-        {
-                &struct {
-                        A int "a,omitempty"
-                        B int "b,omitempty"
-                }{1, 0},
-                "a: 1\n",
-        }, {
-                &struct {
-                        A int "a,omitempty"
-                        B int "b,omitempty"
-                }{0, 0},
-                "{}\n",
-        }, {
-                &struct {
-                        A *struct{ X int } "a,omitempty"
-                        B int              "b,omitempty"
-                }{nil, 0},
-                "{}\n",
-        },
-
-        // Flow flag
-        {
-                &struct {
-                        A []int "a,flow"
-                }{[]int{1, 2}},
-                "a: [1, 2]\n",
-        }, {
-                &struct {
-                        A map[string]string "a,flow"
-                }{map[string]string{"b": "c", "d": "e"}},
-                "a: {b: c, d: e}\n",
-        }, {
-                &struct {
-                        A struct {
-                                B, D string
-                        } "a,flow"
-                }{struct{ B, D string }{"c", "e"}},
-                "a: {b: c, d: e}\n",
-        },
-
-        // Unexported field
-        {
-                &struct {
-                        u int
-                        A int
-                }{0, 1},
-                "a: 1\n",
-        },
-
-        // Ignored field
-        {
-                &struct {
-                        A int
-                        B int "-"
-                }{1, 2},
-                "a: 1\n",
-        },
-
-        // Struct inlining
-        {
-                &struct {
-                        A int
-                        C inlineB `yaml:",inline"`
-                }{1, inlineB{2, inlineC{3}}},
-                "a: 1\nb: 2\nc: 3\n",
-        },
-
-        // Duration
-        {
-                map[string]time.Duration{"a": 3 * time.Second},
-                "a: 3s\n",
-        },
-
-        // Issue #24: bug in map merging logic.
-        {
-                map[string]string{"a": "<foo>"},
-                "a: <foo>\n",
-        },
-
-        // Issue #34: marshal unsupported base 60 floats quoted for compatibility
-        // with old YAML 1.1 parsers.
-        {
-                map[string]string{"a": "1:1"},
-                "a: \"1:1\"\n",
-        },
-
-        // Binary data.
-        {
-                map[string]string{"a": "\x00"},
-                "a: \"\\0\"\n",
-        }, {
-                map[string]string{"a": "\x80\x81\x82"},
-                "a: !!binary gIGC\n",
-        }, {
-                map[string]string{"a": strings.Repeat("\x90", 54)},
-                "a: !!binary |\n  " + strings.Repeat("kJCQ", 17) + "kJ\n  CQ\n",
-        },
-
-        // Ordered maps.
-        {
-                &yaml.MapSlice{{"b", 2}, {"a", 1}, {"d", 4}, {"c", 3}, {"sub", yaml.MapSlice{{"e", 5}}}},
-                "b: 2\na: 1\nd: 4\nc: 3\nsub:\n  e: 5\n",
-        },
-
-        // Encode unicode as utf-8 rather than in escaped form.
-        {
-                map[string]string{"a": ""},
-                "a: \n",
-        },
-
-        // Support encoding.TextMarshaler.
-        {
-                map[string]net.IP{"a": net.IPv4(1, 2, 3, 4)},
-                "a: 1.2.3.4\n",
-        },
-}
-
-func (s *S) TestMarshal(c *C) {
-        for _, item := range marshalTests {
-                data, err := yaml.Marshal(item.value)
-                c.Assert(err, IsNil)
-                c.Assert(string(data), Equals, item.data)
-        }
-}
-
-var marshalErrorTests = []struct {
-        value interface{}
-        error string
-        panic string
-}{{
-        value: &struct {
-                B       int
-                inlineB ",inline"
-        }{1, inlineB{2, inlineC{3}}},
-        panic: `Duplicated key 'b' in struct struct \{ B int; .*`,
-}}
-
-func (s *S) TestMarshalErrors(c *C) {
-        for _, item := range marshalErrorTests {
-                if item.panic != "" {
-                        c.Assert(func() { yaml.Marshal(item.value) }, PanicMatches, item.panic)
-                } else {
-                        _, err := yaml.Marshal(item.value)
-                        c.Assert(err, ErrorMatches, item.error)
-                }
-        }
-}
-
-func (s *S) TestMarshalTypeCache(c *C) {
-        var data []byte
-        var err error
-        func() {
-                type T struct{ A int }
-                data, err = yaml.Marshal(&T{})
-                c.Assert(err, IsNil)
-        }()
-        func() {
-                type T struct{ B int }
-                data, err = yaml.Marshal(&T{})
-                c.Assert(err, IsNil)
-        }()
-        c.Assert(string(data), Equals, "b: 0\n")
-}
-
-var marshalerTests = []struct {
-        data  string
-        value interface{}
-}{
-        {"_:\n  hi: there\n", map[interface{}]interface{}{"hi": "there"}},
-        {"_:\n- 1\n- A\n", []interface{}{1, "A"}},
-        {"_: 10\n", 10},
-        {"_: null\n", nil},
-        {"_: BAR!\n", "BAR!"},
-}
-
-type marshalerType struct {
-        value interface{}
-}
-
-func (o marshalerType) MarshalYAML() (interface{}, error) {
-        return o.value, nil
-}
-
-type marshalerValue struct {
-        Field marshalerType "_"
-}
-
-func (s *S) TestMarshaler(c *C) {
-        for _, item := range marshalerTests {
-                obj := &marshalerValue{}
-                obj.Field.value = item.value
-                data, err := yaml.Marshal(obj)
-                c.Assert(err, IsNil)
-                c.Assert(string(data), Equals, string(item.data))
-        }
-}
-
-func (s *S) TestMarshalerWholeDocument(c *C) {
-        obj := &marshalerType{}
-        obj.value = map[string]string{"hello": "world!"}
-        data, err := yaml.Marshal(obj)
-        c.Assert(err, IsNil)
-        c.Assert(string(data), Equals, "hello: world!\n")
-}
-
-type failingMarshaler struct{}
-
-func (ft *failingMarshaler) MarshalYAML() (interface{}, error) {
-        return nil, failingErr
-}
-
-func (s *S) TestMarshalerError(c *C) {
-        _, err := yaml.Marshal(&failingMarshaler{})
-        c.Assert(err, Equals, failingErr)
-}
-
-func (s *S) TestSortedOutput(c *C) {
-        order := []interface{}{
-                false,
-                true,
-                1,
-                uint(1),
-                1.0,
-                1.1,
-                1.2,
-                2,
-                uint(2),
-                2.0,
-                2.1,
-                "",
-                ".1",
-                ".2",
-                ".a",
-                "1",
-                "2",
-                "a!10",
-                "a/2",
-                "a/10",
-                "a~10",
-                "ab/1",
-                "b/1",
-                "b/01",
-                "b/2",
-                "b/02",
-                "b/3",
-                "b/03",
-                "b1",
-                "b01",
-                "b3",
-                "c2.10",
-                "c10.2",
-                "d1",
-                "d12",
-                "d12a",
-        }
-        m := make(map[interface{}]int)
-        for _, k := range order {
-                m[k] = 1
-        }
-        data, err := yaml.Marshal(m)
-        c.Assert(err, IsNil)
-        out := "\n" + string(data)
-        last := 0
-        for i, k := range order {
-                repr := fmt.Sprint(k)
-                if s, ok := k.(string); ok {
-                        if _, err = strconv.ParseFloat(repr, 32); s == "" || err == nil {
-                                repr = `"` + repr + `"`
-                        }
-                }
-                index := strings.Index(out, "\n"+repr+":")
-                if index == -1 {
-                        c.Fatalf("%#v is not in the output: %#v", k, out)
-                }
-                if index < last {
-                        c.Fatalf("%#v was generated before %#v: %q", k, order[i-1], out)
-                }
-                last = index
-        }
-}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/parserc.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/parserc.go
deleted file mode 100644
index 3b89246..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/parserc.go
+++ /dev/null
@@ -1,1096 +0,0 @@
-package yaml
-
-import (
-        "bytes"
-)
-
-// The parser implements the following grammar:
-//
-// stream               ::= STREAM-START implicit_document? explicit_document* STREAM-END
-// implicit_document    ::= block_node DOCUMENT-END*
-// explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
-// block_node_or_indentless_sequence    ::=
-//                          ALIAS
-//                          | properties (block_content | indentless_block_sequence)?
-//                          | block_content
-//                          | indentless_block_sequence
-// block_node           ::= ALIAS
-//                          | properties block_content?
-//                          | block_content
-// flow_node            ::= ALIAS
-//                          | properties flow_content?
-//                          | flow_content
-// properties           ::= TAG ANCHOR? | ANCHOR TAG?
-// block_content        ::= block_collection | flow_collection | SCALAR
-// flow_content         ::= flow_collection | SCALAR
-// block_collection     ::= block_sequence | block_mapping
-// flow_collection      ::= flow_sequence | flow_mapping
-// block_sequence       ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
-// indentless_sequence  ::= (BLOCK-ENTRY block_node?)+
-// block_mapping        ::= BLOCK-MAPPING_START
-//                          ((KEY block_node_or_indentless_sequence?)?
-//                          (VALUE block_node_or_indentless_sequence?)?)*
-//                          BLOCK-END
-// flow_sequence        ::= FLOW-SEQUENCE-START
-//                          (flow_sequence_entry FLOW-ENTRY)*
-//                          flow_sequence_entry?
-//                          FLOW-SEQUENCE-END
-// flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
-// flow_mapping         ::= FLOW-MAPPING-START
-//                          (flow_mapping_entry FLOW-ENTRY)*
-//                          flow_mapping_entry?
-//                          FLOW-MAPPING-END
-// flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
-
-// Peek the next token in the token queue.
-func peek_token(parser *yaml_parser_t) *yaml_token_t {
-        if parser.token_available || yaml_parser_fetch_more_tokens(parser) {
-                return &parser.tokens[parser.tokens_head]
-        }
-        return nil
-}
-
-// Remove the next token from the queue (must be called after peek_token).
-func skip_token(parser *yaml_parser_t) {
-        parser.token_available = false
-        parser.tokens_parsed++
-        parser.stream_end_produced = parser.tokens[parser.tokens_head].typ == yaml_STREAM_END_TOKEN
-        parser.tokens_head++
-}
-
-// Get the next event.
-func yaml_parser_parse(parser *yaml_parser_t, event *yaml_event_t) bool {
-        // Erase the event object.
-        *event = yaml_event_t{}
-
-        // No events after the end of the stream or error.
-        if parser.stream_end_produced || parser.error != yaml_NO_ERROR || parser.state == yaml_PARSE_END_STATE {
-                return true
-        }
-
-        // Generate the next event.
-        return yaml_parser_state_machine(parser, event)
-}
-
-// Set parser error.
-func yaml_parser_set_parser_error(parser *yaml_parser_t, problem string, problem_mark yaml_mark_t) bool {
-        parser.error = yaml_PARSER_ERROR
-        parser.problem = problem
-        parser.problem_mark = problem_mark
-        return false
-}
-
-func yaml_parser_set_parser_error_context(parser *yaml_parser_t, context string, context_mark yaml_mark_t, problem string, problem_mark yaml_mark_t) bool {
-        parser.error = yaml_PARSER_ERROR
-        parser.context = context
-        parser.context_mark = context_mark
-        parser.problem = problem
-        parser.problem_mark = problem_mark
-        return false
-}
-
-// State dispatcher.
-func yaml_parser_state_machine(parser *yaml_parser_t, event *yaml_event_t) bool {
-        //trace("yaml_parser_state_machine", "state:", parser.state.String())
-
-        switch parser.state {
-        case yaml_PARSE_STREAM_START_STATE:
-                return yaml_parser_parse_stream_start(parser, event)
-
-        case yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE:
-                return yaml_parser_parse_document_start(parser, event, true)
-
-        case yaml_PARSE_DOCUMENT_START_STATE:
-                return yaml_parser_parse_document_start(parser, event, false)
-
-        case yaml_PARSE_DOCUMENT_CONTENT_STATE:
-                return yaml_parser_parse_document_content(parser, event)
-
-        case yaml_PARSE_DOCUMENT_END_STATE:
-                return yaml_parser_parse_document_end(parser, event)
-
-        case yaml_PARSE_BLOCK_NODE_STATE:
-                return yaml_parser_parse_node(parser, event, true, false)
-
-        case yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE:
-                return yaml_parser_parse_node(parser, event, true, true)
-
-        case yaml_PARSE_FLOW_NODE_STATE:
-                return yaml_parser_parse_node(parser, event, false, false)
-
-        case yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE:
-                return yaml_parser_parse_block_sequence_entry(parser, event, true)
-
-        case yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE:
-                return yaml_parser_parse_block_sequence_entry(parser, event, false)
-
-        case yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE:
-                return yaml_parser_parse_indentless_sequence_entry(parser, event)
-
-        case yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE:
-                return yaml_parser_parse_block_mapping_key(parser, event, true)
-
-        case yaml_PARSE_BLOCK_MAPPING_KEY_STATE:
-                return yaml_parser_parse_block_mapping_key(parser, event, false)
-
-        case yaml_PARSE_BLOCK_MAPPING_VALUE_STATE:
-                return yaml_parser_parse_block_mapping_value(parser, event)
-
-        case yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE:
-                return yaml_parser_parse_flow_sequence_entry(parser, event, true)
-
-        case yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE:
-                return yaml_parser_parse_flow_sequence_entry(parser, event, false)
-
-        case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE:
-                return yaml_parser_parse_flow_sequence_entry_mapping_key(parser, event)
-
-        case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE:
-                return yaml_parser_parse_flow_sequence_entry_mapping_value(parser, event)
-
-        case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE:
-                return yaml_parser_parse_flow_sequence_entry_mapping_end(parser, event)
-
-        case yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE:
-                return yaml_parser_parse_flow_mapping_key(parser, event, true)
-
-        case yaml_PARSE_FLOW_MAPPING_KEY_STATE:
-                return yaml_parser_parse_flow_mapping_key(parser, event, false)
-
-        case yaml_PARSE_FLOW_MAPPING_VALUE_STATE:
-                return yaml_parser_parse_flow_mapping_value(parser, event, false)
-
-        case yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE:
-                return yaml_parser_parse_flow_mapping_value(parser, event, true)
-
-        default:
-                panic("invalid parser state")
-        }
-        return false
-}
-
-// Parse the production:
-// stream   ::= STREAM-START implicit_document? explicit_document* STREAM-END
-//              ************
-func yaml_parser_parse_stream_start(parser *yaml_parser_t, event *yaml_event_t) bool {
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-        if token.typ != yaml_STREAM_START_TOKEN {
-                return yaml_parser_set_parser_error(parser, "did not find expected <stream-start>", token.start_mark)
-        }
-        parser.state = yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE
-        *event = yaml_event_t{
-                typ:        yaml_STREAM_START_EVENT,
-                start_mark: token.start_mark,
-                end_mark:   token.end_mark,
-                encoding:   token.encoding,
-        }
-        skip_token(parser)
-        return true
-}
-
-// Parse the productions:
-// implicit_document    ::= block_node DOCUMENT-END*
-//                          *
-// explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
-//                          *************************
-func yaml_parser_parse_document_start(parser *yaml_parser_t, event *yaml_event_t, implicit bool) bool {
-
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-
-        // Parse extra document end indicators.
-        if !implicit {
-                for token.typ == yaml_DOCUMENT_END_TOKEN {
-                        skip_token(parser)
-                        token = peek_token(parser)
-                        if token == nil {
-                                return false
-                        }
-                }
-        }
-
-        if implicit && token.typ != yaml_VERSION_DIRECTIVE_TOKEN &&
-                token.typ != yaml_TAG_DIRECTIVE_TOKEN &&
-                token.typ != yaml_DOCUMENT_START_TOKEN &&
-                token.typ != yaml_STREAM_END_TOKEN {
-                // Parse an implicit document.
-                if !yaml_parser_process_directives(parser, nil, nil) {
-                        return false
-                }
-                parser.states = append(parser.states, yaml_PARSE_DOCUMENT_END_STATE)
-                parser.state = yaml_PARSE_BLOCK_NODE_STATE
-
-                *event = yaml_event_t{
-                        typ:        yaml_DOCUMENT_START_EVENT,
-                        start_mark: token.start_mark,
-                        end_mark:   token.end_mark,
-                }
-
-        } else if token.typ != yaml_STREAM_END_TOKEN {
-                // Parse an explicit document.
-                var version_directive *yaml_version_directive_t
-                var tag_directives []yaml_tag_directive_t
-                start_mark := token.start_mark
-                if !yaml_parser_process_directives(parser, &version_directive, &tag_directives) {
-                        return false
-                }
-                token = peek_token(parser)
-                if token == nil {
-                        return false
-                }
-                if token.typ != yaml_DOCUMENT_START_TOKEN {
-                        yaml_parser_set_parser_error(parser,
-                                "did not find expected <document start>", token.start_mark)
-                        return false
-                }
-                parser.states = append(parser.states, yaml_PARSE_DOCUMENT_END_STATE)
-                parser.state = yaml_PARSE_DOCUMENT_CONTENT_STATE
-                end_mark := token.end_mark
-
-                *event = yaml_event_t{
-                        typ:               yaml_DOCUMENT_START_EVENT,
-                        start_mark:        start_mark,
-                        end_mark:          end_mark,
-                        version_directive: version_directive,
-                        tag_directives:    tag_directives,
-                        implicit:          false,
-                }
-                skip_token(parser)
-
-        } else {
-                // Parse the stream end.
-                parser.state = yaml_PARSE_END_STATE
-                *event = yaml_event_t{
-                        typ:        yaml_STREAM_END_EVENT,
-                        start_mark: token.start_mark,
-                        end_mark:   token.end_mark,
-                }
-                skip_token(parser)
-        }
-
-        return true
-}
-
-// Parse the productions:
-// explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
-//                                                    ***********
-//
-func yaml_parser_parse_document_content(parser *yaml_parser_t, event *yaml_event_t) bool {
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-        if token.typ == yaml_VERSION_DIRECTIVE_TOKEN ||
-                token.typ == yaml_TAG_DIRECTIVE_TOKEN ||
-                token.typ == yaml_DOCUMENT_START_TOKEN ||
-                token.typ == yaml_DOCUMENT_END_TOKEN ||
-                token.typ == yaml_STREAM_END_TOKEN {
-                parser.state = parser.states[len(parser.states)-1]
-                parser.states = parser.states[:len(parser.states)-1]
-                return yaml_parser_process_empty_scalar(parser, event,
-                        token.start_mark)
-        }
-        return yaml_parser_parse_node(parser, event, true, false)
-}
-
-// Parse the productions:
-// implicit_document    ::= block_node DOCUMENT-END*
-//                                     *************
-// explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
-//
-func yaml_parser_parse_document_end(parser *yaml_parser_t, event *yaml_event_t) bool {
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-
-        start_mark := token.start_mark
-        end_mark := token.start_mark
-
-        implicit := true
-        if token.typ == yaml_DOCUMENT_END_TOKEN {
-                end_mark = token.end_mark
-                skip_token(parser)
-                implicit = false
-        }
-
-        parser.tag_directives = parser.tag_directives[:0]
-
-        parser.state = yaml_PARSE_DOCUMENT_START_STATE
-        *event = yaml_event_t{
-                typ:        yaml_DOCUMENT_END_EVENT,
-                start_mark: start_mark,
-                end_mark:   end_mark,
-                implicit:   implicit,
-        }
-        return true
-}
-
-// Parse the productions:
-// block_node_or_indentless_sequence    ::=
-//                          ALIAS
-//                          *****
-//                          | properties (block_content | indentless_block_sequence)?
-//                            **********  *
-//                          | block_content | indentless_block_sequence
-//                            *
-// block_node           ::= ALIAS
-//                          *****
-//                          | properties block_content?
-//                            ********** *
-//                          | block_content
-//                            *
-// flow_node            ::= ALIAS
-//                          *****
-//                          | properties flow_content?
-//                            ********** *
-//                          | flow_content
-//                            *
-// properties           ::= TAG ANCHOR? | ANCHOR TAG?
-//                          *************************
-// block_content        ::= block_collection | flow_collection | SCALAR
-//                                                               ******
-// flow_content         ::= flow_collection | SCALAR
-//                                            ******
-func yaml_parser_parse_node(parser *yaml_parser_t, event *yaml_event_t, block, indentless_sequence bool) bool {
-        //defer trace("yaml_parser_parse_node", "block:", block, "indentless_sequence:", indentless_sequence)()
-
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-
-        if token.typ == yaml_ALIAS_TOKEN {
-                parser.state = parser.states[len(parser.states)-1]
-                parser.states = parser.states[:len(parser.states)-1]
-                *event = yaml_event_t{
-                        typ:        yaml_ALIAS_EVENT,
-                        start_mark: token.start_mark,
-                        end_mark:   token.end_mark,
-                        anchor:     token.value,
-                }
-                skip_token(parser)
-                return true
-        }
-
-        start_mark := token.start_mark
-        end_mark := token.start_mark
-
-        var tag_token bool
-        var tag_handle, tag_suffix, anchor []byte
-        var tag_mark yaml_mark_t
-        if token.typ == yaml_ANCHOR_TOKEN {
-                anchor = token.value
-                start_mark = token.start_mark
-                end_mark = token.end_mark
-                skip_token(parser)
-                token = peek_token(parser)
-                if token == nil {
-                        return false
-                }
-                if token.typ == yaml_TAG_TOKEN {
-                        tag_token = true
-                        tag_handle = token.value
-                        tag_suffix = token.suffix
-                        tag_mark = token.start_mark
-                        end_mark = token.end_mark
-                        skip_token(parser)
-                        token = peek_token(parser)
-                        if token == nil {
-                                return false
-                        }
-                }
-        } else if token.typ == yaml_TAG_TOKEN {
-                tag_token = true
-                tag_handle = token.value
-                tag_suffix = token.suffix
-                start_mark = token.start_mark
-                tag_mark = token.start_mark
-                end_mark = token.end_mark
-                skip_token(parser)
-                token = peek_token(parser)
-                if token == nil {
-                        return false
-                }
-                if token.typ == yaml_ANCHOR_TOKEN {
-                        anchor = token.value
-                        end_mark = token.end_mark
-                        skip_token(parser)
-                        token = peek_token(parser)
-                        if token == nil {
-                                return false
-                        }
-                }
-        }
-
-        var tag []byte
-        if tag_token {
-                if len(tag_handle) == 0 {
-                        tag = tag_suffix
-                        tag_suffix = nil
-                } else {
-                        for i := range parser.tag_directives {
-                                if bytes.Equal(parser.tag_directives[i].handle, tag_handle) {
-                                        tag = append([]byte(nil), parser.tag_directives[i].prefix...)
-                                        tag = append(tag, tag_suffix...)
-                                        break
-                                }
-                        }
-                        if len(tag) == 0 {
-                                yaml_parser_set_parser_error_context(parser,
-                                        "while parsing a node", start_mark,
-                                        "found undefined tag handle", tag_mark)
-                                return false
-                        }
-                }
-        }
-
-        implicit := len(tag) == 0
-        if indentless_sequence && token.typ == yaml_BLOCK_ENTRY_TOKEN {
-                end_mark = token.end_mark
-                parser.state = yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE
-                *event = yaml_event_t{
-                        typ:        yaml_SEQUENCE_START_EVENT,
-                        start_mark: start_mark,
-                        end_mark:   end_mark,
-                        anchor:     anchor,
-                        tag:        tag,
-                        implicit:   implicit,
-                        style:      yaml_style_t(yaml_BLOCK_SEQUENCE_STYLE),
-                }
-                return true
-        }
-        if token.typ == yaml_SCALAR_TOKEN {
-                var plain_implicit, quoted_implicit bool
-                end_mark = token.end_mark
-                if (len(tag) == 0 && token.style == yaml_PLAIN_SCALAR_STYLE) || (len(tag) == 1 && tag[0] == '!') {
-                        plain_implicit = true
-                } else if len(tag) == 0 {
-                        quoted_implicit = true
-                }
-                parser.state = parser.states[len(parser.states)-1]
-                parser.states = parser.states[:len(parser.states)-1]
-
-                *event = yaml_event_t{
-                        typ:             yaml_SCALAR_EVENT,
-                        start_mark:      start_mark,
-                        end_mark:        end_mark,
-                        anchor:          anchor,
-                        tag:             tag,
-                        value:           token.value,
-                        implicit:        plain_implicit,
-                        quoted_implicit: quoted_implicit,
-                        style:           yaml_style_t(token.style),
-                }
-                skip_token(parser)
-                return true
-        }
-        if token.typ == yaml_FLOW_SEQUENCE_START_TOKEN {
-                // [Go] Some of the events below can be merged as they differ only on style.
-                end_mark = token.end_mark
-                parser.state = yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE
-                *event = yaml_event_t{
-                        typ:        yaml_SEQUENCE_START_EVENT,
-                        start_mark: start_mark,
-                        end_mark:   end_mark,
-                        anchor:     anchor,
-                        tag:        tag,
-                        implicit:   implicit,
-                        style:      yaml_style_t(yaml_FLOW_SEQUENCE_STYLE),
-                }
-                return true
-        }
-        if token.typ == yaml_FLOW_MAPPING_START_TOKEN {
-                end_mark = token.end_mark
-                parser.state = yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE
-                *event = yaml_event_t{
-                        typ:        yaml_MAPPING_START_EVENT,
-                        start_mark: start_mark,
-                        end_mark:   end_mark,
-                        anchor:     anchor,
-                        tag:        tag,
-                        implicit:   implicit,
-                        style:      yaml_style_t(yaml_FLOW_MAPPING_STYLE),
-                }
-                return true
-        }
-        if block && token.typ == yaml_BLOCK_SEQUENCE_START_TOKEN {
-                end_mark = token.end_mark
-                parser.state = yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE
-                *event = yaml_event_t{
-                        typ:        yaml_SEQUENCE_START_EVENT,
-                        start_mark: start_mark,
-                        end_mark:   end_mark,
-                        anchor:     anchor,
-                        tag:        tag,
-                        implicit:   implicit,
-                        style:      yaml_style_t(yaml_BLOCK_SEQUENCE_STYLE),
-                }
-                return true
-        }
-        if block && token.typ == yaml_BLOCK_MAPPING_START_TOKEN {
-                end_mark = token.end_mark
-                parser.state = yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE
-                *event = yaml_event_t{
-                        typ:        yaml_MAPPING_START_EVENT,
-                        start_mark: start_mark,
-                        end_mark:   end_mark,
-                        anchor:     anchor,
-                        tag:        tag,
-                        implicit:   implicit,
-                        style:      yaml_style_t(yaml_BLOCK_MAPPING_STYLE),
-                }
-                return true
-        }
-        if len(anchor) > 0 || len(tag) > 0 {
-                parser.state = parser.states[len(parser.states)-1]
-                parser.states = parser.states[:len(parser.states)-1]
-
-                *event = yaml_event_t{
-                        typ:             yaml_SCALAR_EVENT,
-                        start_mark:      start_mark,
-                        end_mark:        end_mark,
-                        anchor:          anchor,
-                        tag:             tag,
-                        implicit:        implicit,
-                        quoted_implicit: false,
-                        style:           yaml_style_t(yaml_PLAIN_SCALAR_STYLE),
-                }
-                return true
-        }
-
-        context := "while parsing a flow node"
-        if block {
-                context = "while parsing a block node"
-        }
-        yaml_parser_set_parser_error_context(parser, context, start_mark,
-                "did not find expected node content", token.start_mark)
-        return false
-}
-
-// Parse the productions:
-// block_sequence ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
-//                    ********************  *********** *             *********
-//
-func yaml_parser_parse_block_sequence_entry(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
-        if first {
-                token := peek_token(parser)
-                parser.marks = append(parser.marks, token.start_mark)
-                skip_token(parser)
-        }
-
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-
-        if token.typ == yaml_BLOCK_ENTRY_TOKEN {
-                mark := token.end_mark
-                skip_token(parser)
-                token = peek_token(parser)
-                if token == nil {
-                        return false
-                }
-                if token.typ != yaml_BLOCK_ENTRY_TOKEN && token.typ != yaml_BLOCK_END_TOKEN {
-                        parser.states = append(parser.states, yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE)
-                        return yaml_parser_parse_node(parser, event, true, false)
-                } else {
-                        parser.state = yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE
-                        return yaml_parser_process_empty_scalar(parser, event, mark)
-                }
-        }
-        if token.typ == yaml_BLOCK_END_TOKEN {
-                parser.state = parser.states[len(parser.states)-1]
-                parser.states = parser.states[:len(parser.states)-1]
-                parser.marks = parser.marks[:len(parser.marks)-1]
-
-                *event = yaml_event_t{
-                        typ:        yaml_SEQUENCE_END_EVENT,
-                        start_mark: token.start_mark,
-                        end_mark:   token.end_mark,
-                }
-
-                skip_token(parser)
-                return true
-        }
-
-        context_mark := parser.marks[len(parser.marks)-1]
-        parser.marks = parser.marks[:len(parser.marks)-1]
-        return yaml_parser_set_parser_error_context(parser,
-                "while parsing a block collection", context_mark,
-                "did not find expected '-' indicator", token.start_mark)
-}
-
-// Parse the productions:
-// indentless_sequence  ::= (BLOCK-ENTRY block_node?)+
-//                           *********** *
-func yaml_parser_parse_indentless_sequence_entry(parser *yaml_parser_t, event *yaml_event_t) bool {
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-
-        if token.typ == yaml_BLOCK_ENTRY_TOKEN {
-                mark := token.end_mark
-                skip_token(parser)
-                token = peek_token(parser)
-                if token == nil {
-                        return false
-                }
-                if token.typ != yaml_BLOCK_ENTRY_TOKEN &&
-                        token.typ != yaml_KEY_TOKEN &&
-                        token.typ != yaml_VALUE_TOKEN &&
-                        token.typ != yaml_BLOCK_END_TOKEN {
-                        parser.states = append(parser.states, yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE)
-                        return yaml_parser_parse_node(parser, event, true, false)
-                }
-                parser.state = yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE
-                return yaml_parser_process_empty_scalar(parser, event, mark)
-        }
-        parser.state = parser.states[len(parser.states)-1]
-        parser.states = parser.states[:len(parser.states)-1]
-
-        *event = yaml_event_t{
-                typ:        yaml_SEQUENCE_END_EVENT,
-                start_mark: token.start_mark,
-                end_mark:   token.start_mark, // [Go] Shouldn't this be token.end_mark?
-        }
-        return true
-}
-
-// Parse the productions:
-// block_mapping        ::= BLOCK-MAPPING_START
-//                          *******************
-//                          ((KEY block_node_or_indentless_sequence?)?
-//                            *** *
-//                          (VALUE block_node_or_indentless_sequence?)?)*
-//
-//                          BLOCK-END
-//                          *********
-//
-func yaml_parser_parse_block_mapping_key(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
-        if first {
-                token := peek_token(parser)
-                parser.marks = append(parser.marks, token.start_mark)
-                skip_token(parser)
-        }
-
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-
-        if token.typ == yaml_KEY_TOKEN {
-                mark := token.end_mark
-                skip_token(parser)
-                token = peek_token(parser)
-                if token == nil {
-                        return false
-                }
-                if token.typ != yaml_KEY_TOKEN &&
-                        token.typ != yaml_VALUE_TOKEN &&
-                        token.typ != yaml_BLOCK_END_TOKEN {
-                        parser.states = append(parser.states, yaml_PARSE_BLOCK_MAPPING_VALUE_STATE)
-                        return yaml_parser_parse_node(parser, event, true, true)
-                } else {
-                        parser.state = yaml_PARSE_BLOCK_MAPPING_VALUE_STATE
-                        return yaml_parser_process_empty_scalar(parser, event, mark)
-                }
-        } else if token.typ == yaml_BLOCK_END_TOKEN {
-                parser.state = parser.states[len(parser.states)-1]
-                parser.states = parser.states[:len(parser.states)-1]
-                parser.marks = parser.marks[:len(parser.marks)-1]
-                *event = yaml_event_t{
-                        typ:        yaml_MAPPING_END_EVENT,
-                        start_mark: token.start_mark,
-                        end_mark:   token.end_mark,
-                }
-                skip_token(parser)
-                return true
-        }
-
-        context_mark := parser.marks[len(parser.marks)-1]
-        parser.marks = parser.marks[:len(parser.marks)-1]
-        return yaml_parser_set_parser_error_context(parser,
-                "while parsing a block mapping", context_mark,
-                "did not find expected key", token.start_mark)
-}
-
-// Parse the productions:
-// block_mapping        ::= BLOCK-MAPPING_START
-//
-//                          ((KEY block_node_or_indentless_sequence?)?
-//
-//                          (VALUE block_node_or_indentless_sequence?)?)*
-//                           ***** *
-//                          BLOCK-END
-//
-//
-func yaml_parser_parse_block_mapping_value(parser *yaml_parser_t, event *yaml_event_t) bool {
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-        if token.typ == yaml_VALUE_TOKEN {
-                mark := token.end_mark
-                skip_token(parser)
-                token = peek_token(parser)
-                if token == nil {
-                        return false
-                }
-                if token.typ != yaml_KEY_TOKEN &&
-                        token.typ != yaml_VALUE_TOKEN &&
-                        token.typ != yaml_BLOCK_END_TOKEN {
-                        parser.states = append(parser.states, yaml_PARSE_BLOCK_MAPPING_KEY_STATE)
-                        return yaml_parser_parse_node(parser, event, true, true)
-                }
-                parser.state = yaml_PARSE_BLOCK_MAPPING_KEY_STATE
-                return yaml_parser_process_empty_scalar(parser, event, mark)
-        }
-        parser.state = yaml_PARSE_BLOCK_MAPPING_KEY_STATE
-        return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
-}
-
-// Parse the productions:
-// flow_sequence        ::= FLOW-SEQUENCE-START
-//                          *******************
-//                          (flow_sequence_entry FLOW-ENTRY)*
-//                           *                   **********
-//                          flow_sequence_entry?
-//                          *
-//                          FLOW-SEQUENCE-END
-//                          *****************
-// flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
-//                          *
-//
-func yaml_parser_parse_flow_sequence_entry(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
-        if first {
-                token := peek_token(parser)
-                parser.marks = append(parser.marks, token.start_mark)
-                skip_token(parser)
-        }
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-        if token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
-                if !first {
-                        if token.typ == yaml_FLOW_ENTRY_TOKEN {
-                                skip_token(parser)
-                                token = peek_token(parser)
-                                if token == nil {
-                                        return false
-                                }
-                        } else {
-                                context_mark := parser.marks[len(parser.marks)-1]
-                                parser.marks = parser.marks[:len(parser.marks)-1]
-                                return yaml_parser_set_parser_error_context(parser,
-                                        "while parsing a flow sequence", context_mark,
-                                        "did not find expected ',' or ']'", token.start_mark)
-                        }
-                }
-
-                if token.typ == yaml_KEY_TOKEN {
-                        parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE
-                        *event = yaml_event_t{
-                                typ:        yaml_MAPPING_START_EVENT,
-                                start_mark: token.start_mark,
-                                end_mark:   token.end_mark,
-                                implicit:   true,
-                                style:      yaml_style_t(yaml_FLOW_MAPPING_STYLE),
-                        }
-                        skip_token(parser)
-                        return true
-                } else if token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
-                        parser.states = append(parser.states, yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE)
-                        return yaml_parser_parse_node(parser, event, false, false)
-                }
-        }
-
-        parser.state = parser.states[len(parser.states)-1]
-        parser.states = parser.states[:len(parser.states)-1]
-        parser.marks = parser.marks[:len(parser.marks)-1]
-
-        *event = yaml_event_t{
-                typ:        yaml_SEQUENCE_END_EVENT,
-                start_mark: token.start_mark,
-                end_mark:   token.end_mark,
-        }
-
-        skip_token(parser)
-        return true
-}
-
-//
-// Parse the productions:
-// flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
-//                                      *** *
-//
-func yaml_parser_parse_flow_sequence_entry_mapping_key(parser *yaml_parser_t, event *yaml_event_t) bool {
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-        if token.typ != yaml_VALUE_TOKEN &&
-                token.typ != yaml_FLOW_ENTRY_TOKEN &&
-                token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
-                parser.states = append(parser.states, yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE)
-                return yaml_parser_parse_node(parser, event, false, false)
-        }
-        mark := token.end_mark
-        skip_token(parser)
-        parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE
-        return yaml_parser_process_empty_scalar(parser, event, mark)
-}
-
-// Parse the productions:
-// flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
-//                                                      ***** *
-//
-func yaml_parser_parse_flow_sequence_entry_mapping_value(parser *yaml_parser_t, event *yaml_event_t) bool {
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-        if token.typ == yaml_VALUE_TOKEN {
-                skip_token(parser)
-                token := peek_token(parser)
-                if token == nil {
-                        return false
-                }
-                if token.typ != yaml_FLOW_ENTRY_TOKEN && token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
-                        parser.states = append(parser.states, yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE)
-                        return yaml_parser_parse_node(parser, event, false, false)
-                }
-        }
-        parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE
-        return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
-}
-
-// Parse the productions:
-// flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
-//                                                                      *
-//
-func yaml_parser_parse_flow_sequence_entry_mapping_end(parser *yaml_parser_t, event *yaml_event_t) bool {
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-        parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE
-        *event = yaml_event_t{
-                typ:        yaml_MAPPING_END_EVENT,
-                start_mark: token.start_mark,
-                end_mark:   token.start_mark, // [Go] Shouldn't this be end_mark?
-        }
-        return true
-}
-
-// Parse the productions:
-// flow_mapping         ::= FLOW-MAPPING-START
-//                          ******************
-//                          (flow_mapping_entry FLOW-ENTRY)*
-//                           *                  **********
-//                          flow_mapping_entry?
-//                          ******************
-//                          FLOW-MAPPING-END
-//                          ****************
-// flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
-//                          *           *** *
-//
-func yaml_parser_parse_flow_mapping_key(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
-        if first {
-                token := peek_token(parser)
-                parser.marks = append(parser.marks, token.start_mark)
-                skip_token(parser)
-        }
-
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-
-        if token.typ != yaml_FLOW_MAPPING_END_TOKEN {
-                if !first {
-                        if token.typ == yaml_FLOW_ENTRY_TOKEN {
-                                skip_token(parser)
-                                token = peek_token(parser)
-                                if token == nil {
-                                        return false
-                                }
-                        } else {
-                                context_mark := parser.marks[len(parser.marks)-1]
-                                parser.marks = parser.marks[:len(parser.marks)-1]
-                                return yaml_parser_set_parser_error_context(parser,
-                                        "while parsing a flow mapping", context_mark,
-                                        "did not find expected ',' or '}'", token.start_mark)
-                        }
-                }
-
-                if token.typ == yaml_KEY_TOKEN {
-                        skip_token(parser)
-                        token = peek_token(parser)
-                        if token == nil {
-                                return false
-                        }
-                        if token.typ != yaml_VALUE_TOKEN &&
-                                token.typ != yaml_FLOW_ENTRY_TOKEN &&
-                                token.typ != yaml_FLOW_MAPPING_END_TOKEN {
-                                parser.states = append(parser.states, yaml_PARSE_FLOW_MAPPING_VALUE_STATE)
-                                return yaml_parser_parse_node(parser, event, false, false)
-                        } else {
-                                parser.state = yaml_PARSE_FLOW_MAPPING_VALUE_STATE
-                                return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
-                        }
-                } else if token.typ != yaml_FLOW_MAPPING_END_TOKEN {
-                        parser.states = append(parser.states, yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE)
-                        return yaml_parser_parse_node(parser, event, false, false)
-                }
-        }
-
-        parser.state = parser.states[len(parser.states)-1]
-        parser.states = parser.states[:len(parser.states)-1]
-        parser.marks = parser.marks[:len(parser.marks)-1]
-        *event = yaml_event_t{
-                typ:        yaml_MAPPING_END_EVENT,
-                start_mark: token.start_mark,
-                end_mark:   token.end_mark,
-        }
-        skip_token(parser)
-        return true
-}
-
-// Parse the productions:
-// flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
-//                                   *                  ***** *
-//
-func yaml_parser_parse_flow_mapping_value(parser *yaml_parser_t, event *yaml_event_t, empty bool) bool {
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-        if empty {
-                parser.state = yaml_PARSE_FLOW_MAPPING_KEY_STATE
-                return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
-        }
-        if token.typ == yaml_VALUE_TOKEN {
-                skip_token(parser)
-                token = peek_token(parser)
-                if token == nil {
-                        return false
-                }
-                if token.typ != yaml_FLOW_ENTRY_TOKEN && token.typ != yaml_FLOW_MAPPING_END_TOKEN {
-                        parser.states = append(parser.states, yaml_PARSE_FLOW_MAPPING_KEY_STATE)
-                        return yaml_parser_parse_node(parser, event, false, false)
-                }
-        }
-        parser.state = yaml_PARSE_FLOW_MAPPING_KEY_STATE
-        return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
-}
-
-// Generate an empty scalar event.
-func yaml_parser_process_empty_scalar(parser *yaml_parser_t, event *yaml_event_t, mark yaml_mark_t) bool {
-        *event = yaml_event_t{
-                typ:        yaml_SCALAR_EVENT,
-                start_mark: mark,
-                end_mark:   mark,
-                value:      nil, // Empty
-                implicit:   true,
-                style:      yaml_style_t(yaml_PLAIN_SCALAR_STYLE),
-        }
-        return true
-}
-
-var default_tag_directives = []yaml_tag_directive_t{
-        {[]byte("!"), []byte("!")},
-        {[]byte("!!"), []byte("tag:yaml.org,2002:")},
-}
-
-// Parse directives.
-func yaml_parser_process_directives(parser *yaml_parser_t,
-        version_directive_ref **yaml_version_directive_t,
-        tag_directives_ref *[]yaml_tag_directive_t) bool {
-
-        var version_directive *yaml_version_directive_t
-        var tag_directives []yaml_tag_directive_t
-
-        token := peek_token(parser)
-        if token == nil {
-                return false
-        }
-
-        for token.typ == yaml_VERSION_DIRECTIVE_TOKEN || token.typ == yaml_TAG_DIRECTIVE_TOKEN {
-                if token.typ == yaml_VERSION_DIRECTIVE_TOKEN {
-                        if version_directive != nil {
-                                yaml_parser_set_parser_error(parser,
-                                        "found duplicate %YAML directive", token.start_mark)
-                                return false
-                        }
-                        if token.major != 1 || token.minor != 1 {
-                                yaml_parser_set_parser_error(parser,
-                                        "found incompatible YAML document", token.start_mark)
-                                return false
-                        }
-                        version_directive = &yaml_version_directive_t{
-                                major: token.major,
-                                minor: token.minor,
-                        }
-                } else if token.typ == yaml_TAG_DIRECTIVE_TOKEN {
-                        value := yaml_tag_directive_t{
-                                handle: token.value,
-                                prefix: token.prefix,
-                        }
-                        if !yaml_parser_append_tag_directive(parser, value, false, token.start_mark) {
-                                return false
-                        }
-                        tag_directives = append(tag_directives, value)
-                }
-
-                skip_token(parser)
-                token = peek_token(parser)
-                if token == nil {
-                        return false
-                }
-        }
-
-        for i := range default_tag_directives {
-                if !yaml_parser_append_tag_directive(parser, default_tag_directives[i], true, token.start_mark) {
-                        return false
-                }
-        }
-
-        if version_directive_ref != nil {
-                *version_directive_ref = version_directive
-        }
-        if tag_directives_ref != nil {
-                *tag_directives_ref = tag_directives
-        }
-        return true
-}
-
-// Append a tag directive to the directives stack.
-func yaml_parser_append_tag_directive(parser *yaml_parser_t, value yaml_tag_directive_t, allow_duplicates bool, mark yaml_mark_t) bool {
-        for i := range parser.tag_directives {
-                if bytes.Equal(value.handle, parser.tag_directives[i].handle) {
-                        if allow_duplicates {
-                                return true
-                        }
-                        return yaml_parser_set_parser_error(parser, "found duplicate %TAG directive", mark)
-                }
-        }
-
-        // [Go] I suspect the copy is unnecessary. This was likely done
-        // because there was no way to track ownership of the data.
-        value_copy := yaml_tag_directive_t{
-                handle: make([]byte, len(value.handle)),
-                prefix: make([]byte, len(value.prefix)),
-        }
-        copy(value_copy.handle, value.handle)
-        copy(value_copy.prefix, value.prefix)
-        parser.tag_directives = append(parser.tag_directives, value_copy)
-        return true
-}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/readerc.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/readerc.go
deleted file mode 100644
index 13f5868..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/readerc.go
+++ /dev/null
@@ -1,391 +0,0 @@
-package yaml
-
-import (
-        "io"
-)
-
-// Set the reader error and return 0.
-func yaml_parser_set_reader_error(parser *yaml_parser_t, problem string, offset int, value int) bool {
-        parser.error = yaml_READER_ERROR
-        parser.problem = problem
-        parser.problem_offset = offset
-        parser.problem_value = value
-        return false
-}
-
-// Byte order marks.
-const (
-        bom_UTF8    = "\xef\xbb\xbf"
-        bom_UTF16LE = "\xff\xfe"
-        bom_UTF16BE = "\xfe\xff"
-)
-
-// Determine the input stream encoding by checking the BOM symbol. If no BOM is
-// found, the UTF-8 encoding is assumed. Return 1 on success, 0 on failure.
-func yaml_parser_determine_encoding(parser *yaml_parser_t) bool {
-        // Ensure that we had enough bytes in the raw buffer.
-        for !parser.eof && len(parser.raw_buffer)-parser.raw_buffer_pos < 3 {
-                if !yaml_parser_update_raw_buffer(parser) {
-                        return false
-                }
-        }
-
-        // Determine the encoding.
-        buf := parser.raw_buffer
-        pos := parser.raw_buffer_pos
-        avail := len(buf) - pos
-        if avail >= 2 && buf[pos] == bom_UTF16LE[0] && buf[pos+1] == bom_UTF16LE[1] {
-                parser.encoding = yaml_UTF16LE_ENCODING
-                parser.raw_buffer_pos += 2
-                parser.offset += 2
-        } else if avail >= 2 && buf[pos] == bom_UTF16BE[0] && buf[pos+1] == bom_UTF16BE[1] {
-                parser.encoding = yaml_UTF16BE_ENCODING
-                parser.raw_buffer_pos += 2
-                parser.offset += 2
-        } else if avail >= 3 && buf[pos] == bom_UTF8[0] && buf[pos+1] == bom_UTF8[1] && buf[pos+2] == bom_UTF8[2] {
-                parser.encoding = yaml_UTF8_ENCODING
-                parser.raw_buffer_pos += 3
-                parser.offset += 3
-        } else {
-                parser.encoding = yaml_UTF8_ENCODING
-        }
-        return true
-}
-
-// Update the raw buffer.
-func yaml_parser_update_raw_buffer(parser *yaml_parser_t) bool {
-        size_read := 0
-
-        // Return if the raw buffer is full.
-        if parser.raw_buffer_pos == 0 && len(parser.raw_buffer) == cap(parser.raw_buffer) {
-                return true
-        }
-
-        // Return on EOF.
-        if parser.eof {
-                return true
-        }
-
-        // Move the remaining bytes in the raw buffer to the beginning.
-        if parser.raw_buffer_pos > 0 && parser.raw_buffer_pos < len(parser.raw_buffer) {
-                copy(parser.raw_buffer, parser.raw_buffer[parser.raw_buffer_pos:])
-        }
-        parser.raw_buffer = parser.raw_buffer[:len(parser.raw_buffer)-parser.raw_buffer_pos]
-        parser.raw_buffer_pos = 0
-
-        // Call the read handler to fill the buffer.
-        size_read, err := parser.read_handler(parser, parser.raw_buffer[len(parser.raw_buffer):cap(parser.raw_buffer)])
-        parser.raw_buffer = parser.raw_buffer[:len(parser.raw_buffer)+size_read]
-        if err == io.EOF {
-                parser.eof = true
-        } else if err != nil {
-                return yaml_parser_set_reader_error(parser, "input error: "+err.Error(), parser.offset, -1)
-        }
-        return true
-}
-
-// Ensure that the buffer contains at least `length` characters.
-// Return true on success, false on failure.
-//
-// The length is supposed to be significantly less that the buffer size.
-func yaml_parser_update_buffer(parser *yaml_parser_t, length int) bool {
-        if parser.read_handler == nil {
-                panic("read handler must be set")
-        }
-
-        // If the EOF flag is set and the raw buffer is empty, do nothing.
-        if parser.eof && parser.raw_buffer_pos == len(parser.raw_buffer) {
-                return true
-        }
-
-        // Return if the buffer contains enough characters.
-        if parser.unread >= length {
-                return true
-        }
-
-        // Determine the input encoding if it is not known yet.
-        if parser.encoding == yaml_ANY_ENCODING {
-                if !yaml_parser_determine_encoding(parser) {
-                        return false
-                }
-        }
-
-        // Move the unread characters to the beginning of the buffer.
-        buffer_len := len(parser.buffer)
-        if parser.buffer_pos > 0 && parser.buffer_pos < buffer_len {
-                copy(parser.buffer, parser.buffer[parser.buffer_pos:])
-                buffer_len -= parser.buffer_pos
-                parser.buffer_pos = 0
-        } else if parser.buffer_pos == buffer_len {
-                buffer_len = 0
-                parser.buffer_pos = 0
-        }
-
-        // Open the whole buffer for writing, and cut it before returning.
-        parser.buffer = parser.buffer[:cap(parser.buffer)]
-
-        // Fill the buffer until it has enough characters.
-        first := true
-        for parser.unread < length {
-
-                // Fill the raw buffer if necessary.
-                if !first || parser.raw_buffer_pos == len(parser.raw_buffer) {
-                        if !yaml_parser_update_raw_buffer(parser) {
-                                parser.buffer = parser.buffer[:buffer_len]
-                                return false
-                        }
-                }
-                first = false
-
-                // Decode the raw buffer.
-        inner:
-                for parser.raw_buffer_pos != len(parser.raw_buffer) {
-                        var value rune
-                        var width int
-
-                        raw_unread := len(parser.raw_buffer) - parser.raw_buffer_pos
-
-                        // Decode the next character.
-                        switch parser.encoding {
-                        case yaml_UTF8_ENCODING:
-                                // Decode a UTF-8 character.  Check RFC 3629
-                                // (http://www.ietf.org/rfc/rfc3629.txt) for more details.
-                                //
-                                // The following table (taken from the RFC) is used for
-                                // decoding.
-                                //
-                                //    Char. number range |        UTF-8 octet sequence
-                                //      (hexadecimal)    |              (binary)
-                                //   --------------------+------------------------------------
-                                //   0000 0000-0000 007F | 0xxxxxxx
-                                //   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
-                                //   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
-                                //   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
-                                //
-                                // Additionally, the characters in the range 0xD800-0xDFFF
-                                // are prohibited as they are reserved for use with UTF-16
-                                // surrogate pairs.
-
-                                // Determine the length of the UTF-8 sequence.
-                                octet := parser.raw_buffer[parser.raw_buffer_pos]
-                                switch {
-                                case octet&0x80 == 0x00:
-                                        width = 1
-                                case octet&0xE0 == 0xC0:
-                                        width = 2
-                                case octet&0xF0 == 0xE0:
-                                        width = 3
-                                case octet&0xF8 == 0xF0:
-                                        width = 4
-                                default:
-                                        // The leading octet is invalid.
-                                        return yaml_parser_set_reader_error(parser,
-                                                "invalid leading UTF-8 octet",
-                                                parser.offset, int(octet))
-                                }
-
-                                // Check if the raw buffer contains an incomplete character.
-                                if width > raw_unread {
-                                        if parser.eof {
-                                                return yaml_parser_set_reader_error(parser,
-                                                        "incomplete UTF-8 octet sequence",
-                                                        parser.offset, -1)
-                                        }
-                                        break inner
-                                }
-
-                                // Decode the leading octet.
-                                switch {
-                                case octet&0x80 == 0x00:
-                                        value = rune(octet & 0x7F)
-                                case octet&0xE0 == 0xC0:
-                                        value = rune(octet & 0x1F)
-                                case octet&0xF0 == 0xE0:
-                                        value = rune(octet & 0x0F)
-                                case octet&0xF8 == 0xF0:
-                                        value = rune(octet & 0x07)
-                                default:
-                                        value = 0
-                                }
-
-                                // Check and decode the trailing octets.
-                                for k := 1; k < width; k++ {
-                                        octet = parser.raw_buffer[parser.raw_buffer_pos+k]
-
-                                        // Check if the octet is valid.
-                                        if (octet & 0xC0) != 0x80 {
-                                                return yaml_parser_set_reader_error(parser,
-                                                        "invalid trailing UTF-8 octet",
-                                                        parser.offset+k, int(octet))
-                                        }
-
-                                        // Decode the octet.
-                                        value = (value << 6) + rune(octet&0x3F)
-                                }
-
-                                // Check the length of the sequence against the value.
-                                switch {
-                                case width == 1:
-                                case width == 2 && value >= 0x80:
-                                case width == 3 && value >= 0x800:
-                                case width == 4 && value >= 0x10000:
-                                default:
-                                        return yaml_parser_set_reader_error(parser,
-                                                "invalid length of a UTF-8 sequence",
-                                                parser.offset, -1)
-                                }
-
-                                // Check the range of the value.
-                                if value >= 0xD800 && value <= 0xDFFF || value > 0x10FFFF {
-                                        return yaml_parser_set_reader_error(parser,
-                                                "invalid Unicode character",
-                                                parser.offset, int(value))
-                                }
-
-                        case yaml_UTF16LE_ENCODING, yaml_UTF16BE_ENCODING:
-                                var low, high int
-                                if parser.encoding == yaml_UTF16LE_ENCODING {
-                                        low, high = 0, 1
-                                } else {
-                                        high, low = 1, 0
-                                }
-
-                                // The UTF-16 encoding is not as simple as one might
-                                // naively think.  Check RFC 2781
-                                // (http://www.ietf.org/rfc/rfc2781.txt).
-                                //
-                                // Normally, two subsequent bytes describe a Unicode
-                                // character.  However a special technique (called a
-                                // surrogate pair) is used for specifying character
-                                // values larger than 0xFFFF.
-                                //
-                                // A surrogate pair consists of two pseudo-characters:
-                                //      high surrogate area (0xD800-0xDBFF)
-                                //      low surrogate area (0xDC00-0xDFFF)
-                                //
-                                // The following formulas are used for decoding
-                                // and encoding characters using surrogate pairs:
-                                //
-                                //  U  = U' + 0x10000   (0x01 00 00 <= U <= 0x10 FF FF)
-                                //  U' = yyyyyyyyyyxxxxxxxxxx   (0 <= U' <= 0x0F FF FF)
-                                //  W1 = 110110yyyyyyyyyy
-                                //  W2 = 110111xxxxxxxxxx
-                                //
-                                // where U is the character value, W1 is the high surrogate
-                                // area, W2 is the low surrogate area.
-
-                                // Check for incomplete UTF-16 character.
-                                if raw_unread < 2 {
-                                        if parser.eof {
-                                                return yaml_parser_set_reader_error(parser,
-                                                        "incomplete UTF-16 character",
-                                                        parser.offset, -1)
-                                        }
-                                        break inner
-                                }
-
-                                // Get the character.
-                                value = rune(parser.raw_buffer[parser.raw_buffer_pos+low]) +
-                                        (rune(parser.raw_buffer[parser.raw_buffer_pos+high]) << 8)
-
-                                // Check for unexpected low surrogate area.
-                                if value&0xFC00 == 0xDC00 {
-                                        return yaml_parser_set_reader_error(parser,
-                                                "unexpected low surrogate area",
-                                                parser.offset, int(value))
-                                }
-
-                                // Check for a high surrogate area.
-                                if value&0xFC00 == 0xD800 {
-                                        width = 4
-
-                                        // Check for incomplete surrogate pair.
-                                        if raw_unread < 4 {
-                                                if parser.eof {
-                                                        return yaml_parser_set_reader_error(parser,
-                                                                "incomplete UTF-16 surrogate pair",
-                                                                parser.offset, -1)
-                                                }
-                                                break inner
-                                        }
-
-                                        // Get the next character.
-                                        value2 := rune(parser.raw_buffer[parser.raw_buffer_pos+low+2]) +
-                                                (rune(parser.raw_buffer[parser.raw_buffer_pos+high+2]) << 8)
-
-                                        // Check for a low surrogate area.
-                                        if value2&0xFC00 != 0xDC00 {
-                                                return yaml_parser_set_reader_error(parser,
-                                                        "expected low surrogate area",
-                                                        parser.offset+2, int(value2))
-                                        }
-
-                                        // Generate the value of the surrogate pair.
-                                        value = 0x10000 + ((value & 0x3FF) << 10) + (value2 & 0x3FF)
-                                } else {
-                                        width = 2
-                                }
-
-                        default:
-                                panic("impossible")
-                        }
-
-                        // Check if the character is in the allowed range:
-                        //      #x9 | #xA | #xD | [#x20-#x7E]               (8 bit)
-                        //      | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD]    (16 bit)
-                        //      | [#x10000-#x10FFFF]                        (32 bit)
-                        switch {
-                        case value == 0x09:
-                        case value == 0x0A:
-                        case value == 0x0D:
-                        case value >= 0x20 && value <= 0x7E:
-                        case value == 0x85:
-                        case value >= 0xA0 && value <= 0xD7FF:
-                        case value >= 0xE000 && value <= 0xFFFD:
-                        case value >= 0x10000 && value <= 0x10FFFF:
-                        default:
-                                return yaml_parser_set_reader_error(parser,
-                                        "control characters are not allowed",
-                                        parser.offset, int(value))
-                        }
-
-                        // Move the raw pointers.
-                        parser.raw_buffer_pos += width
-                        parser.offset += width
-
-                        // Finally put the character into the buffer.
-                        if value <= 0x7F {
-                                // 0000 0000-0000 007F . 0xxxxxxx
-                                parser.buffer[buffer_len+0] = byte(value)
-                        } else if value <= 0x7FF {
-                                // 0000 0080-0000 07FF . 110xxxxx 10xxxxxx
-                                parser.buffer[buffer_len+0] = byte(0xC0 + (value >> 6))
-                                parser.buffer[buffer_len+1] = byte(0x80 + (value & 0x3F))
-                        } else if value <= 0xFFFF {
-                                // 0000 0800-0000 FFFF . 1110xxxx 10xxxxxx 10xxxxxx
-                                parser.buffer[buffer_len+0] = byte(0xE0 + (value >> 12))
-                                parser.buffer[buffer_len+1] = byte(0x80 + ((value >> 6) & 0x3F))
-                                parser.buffer[buffer_len+2] = byte(0x80 + (value & 0x3F))
-                        } else {
-                                // 0001 0000-0010 FFFF . 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
-                                parser.buffer[buffer_len+0] = byte(0xF0 + (value >> 18))
-                                parser.buffer[buffer_len+1] = byte(0x80 + ((value >> 12) & 0x3F))
-                                parser.buffer[buffer_len+2] = byte(0x80 + ((value >> 6) & 0x3F))
-                                parser.buffer[buffer_len+3] = byte(0x80 + (value & 0x3F))
-                        }
-                        buffer_len += width
-
-                        parser.unread++
-                }
-
-                // On EOF, put NUL into the buffer and return.
-                if parser.eof {
-                        parser.buffer[buffer_len] = 0
-                        buffer_len++
-                        parser.unread++
-                        break
-                }
-        }
-        parser.buffer = parser.buffer[:buffer_len]
-        return true
-}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/resolve.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/resolve.go
deleted file mode 100644
index 1f873ca..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/resolve.go
+++ /dev/null
@@ -1,203 +0,0 @@
-package yaml
-
-import (
-        "encoding/base64"
-        "math"
-        "strconv"
-        "strings"
-        "unicode/utf8"
-)
-
-type resolveMapItem struct {
-        value interface{}
-        tag   string
-}
-
-var resolveTable = make([]byte, 256)
-var resolveMap = make(map[string]resolveMapItem)
-
-func init() {
-        t := resolveTable
-        t[int('+')] = 'S' // Sign
-        t[int('-')] = 'S'
-        for _, c := range "0123456789" {
-                t[int(c)] = 'D' // Digit
-        }
-        for _, c := range "yYnNtTfFoO~" {
-                t[int(c)] = 'M' // In map
-        }
-        t[int('.')] = '.' // Float (potentially in map)
-
-        var resolveMapList = []struct {
-                v   interface{}
-                tag string
-                l   []string
-        }{
-                {true, yaml_BOOL_TAG, []string{"y", "Y", "yes", "Yes", "YES"}},
-                {true, yaml_BOOL_TAG, []string{"true", "True", "TRUE"}},
-                {true, yaml_BOOL_TAG, []string{"on", "On", "ON"}},
-                {false, yaml_BOOL_TAG, []string{"n", "N", "no", "No", "NO"}},
-                {false, yaml_BOOL_TAG, []string{"false", "False", "FALSE"}},
-                {false, yaml_BOOL_TAG, []string{"off", "Off", "OFF"}},
-                {nil, yaml_NULL_TAG, []string{"", "~", "null", "Null", "NULL"}},
-                {math.NaN(), yaml_FLOAT_TAG, []string{".nan", ".NaN", ".NAN"}},
-                {math.Inf(+1), yaml_FLOAT_TAG, []string{".inf", ".Inf", ".INF"}},
-                {math.Inf(+1), yaml_FLOAT_TAG, []string{"+.inf", "+.Inf", "+.INF"}},
-                {math.Inf(-1), yaml_FLOAT_TAG, []string{"-.inf", "-.Inf", "-.INF"}},
-                {"<<", yaml_MERGE_TAG, []string{"<<"}},
-        }
-
-        m := resolveMap
-        for _, item := range resolveMapList {
-                for _, s := range item.l {
-                        m[s] = resolveMapItem{item.v, item.tag}
-                }
-        }
-}
-
-const longTagPrefix = "tag:yaml.org,2002:"
-
-func shortTag(tag string) string {
-        // TODO This can easily be made faster and produce less garbage.
-        if strings.HasPrefix(tag, longTagPrefix) {
-                return "!!" + tag[len(longTagPrefix):]
-        }
-        return tag
-}
-
-func longTag(tag string) string {
-        if strings.HasPrefix(tag, "!!") {
-                return longTagPrefix + tag[2:]
-        }
-        return tag
-}
-
-func resolvableTag(tag string) bool {
-        switch tag {
-        case "", yaml_STR_TAG, yaml_BOOL_TAG, yaml_INT_TAG, yaml_FLOAT_TAG, yaml_NULL_TAG:
-                return true
-        }
-        return false
-}
-
-func resolve(tag string, in string) (rtag string, out interface{}) {
-        if !resolvableTag(tag) {
-                return tag, in
-        }
-
-        defer func() {
-                switch tag {
-                case "", rtag, yaml_STR_TAG, yaml_BINARY_TAG:
-                        return
-                }
-                failf("cannot decode %s `%s` as a %s", shortTag(rtag), in, shortTag(tag))
-        }()
-
-        // Any data is accepted as a !!str or !!binary.
-        // Otherwise, the prefix is enough of a hint about what it might be.
-        hint := byte('N')
-        if in != "" {
-                hint = resolveTable[in[0]]
-        }
-        if hint != 0 && tag != yaml_STR_TAG && tag != yaml_BINARY_TAG {
-                // Handle things we can lookup in a map.
-                if item, ok := resolveMap[in]; ok {
-                        return item.tag, item.value
-                }
-
-                // Base 60 floats are a bad idea, were dropped in YAML 1.2, and
-                // are purposefully unsupported here. They're still quoted on
-                // the way out for compatibility with other parser, though.
-
-                switch hint {
-                case 'M':
-                        // We've already checked the map above.
-
-                case '.':
-                        // Not in the map, so maybe a normal float.
-                        floatv, err := strconv.ParseFloat(in, 64)
-                        if err == nil {
-                                return yaml_FLOAT_TAG, floatv
-                        }
-
-                case 'D', 'S':
-                        // Int, float, or timestamp.
-                        plain := strings.Replace(in, "_", "", -1)
-                        intv, err := strconv.ParseInt(plain, 0, 64)
-                        if err == nil {
-                                if intv == int64(int(intv)) {
-                                        return yaml_INT_TAG, int(intv)
-                                } else {
-                                        return yaml_INT_TAG, intv
-                                }
-                        }
-                        uintv, err := strconv.ParseUint(plain, 0, 64)
-                        if err == nil {
-                                return yaml_INT_TAG, uintv
-                        }
-                        floatv, err := strconv.ParseFloat(plain, 64)
-                        if err == nil {
-                                return yaml_FLOAT_TAG, floatv
-                        }
-                        if strings.HasPrefix(plain, "0b") {
-                                intv, err := strconv.ParseInt(plain[2:], 2, 64)
-                                if err == nil {
-                                        if intv == int64(int(intv)) {
-                                                return yaml_INT_TAG, int(intv)
-                                        } else {
-                                                return yaml_INT_TAG, intv
-                                        }
-                                }
-                                uintv, err := strconv.ParseUint(plain[2:], 2, 64)
-                                if err == nil {
-                                        return yaml_INT_TAG, uintv
-                                }
-                        } else if strings.HasPrefix(plain, "-0b") {
-                                intv, err := strconv.ParseInt(plain[3:], 2, 64)
-                                if err == nil {
-                                        if intv == int64(int(intv)) {
-                                                return yaml_INT_TAG, -int(intv)
-                                        } else {
-                                                return yaml_INT_TAG, -intv
-                                        }
-                                }
-                        }
-                        // XXX Handle timestamps here.
-
-                default:
-                        panic("resolveTable item not yet handled: " + string(rune(hint)) + " (with " + in + ")")
-                }
-        }
-        if tag == yaml_BINARY_TAG {
-                return yaml_BINARY_TAG, in
-        }
-        if utf8.ValidString(in) {
-                return yaml_STR_TAG, in
-        }
-        return yaml_BINARY_TAG, encodeBase64(in)
-}
-
-// encodeBase64 encodes s as base64 that is broken up into multiple lines
-// as appropriate for the resulting length.
-func encodeBase64(s string) string {
-        const lineLen = 70
-        encLen := base64.StdEncoding.EncodedLen(len(s))
-        lines := encLen/lineLen + 1
-        buf := make([]byte, encLen*2+lines)
-        in := buf[0:encLen]
-        out := buf[encLen:]
-        base64.StdEncoding.Encode(in, []byte(s))
-        k := 0
-        for i := 0; i < len(in); i += lineLen {
-                j := i + lineLen
-                if j > len(in) {
-                        j = len(in)
-                }
-                k += copy(out[k:], in[i:j])
-                if lines > 1 {
-                        out[k] = '\n'
-                        k++
-                }
-        }
-        return string(out[:k])
-}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/scannerc.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/scannerc.go
deleted file mode 100644
index 9a799da..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/scannerc.go
+++ /dev/null
@@ -1,2710 +0,0 @@
-package yaml
-
-import (
-        "bytes"
-        "fmt"
-)
-
-// Introduction
-// ************
-//
-// The following notes assume that you are familiar with the YAML specification
-// (http://yaml.org/spec/cvs/current.html).  We mostly follow it, although in
-// some cases we are less restrictive that it requires.
-//
-// The process of transforming a YAML stream into a sequence of events is
-// divided on two steps: Scanning and Parsing.
-//
-// The Scanner transforms the input stream into a sequence of tokens, while the
-// parser transform the sequence of tokens produced by the Scanner into a
-// sequence of parsing events.
-//
-// The Scanner is rather clever and complicated. The Parser, on the contrary,
-// is a straightforward implementation of a recursive-descendant parser (or,
-// LL(1) parser, as it is usually called).
-//
-// Actually there are two issues of Scanning that might be called "clever", the
-// rest is quite straightforward.  The issues are "block collection start" and
-// "simple keys".  Both issues are explained below in details.
-//
-// Here the Scanning step is explained and implemented.  We start with the list
-// of all the tokens produced by the Scanner together with short descriptions.
-//
-// Now, tokens:
-//
-//      STREAM-START(encoding)          # The stream start.
-//      STREAM-END                      # The stream end.
-//      VERSION-DIRECTIVE(major,minor)  # The '%YAML' directive.
-//      TAG-DIRECTIVE(handle,prefix)    # The '%TAG' directive.
-//      DOCUMENT-START                  # '---'
-//      DOCUMENT-END                    # '...'
-//      BLOCK-SEQUENCE-START            # Indentation increase denoting a block
-//      BLOCK-MAPPING-START             # sequence or a block mapping.
-//      BLOCK-END                       # Indentation decrease.
-//      FLOW-SEQUENCE-START             # '['
-//      FLOW-SEQUENCE-END               # ']'
-//      BLOCK-SEQUENCE-START            # '{'
-//      BLOCK-SEQUENCE-END              # '}'
-//      BLOCK-ENTRY                     # '-'
-//      FLOW-ENTRY                      # ','
-//      KEY                             # '?' or nothing (simple keys).
-//      VALUE                           # ':'
-//      ALIAS(anchor)                   # '*anchor'
-//      ANCHOR(anchor)                  # '&anchor'
-//      TAG(handle,suffix)              # '!handle!suffix'
-//      SCALAR(value,style)             # A scalar.
-//
-// The following two tokens are "virtual" tokens denoting the beginning and the
-// end of the stream:
-//
-//      STREAM-START(encoding)
-//      STREAM-END
-//
-// We pass the information about the input stream encoding with the
-// STREAM-START token.
-//
-// The next two tokens are responsible for tags:
-//
-//      VERSION-DIRECTIVE(major,minor)
-//      TAG-DIRECTIVE(handle,prefix)
-//
-// Example:
-//
-//      %YAML   1.1
-//      %TAG    !   !foo
-//      %TAG    !yaml!  tag:yaml.org,2002:
-//      ---
-//
-// The correspoding sequence of tokens:
-//
-//      STREAM-START(utf-8)
-//      VERSION-DIRECTIVE(1,1)
-//      TAG-DIRECTIVE("!","!foo")
-//      TAG-DIRECTIVE("!yaml","tag:yaml.org,2002:")
-//      DOCUMENT-START
-//      STREAM-END
-//
-// Note that the VERSION-DIRECTIVE and TAG-DIRECTIVE tokens occupy a whole
-// line.
-//
-// The document start and end indicators are represented by:
-//
-//      DOCUMENT-START
-//      DOCUMENT-END
-//
-// Note that if a YAML stream contains an implicit document (without '---'
-// and '...' indicators), no DOCUMENT-START and DOCUMENT-END tokens will be
-// produced.
-//
-// In the following examples, we present whole documents together with the
-// produced tokens.
-//
-//      1. An implicit document:
-//
-//          'a scalar'
-//
-//      Tokens:
-//
-//          STREAM-START(utf-8)
-//          SCALAR("a scalar",single-quoted)
-//          STREAM-END
-//
-//      2. An explicit document:
-//
-//          ---
-//          'a scalar'
-//          ...
-//
-//      Tokens:
-//
-//          STREAM-START(utf-8)
-//          DOCUMENT-START
-//          SCALAR("a scalar",single-quoted)
-//          DOCUMENT-END
-//          STREAM-END
-//
-//      3. Several documents in a stream:
-//
-//          'a scalar'
-//          ---
-//          'another scalar'
-//          ---
-//          'yet another scalar'
-//
-//      Tokens:
-//
-//          STREAM-START(utf-8)
-//          SCALAR("a scalar",single-quoted)
-//          DOCUMENT-START
-//          SCALAR("another scalar",single-quoted)
-//          DOCUMENT-START
-//          SCALAR("yet another scalar",single-quoted)
-//          STREAM-END
-//
-// We have already introduced the SCALAR token above.  The following tokens are
-// used to describe aliases, anchors, tag, and scalars:
-//
-//      ALIAS(anchor)
-//      ANCHOR(anchor)
-//      TAG(handle,suffix)
-//      SCALAR(value,style)
-//
-// The following series of examples illustrate the usage of these tokens:
-//
-//      1. A recursive sequence:
-//
-//          &A [ *A ]
-//
-//      Tokens:
-//
-//          STREAM-START(utf-8)
-//          ANCHOR("A")
-//          FLOW-SEQUENCE-START
-//          ALIAS("A")
-//          FLOW-SEQUENCE-END
-//          STREAM-END
-//
-//      2. A tagged scalar:
-//
-//          !!float "3.14"  # A good approximation.
-//
-//      Tokens:
-//
-//          STREAM-START(utf-8)
-//          TAG("!!","float")
-//          SCALAR("3.14",double-quoted)
-//          STREAM-END
-//
-//      3. Various scalar styles:
-//
-//          --- # Implicit empty plain scalars do not produce tokens.
-//          --- a plain scalar
-//          --- 'a single-quoted scalar'
-//          --- "a double-quoted scalar"
-//          --- |-
-//            a literal scalar
-//          --- >-
-//            a folded
-//            scalar
-//
-//      Tokens:
-//
-//          STREAM-START(utf-8)
-//          DOCUMENT-START
-//          DOCUMENT-START
-//          SCALAR("a plain scalar",plain)
-//          DOCUMENT-START
-//          SCALAR("a single-quoted scalar",single-quoted)
-//          DOCUMENT-START
-//          SCALAR("a double-quoted scalar",double-quoted)
-//          DOCUMENT-START
-//          SCALAR("a literal scalar",literal)
-//          DOCUMENT-START
-//          SCALAR("a folded scalar",folded)
-//          STREAM-END
-//
-// Now it's time to review collection-related tokens. We will start with
-// flow collections:
-//
-//      FLOW-SEQUENCE-START
-//      FLOW-SEQUENCE-END
-//      FLOW-MAPPING-START
-//      FLOW-MAPPING-END
-//      FLOW-ENTRY
-//      KEY
-//      VALUE
-//
-// The tokens FLOW-SEQUENCE-START, FLOW-SEQUENCE-END, FLOW-MAPPING-START, and
-// FLOW-MAPPING-END represent the indicators '[', ']', '{', and '}'
-// correspondingly.  FLOW-ENTRY represent the ',' indicator.  Finally the
-// indicators '?' and ':', which are used for denoting mapping keys and values,
-// are represented by the KEY and VALUE tokens.
-//
-// The following examples show flow collections:
-//
-//      1. A flow sequence:
-//
-//          [item 1, item 2, item 3]
-//
-//      Tokens:
-//
-//          STREAM-START(utf-8)
-//          FLOW-SEQUENCE-START
-//          SCALAR("item 1",plain)
-//          FLOW-ENTRY
-//          SCALAR("item 2",plain)
-//          FLOW-ENTRY
-//          SCALAR("item 3",plain)
-//          FLOW-SEQUENCE-END
-//          STREAM-END
-//
-//      2. A flow mapping:
-//
-//          {
-//              a simple key: a value,  # Note that the KEY token is produced.
-//              ? a complex key: another value,
-//          }
-//
-//      Tokens:
-//
-//          STREAM-START(utf-8)
-//          FLOW-MAPPING-START
-//          KEY
-//          SCALAR("a simple key",plain)
-//          VALUE
-//          SCALAR("a value",plain)
-//          FLOW-ENTRY
-//          KEY
-//          SCALAR("a complex key",plain)
-//          VALUE
-//          SCALAR("another value",plain)
-//          FLOW-ENTRY
-//          FLOW-MAPPING-END
-//          STREAM-END
-//
-// A simple key is a key which is not denoted by the '?' indicator.  Note that
-// the Scanner still produce the KEY token whenever it encounters a simple key.
-//
-// For scanning block collections, the following tokens are used (note that we
-// repeat KEY and VALUE here):
-//
-//      BLOCK-SEQUENCE-START
-//      BLOCK-MAPPING-START
-//      BLOCK-END
-//      BLOCK-ENTRY
-//      KEY
-//      VALUE
-//
-// The tokens BLOCK-SEQUENCE-START and BLOCK-MAPPING-START denote indentation
-// increase that precedes a block collection (cf. the INDENT token in Python).
-// The token BLOCK-END denote indentation decrease that ends a block collection
-// (cf. the DEDENT token in Python).  However YAML has some syntax pecularities
-// that makes detections of these tokens more complex.
-//
-// The tokens BLOCK-ENTRY, KEY, and VALUE are used to represent the indicators
-// '-', '?', and ':' correspondingly.
-//
-// The following examples show how the tokens BLOCK-SEQUENCE-START,
-// BLOCK-MAPPING-START, and BLOCK-END are emitted by the Scanner:
-//
-//      1. Block sequences:
-//
-//          - item 1
-//          - item 2
-//          -
-//            - item 3.1
-//            - item 3.2
-//          -
-//            key 1: value 1
-//            key 2: value 2
-//
-//      Tokens:
-//
-//          STREAM-START(utf-8)
-//          BLOCK-SEQUENCE-START
-//          BLOCK-ENTRY
-//          SCALAR("item 1",plain)
-//          BLOCK-ENTRY
-//          SCALAR("item 2",plain)
-//          BLOCK-ENTRY
-//          BLOCK-SEQUENCE-START
-//          BLOCK-ENTRY
-//          SCALAR("item 3.1",plain)
-//          BLOCK-ENTRY
-//          SCALAR("item 3.2",plain)
-//          BLOCK-END
-//          BLOCK-ENTRY
-//          BLOCK-MAPPING-START
-//          KEY
-//          SCALAR("key 1",plain)
-//          VALUE
-//          SCALAR("value 1",plain)
-//          KEY
-//          SCALAR("key 2",plain)
-//          VALUE
-//          SCALAR("value 2",plain)
-//          BLOCK-END
-//          BLOCK-END
-//          STREAM-END
-//
-//      2. Block mappings:
-//
-//          a simple key: a value   # The KEY token is produced here.
-//          ? a complex key
-//          : another value
-//          a mapping:
-//            key 1: value 1
-//            key 2: value 2
-//          a sequence:
-//            - item 1
-//            - item 2
-//
-//      Tokens:
-//
-//          STREAM-START(utf-8)
-//          BLOCK-MAPPING-START
-//          KEY
-//          SCALAR("a simple key",plain)
-//          VALUE
-//          SCALAR("a value",plain)
-//          KEY
-//          SCALAR("a complex key",plain)
-//          VALUE
-//          SCALAR("another value",plain)
-//          KEY
-//          SCALAR("a mapping",plain)
-//          BLOCK-MAPPING-START
-//          KEY
-//          SCALAR("key 1",plain)
-//          VALUE
-//          SCALAR("value 1",plain)
-//          KEY
-//          SCALAR("key 2",plain)
-//          VALUE
-//          SCALAR("value 2",plain)
-//          BLOCK-END
-//          KEY
-//          SCALAR("a sequence",plain)
-//          VALUE
-//          BLOCK-SEQUENCE-START
-//          BLOCK-ENTRY
-//          SCALAR("item 1",plain)
-//          BLOCK-ENTRY
-//          SCALAR("item 2",plain)
-//          BLOCK-END
-//          BLOCK-END
-//          STREAM-END
-//
-// YAML does not always require to start a new block collection from a new
-// line.  If the current line contains only '-', '?', and ':' indicators, a new
-// block collection may start at the current line.  The following examples
-// illustrate this case:
-//
-//      1. Collections in a sequence:
-//
-//          - - item 1
-//            - item 2
-//          - key 1: value 1
-//            key 2: value 2
-//          - ? complex key
-//            : complex value
-//
-//      Tokens:
-//
-//          STREAM-START(utf-8)
-//          BLOCK-SEQUENCE-START
-//          BLOCK-ENTRY
-//          BLOCK-SEQUENCE-START
-//          BLOCK-ENTRY
-//          SCALAR("item 1",plain)
-//          BLOCK-ENTRY
-//          SCALAR("item 2",plain)
-//          BLOCK-END
-//          BLOCK-ENTRY
-//          BLOCK-MAPPING-START
-//          KEY
-//          SCALAR("key 1",plain)
-//          VALUE
-//          SCALAR("value 1",plain)
-//          KEY
-//          SCALAR("key 2",plain)
-//          VALUE
-//          SCALAR("value 2",plain)
-//          BLOCK-END
-//          BLOCK-ENTRY
-//          BLOCK-MAPPING-START
-//          KEY
-//          SCALAR("complex key")
-//          VALUE
-//          SCALAR("complex value")
-//          BLOCK-END
-//          BLOCK-END
-//          STREAM-END
-//
-//      2. Collections in a mapping:
-//
-//          ? a sequence
-//          : - item 1
-//            - item 2
-//          ? a mapping
-//          : key 1: value 1
-//            key 2: value 2
-//
-//      Tokens:
-//
-//          STREAM-START(utf-8)
-//          BLOCK-MAPPING-START
-//          KEY
-//          SCALAR("a sequence",plain)
-//          VALUE
-//          BLOCK-SEQUENCE-START
-//          BLOCK-ENTRY
-//          SCALAR("item 1",plain)
-//          BLOCK-ENTRY
-//          SCALAR("item 2",plain)
-//          BLOCK-END
-//          KEY
-//          SCALAR("a mapping",plain)
-//          VALUE
-//          BLOCK-MAPPING-START
-//          KEY
-//          SCALAR("key 1",plain)
-//          VALUE
-//          SCALAR("value 1",plain)
-//          KEY
-//          SCALAR("key 2",plain)
-//          VALUE
-//          SCALAR("value 2",plain)
-//          BLOCK-END
-//          BLOCK-END
-//          STREAM-END
-//
-// YAML also permits non-indented sequences if they are included into a block
-// mapping.  In this case, the token BLOCK-SEQUENCE-START is not produced:
-//
-//      key:
-//      - item 1    # BLOCK-SEQUENCE-START is NOT produced here.
-//      - item 2
-//
-// Tokens:
-//
-//      STREAM-START(utf-8)
-//      BLOCK-MAPPING-START
-//      KEY
-//      SCALAR("key",plain)
-//      VALUE
-//      BLOCK-ENTRY
-//      SCALAR("item 1",plain)
-//      BLOCK-ENTRY
-//      SCALAR("item 2",plain)
-//      BLOCK-END
-//
-
-// Ensure that the buffer contains the required number of characters.
-// Return true on success, false on failure (reader error or memory error).
-func cache(parser *yaml_parser_t, length int) bool {
-        // [Go] This was inlined: !cache(A, B) -> unread < B && !update(A, B)
-        return parser.unread >= length || yaml_parser_update_buffer(parser, length)
-}
-
-// Advance the buffer pointer.
-func skip(parser *yaml_parser_t) {
-        parser.mark.index++
-        parser.mark.column++
-        parser.unread--
-        parser.buffer_pos += width(parser.buffer[parser.buffer_pos])
-}
-
-func skip_line(parser *yaml_parser_t) {
-        if is_crlf(parser.buffer, parser.buffer_pos) {
-                parser.mark.index += 2
-                parser.mark.column = 0
-                parser.mark.line++
-                parser.unread -= 2
-                parser.buffer_pos += 2
-        } else if is_break(parser.buffer, parser.buffer_pos) {
-                parser.mark.index++
-                parser.mark.column = 0
-                parser.mark.line++
-                parser.unread--
-                parser.buffer_pos += width(parser.buffer[parser.buffer_pos])
-        }
-}
-
-// Copy a character to a string buffer and advance pointers.
-func read(parser *yaml_parser_t, s []byte) []byte {
-        w := width(parser.buffer[parser.buffer_pos])
-        if w == 0 {
-                panic("invalid character sequence")
-        }
-        if len(s) == 0 {
-                s = make([]byte, 0, 32)
-        }
-        if w == 1 && len(s)+w <= cap(s) {
-                s = s[:len(s)+1]
-                s[len(s)-1] = parser.buffer[parser.buffer_pos]
-                parser.buffer_pos++
-        } else {
-                s = append(s, parser.buffer[parser.buffer_pos:parser.buffer_pos+w]...)
-                parser.buffer_pos += w
-        }
-        parser.mark.index++
-        parser.mark.column++
-        parser.unread--
-        return s
-}
-
-// Copy a line break character to a string buffer and advance pointers.
-func read_line(parser *yaml_parser_t, s []byte) []byte {
-        buf := parser.buffer
-        pos := parser.buffer_pos
-        switch {
-        case buf[pos] == '\r' && buf[pos+1] == '\n':
-                // CR LF . LF
-                s = append(s, '\n')
-                parser.buffer_pos += 2
-                parser.mark.index++
-                parser.unread--
-        case buf[pos] == '\r' || buf[pos] == '\n':
-                // CR|LF . LF
-                s = append(s, '\n')
-                parser.buffer_pos += 1
-        case buf[pos] == '\xC2' && buf[pos+1] == '\x85':
-                // NEL . LF
-                s = append(s, '\n')
-                parser.buffer_pos += 2
-        case buf[pos] == '\xE2' && buf[pos+1] == '\x80' && (buf[pos+2] == '\xA8' || buf[pos+2] == '\xA9'):
-                // LS|PS . LS|PS
-                s = append(s, buf[parser.buffer_pos:pos+3]...)
-                parser.buffer_pos += 3
-        default:
-                return s
-        }
-        parser.mark.index++
-        parser.mark.column = 0
-        parser.mark.line++
-        parser.unread--
-        return s
-}
-
-// Get the next token.
-func yaml_parser_scan(parser *yaml_parser_t, token *yaml_token_t) bool {
-        // Erase the token object.
-        *token = yaml_token_t{} // [Go] Is this necessary?
-
-        // No tokens after STREAM-END or error.
-        if parser.stream_end_produced || parser.error != yaml_NO_ERROR {
-                return true
-        }
-
-        // Ensure that the tokens queue contains enough tokens.
-        if !parser.token_available {
-                if !yaml_parser_fetch_more_tokens(parser) {
-                        return false
-                }
-        }
-
-        // Fetch the next token from the queue.
-        *token = parser.tokens[parser.tokens_head]
-        parser.tokens_head++
-        parser.tokens_parsed++
-        parser.token_available = false
-
-        if token.typ == yaml_STREAM_END_TOKEN {
-                parser.stream_end_produced = true
-        }
-        return true
-}
-
-// Set the scanner error and return false.
-func yaml_parser_set_scanner_error(parser *yaml_parser_t, context string, context_mark yaml_mark_t, problem string) bool {
-        parser.error = yaml_SCANNER_ERROR
-        parser.context = context
-        parser.context_mark = context_mark
-        parser.problem = problem
-        parser.problem_mark = parser.mark
-        return false
-}
-
-func yaml_parser_set_scanner_tag_error(parser *yaml_parser_t, directive bool, context_mark yaml_mark_t, problem string) bool {
-        context := "while parsing a tag"
-        if directive {
-                context = "while parsing a %TAG directive"
-        }
-        return yaml_parser_set_scanner_error(parser, context, context_mark, "did not find URI escaped octet")
-}
-
-func trace(args ...interface{}) func() {
-        pargs := append([]interface{}{"+++"}, args...)
-        fmt.Println(pargs...)
-        pargs = append([]interface{}{"---"}, args...)
-        return func() { fmt.Println(pargs...) }
-}
-
-// Ensure that the tokens queue contains at least one token which can be
-// returned to the Parser.
-func yaml_parser_fetch_more_tokens(parser *yaml_parser_t) bool {
-        // While we need more tokens to fetch, do it.
-        for {
-                // Check if we really need to fetch more tokens.
-                need_more_tokens := false
-
-                if parser.tokens_head == len(parser.tokens) {
-                        // Queue is empty.
-                        need_more_tokens = true
-                } else {
-                        // Check if any potential simple key may occupy the head position.
-                        if !yaml_parser_stale_simple_keys(parser) {
-                                return false
-                        }
-
-                        for i := range parser.simple_keys {
-                                simple_key := &parser.simple_keys[i]
-                                if simple_key.possible && simple_key.token_number == parser.tokens_parsed {
-                                        need_more_tokens = true
-                                        break
-                                }
-                        }
-                }
-
-                // We are finished.
-                if !need_more_tokens {
-                        break
-                }
-                // Fetch the next token.
-                if !yaml_parser_fetch_next_token(parser) {
-                        return false
-                }
-        }
-
-        parser.token_available = true
-        return true
-}
-
-// The dispatcher for token fetchers.
-func yaml_parser_fetch_next_token(parser *yaml_parser_t) bool {
-        // Ensure that the buffer is initialized.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-
-        // Check if we just started scanning.  Fetch STREAM-START then.
-        if !parser.stream_start_produced {
-                return yaml_parser_fetch_stream_start(parser)
-        }
-
-        // Eat whitespaces and comments until we reach the next token.
-        if !yaml_parser_scan_to_next_token(parser) {
-                return false
-        }
-
-        // Remove obsolete potential simple keys.
-        if !yaml_parser_stale_simple_keys(parser) {
-                return false
-        }
-
-        // Check the indentation level against the current column.
-        if !yaml_parser_unroll_indent(parser, parser.mark.column) {
-                return false
-        }
-
-        // Ensure that the buffer contains at least 4 characters.  4 is the length
-        // of the longest indicators ('--- ' and '... ').
-        if parser.unread < 4 && !yaml_parser_update_buffer(parser, 4) {
-                return false
-        }
-
-        // Is it the end of the stream?
-        if is_z(parser.buffer, parser.buffer_pos) {
-                return yaml_parser_fetch_stream_end(parser)
-        }
-
-        // Is it a directive?
-        if parser.mark.column == 0 && parser.buffer[parser.buffer_pos] == '%' {
-                return yaml_parser_fetch_directive(parser)
-        }
-
-        buf := parser.buffer
-        pos := parser.buffer_pos
-
-        // Is it the document start indicator?
-        if parser.mark.column == 0 && buf[pos] == '-' && buf[pos+1] == '-' && buf[pos+2] == '-' && is_blankz(buf, pos+3) {
-                return yaml_parser_fetch_document_indicator(parser, yaml_DOCUMENT_START_TOKEN)
-        }
-
-        // Is it the document end indicator?
-        if parser.mark.column == 0 && buf[pos] == '.' && buf[pos+1] == '.' && buf[pos+2] == '.' && is_blankz(buf, pos+3) {
-                return yaml_parser_fetch_document_indicator(parser, yaml_DOCUMENT_END_TOKEN)
-        }
-
-        // Is it the flow sequence start indicator?
-        if buf[pos] == '[' {
-                return yaml_parser_fetch_flow_collection_start(parser, yaml_FLOW_SEQUENCE_START_TOKEN)
-        }
-
-        // Is it the flow mapping start indicator?
-        if parser.buffer[parser.buffer_pos] == '{' {
-                return yaml_parser_fetch_flow_collection_start(parser, yaml_FLOW_MAPPING_START_TOKEN)
-        }
-
-        // Is it the flow sequence end indicator?
-        if parser.buffer[parser.buffer_pos] == ']' {
-                return yaml_parser_fetch_flow_collection_end(parser,
-                        yaml_FLOW_SEQUENCE_END_TOKEN)
-        }
-
-        // Is it the flow mapping end indicator?
-        if parser.buffer[parser.buffer_pos] == '}' {
-                return yaml_parser_fetch_flow_collection_end(parser,
-                        yaml_FLOW_MAPPING_END_TOKEN)
-        }
-
-        // Is it the flow entry indicator?
-        if parser.buffer[parser.buffer_pos] == ',' {
-                return yaml_parser_fetch_flow_entry(parser)
-        }
-
-        // Is it the block entry indicator?
-        if parser.buffer[parser.buffer_pos] == '-' && is_blankz(parser.buffer, parser.buffer_pos+1) {
-                return yaml_parser_fetch_block_entry(parser)
-        }
-
-        // Is it the key indicator?
-        if parser.buffer[parser.buffer_pos] == '?' && (parser.flow_level > 0 || is_blankz(parser.buffer, parser.buffer_pos+1)) {
-                return yaml_parser_fetch_key(parser)
-        }
-
-        // Is it the value indicator?
-        if parser.buffer[parser.buffer_pos] == ':' && (parser.flow_level > 0 || is_blankz(parser.buffer, parser.buffer_pos+1)) {
-                return yaml_parser_fetch_value(parser)
-        }
-
-        // Is it an alias?
-        if parser.buffer[parser.buffer_pos] == '*' {
-                return yaml_parser_fetch_anchor(parser, yaml_ALIAS_TOKEN)
-        }
-
-        // Is it an anchor?
-        if parser.buffer[parser.buffer_pos] == '&' {
-                return yaml_parser_fetch_anchor(parser, yaml_ANCHOR_TOKEN)
-        }
-
-        // Is it a tag?
-        if parser.buffer[parser.buffer_pos] == '!' {
-                return yaml_parser_fetch_tag(parser)
-        }
-
-        // Is it a literal scalar?
-        if parser.buffer[parser.buffer_pos] == '|' && parser.flow_level == 0 {
-                return yaml_parser_fetch_block_scalar(parser, true)
-        }
-
-        // Is it a folded scalar?
-        if parser.buffer[parser.buffer_pos] == '>' && parser.flow_level == 0 {
-                return yaml_parser_fetch_block_scalar(parser, false)
-        }
-
-        // Is it a single-quoted scalar?
-        if parser.buffer[parser.buffer_pos] == '\'' {
-                return yaml_parser_fetch_flow_scalar(parser, true)
-        }
-
-        // Is it a double-quoted scalar?
-        if parser.buffer[parser.buffer_pos] == '"' {
-                return yaml_parser_fetch_flow_scalar(parser, false)
-        }
-
-        // Is it a plain scalar?
-        //
-        // A plain scalar may start with any non-blank characters except
-        //
-        //      '-', '?', ':', ',', '[', ']', '{', '}',
-        //      '#', '&', '*', '!', '|', '>', '\'', '\"',
-        //      '%', '@', '`'.
-        //
-        // In the block context (and, for the '-' indicator, in the flow context
-        // too), it may also start with the characters
-        //
-        //      '-', '?', ':'
-        //
-        // if it is followed by a non-space character.
-        //
-        // The last rule is more restrictive than the specification requires.
-        // [Go] Make this logic more reasonable.
-        //switch parser.buffer[parser.buffer_pos] {
-        //case '-', '?', ':', ',', '?', '-', ',', ':', ']', '[', '}', '{', '&', '#', '!', '*', '>', '|', '"', '\'', '@', '%', '-', '`':
-        //}
-        if !(is_blankz(parser.buffer, parser.buffer_pos) || parser.buffer[parser.buffer_pos] == '-' ||
-                parser.buffer[parser.buffer_pos] == '?' || parser.buffer[parser.buffer_pos] == ':' ||
-                parser.buffer[parser.buffer_pos] == ',' || parser.buffer[parser.buffer_pos] == '[' ||
-                parser.buffer[parser.buffer_pos] == ']' || parser.buffer[parser.buffer_pos] == '{' ||
-                parser.buffer[parser.buffer_pos] == '}' || parser.buffer[parser.buffer_pos] == '#' ||
-                parser.buffer[parser.buffer_pos] == '&' || parser.buffer[parser.buffer_pos] == '*' ||
-                parser.buffer[parser.buffer_pos] == '!' || parser.buffer[parser.buffer_pos] == '|' ||
-                parser.buffer[parser.buffer_pos] == '>' || parser.buffer[parser.buffer_pos] == '\'' ||
-                parser.buffer[parser.buffer_pos] == '"' || parser.buffer[parser.buffer_pos] == '%' ||
-                parser.buffer[parser.buffer_pos] == '@' || parser.buffer[parser.buffer_pos] == '`') ||
-                (parser.buffer[parser.buffer_pos] == '-' && !is_blank(parser.buffer, parser.buffer_pos+1)) ||
-                (parser.flow_level == 0 &&
-                        (parser.buffer[parser.buffer_pos] == '?' || parser.buffer[parser.buffer_pos] == ':') &&
-                        !is_blankz(parser.buffer, parser.buffer_pos+1)) {
-                return yaml_parser_fetch_plain_scalar(parser)
-        }
-
-        // If we don't determine the token type so far, it is an error.
-        return yaml_parser_set_scanner_error(parser,
-                "while scanning for the next token", parser.mark,
-                "found character that cannot start any token")
-}
-
-// Check the list of potential simple keys and remove the positions that
-// cannot contain simple keys anymore.
-func yaml_parser_stale_simple_keys(parser *yaml_parser_t) bool {
-        // Check for a potential simple key for each flow level.
-        for i := range parser.simple_keys {
-                simple_key := &parser.simple_keys[i]
-
-                // The specification requires that a simple key
-                //
-                //  - is limited to a single line,
-                //  - is shorter than 1024 characters.
-                if simple_key.possible && (simple_key.mark.line < parser.mark.line || simple_key.mark.index+1024 < parser.mark.index) {
-
-                        // Check if the potential simple key to be removed is required.
-                        if simple_key.required {
-                                return yaml_parser_set_scanner_error(parser,
-                                        "while scanning a simple key", simple_key.mark,
-                                        "could not find expected ':'")
-                        }
-                        simple_key.possible = false
-                }
-        }
-        return true
-}
-
-// Check if a simple key may start at the current position and add it if
-// needed.
-func yaml_parser_save_simple_key(parser *yaml_parser_t) bool {
-        // A simple key is required at the current position if the scanner is in
-        // the block context and the current column coincides with the indentation
-        // level.
-
-        required := parser.flow_level == 0 && parser.indent == parser.mark.column
-
-        // A simple key is required only when it is the first token in the current
-        // line.  Therefore it is always allowed.  But we add a check anyway.
-        if required && !parser.simple_key_allowed {
-                panic("should not happen")
-        }
-
-        //
-        // If the current position may start a simple key, save it.
-        //
-        if parser.simple_key_allowed {
-                simple_key := yaml_simple_key_t{
-                        possible:     true,
-                        required:     required,
-                        token_number: parser.tokens_parsed + (len(parser.tokens) - parser.tokens_head),
-                }
-                simple_key.mark = parser.mark
-
-                if !yaml_parser_remove_simple_key(parser) {
-                        return false
-                }
-                parser.simple_keys[len(parser.simple_keys)-1] = simple_key
-        }
-        return true
-}
-
-// Remove a potential simple key at the current flow level.
-func yaml_parser_remove_simple_key(parser *yaml_parser_t) bool {
-        i := len(parser.simple_keys) - 1
-        if parser.simple_keys[i].possible {
-                // If the key is required, it is an error.
-                if parser.simple_keys[i].required {
-                        return yaml_parser_set_scanner_error(parser,
-                                "while scanning a simple key", parser.simple_keys[i].mark,
-                                "could not find expected ':'")
-                }
-        }
-        // Remove the key from the stack.
-        parser.simple_keys[i].possible = false
-        return true
-}
-
-// Increase the flow level and resize the simple key list if needed.
-func yaml_parser_increase_flow_level(parser *yaml_parser_t) bool {
-        // Reset the simple key on the next level.
-        parser.simple_keys = append(parser.simple_keys, yaml_simple_key_t{})
-
-        // Increase the flow level.
-        parser.flow_level++
-        return true
-}
-
-// Decrease the flow level.
-func yaml_parser_decrease_flow_level(parser *yaml_parser_t) bool {
-        if parser.flow_level > 0 {
-                parser.flow_level--
-                parser.simple_keys = parser.simple_keys[:len(parser.simple_keys)-1]
-        }
-        return true
-}
-
-// Push the current indentation level to the stack and set the new level
-// the current column is greater than the indentation level.  In this case,
-// append or insert the specified token into the token queue.
-func yaml_parser_roll_indent(parser *yaml_parser_t, column, number int, typ yaml_token_type_t, mark yaml_mark_t) bool {
-        // In the flow context, do nothing.
-        if parser.flow_level > 0 {
-                return true
-        }
-
-        if parser.indent < column {
-                // Push the current indentation level to the stack and set the new
-                // indentation level.
-                parser.indents = append(parser.indents, parser.indent)
-                parser.indent = column
-
-                // Create a token and insert it into the queue.
-                token := yaml_token_t{
-                        typ:        typ,
-                        start_mark: mark,
-                        end_mark:   mark,
-                }
-                if number > -1 {
-                        number -= parser.tokens_parsed
-                }
-                yaml_insert_token(parser, number, &token)
-        }
-        return true
-}
-
-// Pop indentation levels from the indents stack until the current level
-// becomes less or equal to the column.  For each intendation level, append
-// the BLOCK-END token.
-func yaml_parser_unroll_indent(parser *yaml_parser_t, column int) bool {
-        // In the flow context, do nothing.
-        if parser.flow_level > 0 {
-                return true
-        }
-
-        // Loop through the intendation levels in the stack.
-        for parser.indent > column {
-                // Create a token and append it to the queue.
-                token := yaml_token_t{
-                        typ:        yaml_BLOCK_END_TOKEN,
-                        start_mark: parser.mark,
-                        end_mark:   parser.mark,
-                }
-                yaml_insert_token(parser, -1, &token)
-
-                // Pop the indentation level.
-                parser.indent = parser.indents[len(parser.indents)-1]
-                parser.indents = parser.indents[:len(parser.indents)-1]
-        }
-        return true
-}
-
-// Initialize the scanner and produce the STREAM-START token.
-func yaml_parser_fetch_stream_start(parser *yaml_parser_t) bool {
-
-        // Set the initial indentation.
-        parser.indent = -1
-
-        // Initialize the simple key stack.
-        parser.simple_keys = append(parser.simple_keys, yaml_simple_key_t{})
-
-        // A simple key is allowed at the beginning of the stream.
-        parser.simple_key_allowed = true
-
-        // We have started.
-        parser.stream_start_produced = true
-
-        // Create the STREAM-START token and append it to the queue.
-        token := yaml_token_t{
-                typ:        yaml_STREAM_START_TOKEN,
-                start_mark: parser.mark,
-                end_mark:   parser.mark,
-                encoding:   parser.encoding,
-        }
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce the STREAM-END token and shut down the scanner.
-func yaml_parser_fetch_stream_end(parser *yaml_parser_t) bool {
-
-        // Force new line.
-        if parser.mark.column != 0 {
-                parser.mark.column = 0
-                parser.mark.line++
-        }
-
-        // Reset the indentation level.
-        if !yaml_parser_unroll_indent(parser, -1) {
-                return false
-        }
-
-        // Reset simple keys.
-        if !yaml_parser_remove_simple_key(parser) {
-                return false
-        }
-
-        parser.simple_key_allowed = false
-
-        // Create the STREAM-END token and append it to the queue.
-        token := yaml_token_t{
-                typ:        yaml_STREAM_END_TOKEN,
-                start_mark: parser.mark,
-                end_mark:   parser.mark,
-        }
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce a VERSION-DIRECTIVE or TAG-DIRECTIVE token.
-func yaml_parser_fetch_directive(parser *yaml_parser_t) bool {
-        // Reset the indentation level.
-        if !yaml_parser_unroll_indent(parser, -1) {
-                return false
-        }
-
-        // Reset simple keys.
-        if !yaml_parser_remove_simple_key(parser) {
-                return false
-        }
-
-        parser.simple_key_allowed = false
-
-        // Create the YAML-DIRECTIVE or TAG-DIRECTIVE token.
-        token := yaml_token_t{}
-        if !yaml_parser_scan_directive(parser, &token) {
-                return false
-        }
-        // Append the token to the queue.
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce the DOCUMENT-START or DOCUMENT-END token.
-func yaml_parser_fetch_document_indicator(parser *yaml_parser_t, typ yaml_token_type_t) bool {
-        // Reset the indentation level.
-        if !yaml_parser_unroll_indent(parser, -1) {
-                return false
-        }
-
-        // Reset simple keys.
-        if !yaml_parser_remove_simple_key(parser) {
-                return false
-        }
-
-        parser.simple_key_allowed = false
-
-        // Consume the token.
-        start_mark := parser.mark
-
-        skip(parser)
-        skip(parser)
-        skip(parser)
-
-        end_mark := parser.mark
-
-        // Create the DOCUMENT-START or DOCUMENT-END token.
-        token := yaml_token_t{
-                typ:        typ,
-                start_mark: start_mark,
-                end_mark:   end_mark,
-        }
-        // Append the token to the queue.
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce the FLOW-SEQUENCE-START or FLOW-MAPPING-START token.
-func yaml_parser_fetch_flow_collection_start(parser *yaml_parser_t, typ yaml_token_type_t) bool {
-        // The indicators '[' and '{' may start a simple key.
-        if !yaml_parser_save_simple_key(parser) {
-                return false
-        }
-
-        // Increase the flow level.
-        if !yaml_parser_increase_flow_level(parser) {
-                return false
-        }
-
-        // A simple key may follow the indicators '[' and '{'.
-        parser.simple_key_allowed = true
-
-        // Consume the token.
-        start_mark := parser.mark
-        skip(parser)
-        end_mark := parser.mark
-
-        // Create the FLOW-SEQUENCE-START of FLOW-MAPPING-START token.
-        token := yaml_token_t{
-                typ:        typ,
-                start_mark: start_mark,
-                end_mark:   end_mark,
-        }
-        // Append the token to the queue.
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce the FLOW-SEQUENCE-END or FLOW-MAPPING-END token.
-func yaml_parser_fetch_flow_collection_end(parser *yaml_parser_t, typ yaml_token_type_t) bool {
-        // Reset any potential simple key on the current flow level.
-        if !yaml_parser_remove_simple_key(parser) {
-                return false
-        }
-
-        // Decrease the flow level.
-        if !yaml_parser_decrease_flow_level(parser) {
-                return false
-        }
-
-        // No simple keys after the indicators ']' and '}'.
-        parser.simple_key_allowed = false
-
-        // Consume the token.
-
-        start_mark := parser.mark
-        skip(parser)
-        end_mark := parser.mark
-
-        // Create the FLOW-SEQUENCE-END of FLOW-MAPPING-END token.
-        token := yaml_token_t{
-                typ:        typ,
-                start_mark: start_mark,
-                end_mark:   end_mark,
-        }
-        // Append the token to the queue.
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce the FLOW-ENTRY token.
-func yaml_parser_fetch_flow_entry(parser *yaml_parser_t) bool {
-        // Reset any potential simple keys on the current flow level.
-        if !yaml_parser_remove_simple_key(parser) {
-                return false
-        }
-
-        // Simple keys are allowed after ','.
-        parser.simple_key_allowed = true
-
-        // Consume the token.
-        start_mark := parser.mark
-        skip(parser)
-        end_mark := parser.mark
-
-        // Create the FLOW-ENTRY token and append it to the queue.
-        token := yaml_token_t{
-                typ:        yaml_FLOW_ENTRY_TOKEN,
-                start_mark: start_mark,
-                end_mark:   end_mark,
-        }
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce the BLOCK-ENTRY token.
-func yaml_parser_fetch_block_entry(parser *yaml_parser_t) bool {
-        // Check if the scanner is in the block context.
-        if parser.flow_level == 0 {
-                // Check if we are allowed to start a new entry.
-                if !parser.simple_key_allowed {
-                        return yaml_parser_set_scanner_error(parser, "", parser.mark,
-                                "block sequence entries are not allowed in this context")
-                }
-                // Add the BLOCK-SEQUENCE-START token if needed.
-                if !yaml_parser_roll_indent(parser, parser.mark.column, -1, yaml_BLOCK_SEQUENCE_START_TOKEN, parser.mark) {
-                        return false
-                }
-        } else {
-                // It is an error for the '-' indicator to occur in the flow context,
-                // but we let the Parser detect and report about it because the Parser
-                // is able to point to the context.
-        }
-
-        // Reset any potential simple keys on the current flow level.
-        if !yaml_parser_remove_simple_key(parser) {
-                return false
-        }
-
-        // Simple keys are allowed after '-'.
-        parser.simple_key_allowed = true
-
-        // Consume the token.
-        start_mark := parser.mark
-        skip(parser)
-        end_mark := parser.mark
-
-        // Create the BLOCK-ENTRY token and append it to the queue.
-        token := yaml_token_t{
-                typ:        yaml_BLOCK_ENTRY_TOKEN,
-                start_mark: start_mark,
-                end_mark:   end_mark,
-        }
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce the KEY token.
-func yaml_parser_fetch_key(parser *yaml_parser_t) bool {
-
-        // In the block context, additional checks are required.
-        if parser.flow_level == 0 {
-                // Check if we are allowed to start a new key (not nessesary simple).
-                if !parser.simple_key_allowed {
-                        return yaml_parser_set_scanner_error(parser, "", parser.mark,
-                                "mapping keys are not allowed in this context")
-                }
-                // Add the BLOCK-MAPPING-START token if needed.
-                if !yaml_parser_roll_indent(parser, parser.mark.column, -1, yaml_BLOCK_MAPPING_START_TOKEN, parser.mark) {
-                        return false
-                }
-        }
-
-        // Reset any potential simple keys on the current flow level.
-        if !yaml_parser_remove_simple_key(parser) {
-                return false
-        }
-
-        // Simple keys are allowed after '?' in the block context.
-        parser.simple_key_allowed = parser.flow_level == 0
-
-        // Consume the token.
-        start_mark := parser.mark
-        skip(parser)
-        end_mark := parser.mark
-
-        // Create the KEY token and append it to the queue.
-        token := yaml_token_t{
-                typ:        yaml_KEY_TOKEN,
-                start_mark: start_mark,
-                end_mark:   end_mark,
-        }
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce the VALUE token.
-func yaml_parser_fetch_value(parser *yaml_parser_t) bool {
-
-        simple_key := &parser.simple_keys[len(parser.simple_keys)-1]
-
-        // Have we found a simple key?
-        if simple_key.possible {
-                // Create the KEY token and insert it into the queue.
-                token := yaml_token_t{
-                        typ:        yaml_KEY_TOKEN,
-                        start_mark: simple_key.mark,
-                        end_mark:   simple_key.mark,
-                }
-                yaml_insert_token(parser, simple_key.token_number-parser.tokens_parsed, &token)
-
-                // In the block context, we may need to add the BLOCK-MAPPING-START token.
-                if !yaml_parser_roll_indent(parser, simple_key.mark.column,
-                        simple_key.token_number,
-                        yaml_BLOCK_MAPPING_START_TOKEN, simple_key.mark) {
-                        return false
-                }
-
-                // Remove the simple key.
-                simple_key.possible = false
-
-                // A simple key cannot follow another simple key.
-                parser.simple_key_allowed = false
-
-        } else {
-                // The ':' indicator follows a complex key.
-
-                // In the block context, extra checks are required.
-                if parser.flow_level == 0 {
-
-                        // Check if we are allowed to start a complex value.
-                        if !parser.simple_key_allowed {
-                                return yaml_parser_set_scanner_error(parser, "", parser.mark,
-                                        "mapping values are not allowed in this context")
-                        }
-
-                        // Add the BLOCK-MAPPING-START token if needed.
-                        if !yaml_parser_roll_indent(parser, parser.mark.column, -1, yaml_BLOCK_MAPPING_START_TOKEN, parser.mark) {
-                                return false
-                        }
-                }
-
-                // Simple keys after ':' are allowed in the block context.
-                parser.simple_key_allowed = parser.flow_level == 0
-        }
-
-        // Consume the token.
-        start_mark := parser.mark
-        skip(parser)
-        end_mark := parser.mark
-
-        // Create the VALUE token and append it to the queue.
-        token := yaml_token_t{
-                typ:        yaml_VALUE_TOKEN,
-                start_mark: start_mark,
-                end_mark:   end_mark,
-        }
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce the ALIAS or ANCHOR token.
-func yaml_parser_fetch_anchor(parser *yaml_parser_t, typ yaml_token_type_t) bool {
-        // An anchor or an alias could be a simple key.
-        if !yaml_parser_save_simple_key(parser) {
-                return false
-        }
-
-        // A simple key cannot follow an anchor or an alias.
-        parser.simple_key_allowed = false
-
-        // Create the ALIAS or ANCHOR token and append it to the queue.
-        var token yaml_token_t
-        if !yaml_parser_scan_anchor(parser, &token, typ) {
-                return false
-        }
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce the TAG token.
-func yaml_parser_fetch_tag(parser *yaml_parser_t) bool {
-        // A tag could be a simple key.
-        if !yaml_parser_save_simple_key(parser) {
-                return false
-        }
-
-        // A simple key cannot follow a tag.
-        parser.simple_key_allowed = false
-
-        // Create the TAG token and append it to the queue.
-        var token yaml_token_t
-        if !yaml_parser_scan_tag(parser, &token) {
-                return false
-        }
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce the SCALAR(...,literal) or SCALAR(...,folded) tokens.
-func yaml_parser_fetch_block_scalar(parser *yaml_parser_t, literal bool) bool {
-        // Remove any potential simple keys.
-        if !yaml_parser_remove_simple_key(parser) {
-                return false
-        }
-
-        // A simple key may follow a block scalar.
-        parser.simple_key_allowed = true
-
-        // Create the SCALAR token and append it to the queue.
-        var token yaml_token_t
-        if !yaml_parser_scan_block_scalar(parser, &token, literal) {
-                return false
-        }
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce the SCALAR(...,single-quoted) or SCALAR(...,double-quoted) tokens.
-func yaml_parser_fetch_flow_scalar(parser *yaml_parser_t, single bool) bool {
-        // A plain scalar could be a simple key.
-        if !yaml_parser_save_simple_key(parser) {
-                return false
-        }
-
-        // A simple key cannot follow a flow scalar.
-        parser.simple_key_allowed = false
-
-        // Create the SCALAR token and append it to the queue.
-        var token yaml_token_t
-        if !yaml_parser_scan_flow_scalar(parser, &token, single) {
-                return false
-        }
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Produce the SCALAR(...,plain) token.
-func yaml_parser_fetch_plain_scalar(parser *yaml_parser_t) bool {
-        // A plain scalar could be a simple key.
-        if !yaml_parser_save_simple_key(parser) {
-                return false
-        }
-
-        // A simple key cannot follow a flow scalar.
-        parser.simple_key_allowed = false
-
-        // Create the SCALAR token and append it to the queue.
-        var token yaml_token_t
-        if !yaml_parser_scan_plain_scalar(parser, &token) {
-                return false
-        }
-        yaml_insert_token(parser, -1, &token)
-        return true
-}
-
-// Eat whitespaces and comments until the next token is found.
-func yaml_parser_scan_to_next_token(parser *yaml_parser_t) bool {
-
-        // Until the next token is not found.
-        for {
-                // Allow the BOM mark to start a line.
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-                if parser.mark.column == 0 && is_bom(parser.buffer, parser.buffer_pos) {
-                        skip(parser)
-                }
-
-                // Eat whitespaces.
-                // Tabs are allowed:
-                //  - in the flow context
-                //  - in the block context, but not at the beginning of the line or
-                //  after '-', '?', or ':' (complex value).
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-
-                for parser.buffer[parser.buffer_pos] == ' ' || ((parser.flow_level > 0 || !parser.simple_key_allowed) && parser.buffer[parser.buffer_pos] == '\t') {
-                        skip(parser)
-                        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                                return false
-                        }
-                }
-
-                // Eat a comment until a line break.
-                if parser.buffer[parser.buffer_pos] == '#' {
-                        for !is_breakz(parser.buffer, parser.buffer_pos) {
-                                skip(parser)
-                                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                                        return false
-                                }
-                        }
-                }
-
-                // If it is a line break, eat it.
-                if is_break(parser.buffer, parser.buffer_pos) {
-                        if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
-                                return false
-                        }
-                        skip_line(parser)
-
-                        // In the block context, a new line may start a simple key.
-                        if parser.flow_level == 0 {
-                                parser.simple_key_allowed = true
-                        }
-                } else {
-                        break // We have found a token.
-                }
-        }
-
-        return true
-}
-
-// Scan a YAML-DIRECTIVE or TAG-DIRECTIVE token.
-//
-// Scope:
-//      %YAML    1.1    # a comment \n
-//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-//      %TAG    !yaml!  tag:yaml.org,2002:  \n
-//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-//
-func yaml_parser_scan_directive(parser *yaml_parser_t, token *yaml_token_t) bool {
-        // Eat '%'.
-        start_mark := parser.mark
-        skip(parser)
-
-        // Scan the directive name.
-        var name []byte
-        if !yaml_parser_scan_directive_name(parser, start_mark, &name) {
-                return false
-        }
-
-        // Is it a YAML directive?
-        if bytes.Equal(name, []byte("YAML")) {
-                // Scan the VERSION directive value.
-                var major, minor int8
-                if !yaml_parser_scan_version_directive_value(parser, start_mark, &major, &minor) {
-                        return false
-                }
-                end_mark := parser.mark
-
-                // Create a VERSION-DIRECTIVE token.
-                *token = yaml_token_t{
-                        typ:        yaml_VERSION_DIRECTIVE_TOKEN,
-                        start_mark: start_mark,
-                        end_mark:   end_mark,
-                        major:      major,
-                        minor:      minor,
-                }
-
-                // Is it a TAG directive?
-        } else if bytes.Equal(name, []byte("TAG")) {
-                // Scan the TAG directive value.
-                var handle, prefix []byte
-                if !yaml_parser_scan_tag_directive_value(parser, start_mark, &handle, &prefix) {
-                        return false
-                }
-                end_mark := parser.mark
-
-                // Create a TAG-DIRECTIVE token.
-                *token = yaml_token_t{
-                        typ:        yaml_TAG_DIRECTIVE_TOKEN,
-                        start_mark: start_mark,
-                        end_mark:   end_mark,
-                        value:      handle,
-                        prefix:     prefix,
-                }
-
-                // Unknown directive.
-        } else {
-                yaml_parser_set_scanner_error(parser, "while scanning a directive",
-                        start_mark, "found uknown directive name")
-                return false
-        }
-
-        // Eat the rest of the line including any comments.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-
-        for is_blank(parser.buffer, parser.buffer_pos) {
-                skip(parser)
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-        }
-
-        if parser.buffer[parser.buffer_pos] == '#' {
-                for !is_breakz(parser.buffer, parser.buffer_pos) {
-                        skip(parser)
-                        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                                return false
-                        }
-                }
-        }
-
-        // Check if we are at the end of the line.
-        if !is_breakz(parser.buffer, parser.buffer_pos) {
-                yaml_parser_set_scanner_error(parser, "while scanning a directive",
-                        start_mark, "did not find expected comment or line break")
-                return false
-        }
-
-        // Eat a line break.
-        if is_break(parser.buffer, parser.buffer_pos) {
-                if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
-                        return false
-                }
-                skip_line(parser)
-        }
-
-        return true
-}
-
-// Scan the directive name.
-//
-// Scope:
-//      %YAML   1.1     # a comment \n
-//       ^^^^
-//      %TAG    !yaml!  tag:yaml.org,2002:  \n
-//       ^^^
-//
-func yaml_parser_scan_directive_name(parser *yaml_parser_t, start_mark yaml_mark_t, name *[]byte) bool {
-        // Consume the directive name.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-
-        var s []byte
-        for is_alpha(parser.buffer, parser.buffer_pos) {
-                s = read(parser, s)
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-        }
-
-        // Check if the name is empty.
-        if len(s) == 0 {
-                yaml_parser_set_scanner_error(parser, "while scanning a directive",
-                        start_mark, "could not find expected directive name")
-                return false
-        }
-
-        // Check for an blank character after the name.
-        if !is_blankz(parser.buffer, parser.buffer_pos) {
-                yaml_parser_set_scanner_error(parser, "while scanning a directive",
-                        start_mark, "found unexpected non-alphabetical character")
-                return false
-        }
-        *name = s
-        return true
-}
-
-// Scan the value of VERSION-DIRECTIVE.
-//
-// Scope:
-//      %YAML   1.1     # a comment \n
-//           ^^^^^^
-func yaml_parser_scan_version_directive_value(parser *yaml_parser_t, start_mark yaml_mark_t, major, minor *int8) bool {
-        // Eat whitespaces.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-        for is_blank(parser.buffer, parser.buffer_pos) {
-                skip(parser)
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-        }
-
-        // Consume the major version number.
-        if !yaml_parser_scan_version_directive_number(parser, start_mark, major) {
-                return false
-        }
-
-        // Eat '.'.
-        if parser.buffer[parser.buffer_pos] != '.' {
-                return yaml_parser_set_scanner_error(parser, "while scanning a %YAML directive",
-                        start_mark, "did not find expected digit or '.' character")
-        }
-
-        skip(parser)
-
-        // Consume the minor version number.
-        if !yaml_parser_scan_version_directive_number(parser, start_mark, minor) {
-                return false
-        }
-        return true
-}
-
-const max_number_length = 2
-
-// Scan the version number of VERSION-DIRECTIVE.
-//
-// Scope:
-//      %YAML   1.1     # a comment \n
-//              ^
-//      %YAML   1.1     # a comment \n
-//                ^
-func yaml_parser_scan_version_directive_number(parser *yaml_parser_t, start_mark yaml_mark_t, number *int8) bool {
-
-        // Repeat while the next character is digit.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-        var value, length int8
-        for is_digit(parser.buffer, parser.buffer_pos) {
-                // Check if the number is too long.
-                length++
-                if length > max_number_length {
-                        return yaml_parser_set_scanner_error(parser, "while scanning a %YAML directive",
-                                start_mark, "found extremely long version number")
-                }
-                value = value*10 + int8(as_digit(parser.buffer, parser.buffer_pos))
-                skip(parser)
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-        }
-
-        // Check if the number was present.
-        if length == 0 {
-                return yaml_parser_set_scanner_error(parser, "while scanning a %YAML directive",
-                        start_mark, "did not find expected version number")
-        }
-        *number = value
-        return true
-}
-
-// Scan the value of a TAG-DIRECTIVE token.
-//
-// Scope:
-//      %TAG    !yaml!  tag:yaml.org,2002:  \n
-//          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-//
-func yaml_parser_scan_tag_directive_value(parser *yaml_parser_t, start_mark yaml_mark_t, handle, prefix *[]byte) bool {
-        var handle_value, prefix_value []byte
-
-        // Eat whitespaces.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-
-        for is_blank(parser.buffer, parser.buffer_pos) {
-                skip(parser)
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-        }
-
-        // Scan a handle.
-        if !yaml_parser_scan_tag_handle(parser, true, start_mark, &handle_value) {
-                return false
-        }
-
-        // Expect a whitespace.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-        if !is_blank(parser.buffer, parser.buffer_pos) {
-                yaml_parser_set_scanner_error(parser, "while scanning a %TAG directive",
-                        start_mark, "did not find expected whitespace")
-                return false
-        }
-
-        // Eat whitespaces.
-        for is_blank(parser.buffer, parser.buffer_pos) {
-                skip(parser)
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-        }
-
-        // Scan a prefix.
-        if !yaml_parser_scan_tag_uri(parser, true, nil, start_mark, &prefix_value) {
-                return false
-        }
-
-        // Expect a whitespace or line break.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-        if !is_blankz(parser.buffer, parser.buffer_pos) {
-                yaml_parser_set_scanner_error(parser, "while scanning a %TAG directive",
-                        start_mark, "did not find expected whitespace or line break")
-                return false
-        }
-
-        *handle = handle_value
-        *prefix = prefix_value
-        return true
-}
-
-func yaml_parser_scan_anchor(parser *yaml_parser_t, token *yaml_token_t, typ yaml_token_type_t) bool {
-        var s []byte
-
-        // Eat the indicator character.
-        start_mark := parser.mark
-        skip(parser)
-
-        // Consume the value.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-
-        for is_alpha(parser.buffer, parser.buffer_pos) {
-                s = read(parser, s)
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-        }
-
-        end_mark := parser.mark
-
-        /*
-         * Check if length of the anchor is greater than 0 and it is followed by
-         * a whitespace character or one of the indicators:
-         *
-         *      '?', ':', ',', ']', '}', '%', '@', '`'.
-         */
-
-        if len(s) == 0 ||
-                !(is_blankz(parser.buffer, parser.buffer_pos) || parser.buffer[parser.buffer_pos] == '?' ||
-                        parser.buffer[parser.buffer_pos] == ':' || parser.buffer[parser.buffer_pos] == ',' ||
-                        parser.buffer[parser.buffer_pos] == ']' || parser.buffer[parser.buffer_pos] == '}' ||
-                        parser.buffer[parser.buffer_pos] == '%' || parser.buffer[parser.buffer_pos] == '@' ||
-                        parser.buffer[parser.buffer_pos] == '`') {
-                context := "while scanning an alias"
-                if typ == yaml_ANCHOR_TOKEN {
-                        context = "while scanning an anchor"
-                }
-                yaml_parser_set_scanner_error(parser, context, start_mark,
-                        "did not find expected alphabetic or numeric character")
-                return false
-        }
-
-        // Create a token.
-        *token = yaml_token_t{
-                typ:        typ,
-                start_mark: start_mark,
-                end_mark:   end_mark,
-                value:      s,
-        }
-
-        return true
-}
-
-/*
- * Scan a TAG token.
- */
-
-func yaml_parser_scan_tag(parser *yaml_parser_t, token *yaml_token_t) bool {
-        var handle, suffix []byte
-
-        start_mark := parser.mark
-
-        // Check if the tag is in the canonical form.
-        if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
-                return false
-        }
-
-        if parser.buffer[parser.buffer_pos+1] == '<' {
-                // Keep the handle as ''
-
-                // Eat '!<'
-                skip(parser)
-                skip(parser)
-
-                // Consume the tag value.
-                if !yaml_parser_scan_tag_uri(parser, false, nil, start_mark, &suffix) {
-                        return false
-                }
-
-                // Check for '>' and eat it.
-                if parser.buffer[parser.buffer_pos] != '>' {
-                        yaml_parser_set_scanner_error(parser, "while scanning a tag",
-                                start_mark, "did not find the expected '>'")
-                        return false
-                }
-
-                skip(parser)
-        } else {
-                // The tag has either the '!suffix' or the '!handle!suffix' form.
-
-                // First, try to scan a handle.
-                if !yaml_parser_scan_tag_handle(parser, false, start_mark, &handle) {
-                        return false
-                }
-
-                // Check if it is, indeed, handle.
-                if handle[0] == '!' && len(handle) > 1 && handle[len(handle)-1] == '!' {
-                        // Scan the suffix now.
-                        if !yaml_parser_scan_tag_uri(parser, false, nil, start_mark, &suffix) {
-                                return false
-                        }
-                } else {
-                        // It wasn't a handle after all.  Scan the rest of the tag.
-                        if !yaml_parser_scan_tag_uri(parser, false, handle, start_mark, &suffix) {
-                                return false
-                        }
-
-                        // Set the handle to '!'.
-                        handle = []byte{'!'}
-
-                        // A special case: the '!' tag.  Set the handle to '' and the
-                        // suffix to '!'.
-                        if len(suffix) == 0 {
-                                handle, suffix = suffix, handle
-                        }
-                }
-        }
-
-        // Check the character which ends the tag.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-        if !is_blankz(parser.buffer, parser.buffer_pos) {
-                yaml_parser_set_scanner_error(parser, "while scanning a tag",
-                        start_mark, "did not find expected whitespace or line break")
-                return false
-        }
-
-        end_mark := parser.mark
-
-        // Create a token.
-        *token = yaml_token_t{
-                typ:        yaml_TAG_TOKEN,
-                start_mark: start_mark,
-                end_mark:   end_mark,
-                value:      handle,
-                suffix:     suffix,
-        }
-        return true
-}
-
-// Scan a tag handle.
-func yaml_parser_scan_tag_handle(parser *yaml_parser_t, directive bool, start_mark yaml_mark_t, handle *[]byte) bool {
-        // Check the initial '!' character.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-        if parser.buffer[parser.buffer_pos] != '!' {
-                yaml_parser_set_scanner_tag_error(parser, directive,
-                        start_mark, "did not find expected '!'")
-                return false
-        }
-
-        var s []byte
-
-        // Copy the '!' character.
-        s = read(parser, s)
-
-        // Copy all subsequent alphabetical and numerical characters.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-        for is_alpha(parser.buffer, parser.buffer_pos) {
-                s = read(parser, s)
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-        }
-
-        // Check if the trailing character is '!' and copy it.
-        if parser.buffer[parser.buffer_pos] == '!' {
-                s = read(parser, s)
-        } else {
-                // It's either the '!' tag or not really a tag handle.  If it's a %TAG
-                // directive, it's an error.  If it's a tag token, it must be a part of URI.
-                if directive && !(s[0] == '!' && s[1] == 0) {
-                        yaml_parser_set_scanner_tag_error(parser, directive,
-                                start_mark, "did not find expected '!'")
-                        return false
-                }
-        }
-
-        *handle = s
-        return true
-}
-
-// Scan a tag.
-func yaml_parser_scan_tag_uri(parser *yaml_parser_t, directive bool, head []byte, start_mark yaml_mark_t, uri *[]byte) bool {
-        //size_t length = head ? strlen((char *)head) : 0
-        var s []byte
-
-        // Copy the head if needed.
-        //
-        // Note that we don't copy the leading '!' character.
-        if len(head) > 1 {
-                s = append(s, head[1:]...)
-        }
-
-        // Scan the tag.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-
-        // The set of characters that may appear in URI is as follows:
-        //
-        //      '0'-'9', 'A'-'Z', 'a'-'z', '_', '-', ';', '/', '?', ':', '@', '&',
-        //      '=', '+', '$', ',', '.', '!', '~', '*', '\'', '(', ')', '[', ']',
-        //      '%'.
-        // [Go] Convert this into more reasonable logic.
-        for is_alpha(parser.buffer, parser.buffer_pos) || parser.buffer[parser.buffer_pos] == ';' ||
-                parser.buffer[parser.buffer_pos] == '/' || parser.buffer[parser.buffer_pos] == '?' ||
-                parser.buffer[parser.buffer_pos] == ':' || parser.buffer[parser.buffer_pos] == '@' ||
-                parser.buffer[parser.buffer_pos] == '&' || parser.buffer[parser.buffer_pos] == '=' ||
-                parser.buffer[parser.buffer_pos] == '+' || parser.buffer[parser.buffer_pos] == '$' ||
-                parser.buffer[parser.buffer_pos] == ',' || parser.buffer[parser.buffer_pos] == '.' ||
-                parser.buffer[parser.buffer_pos] == '!' || parser.buffer[parser.buffer_pos] == '~' ||
-                parser.buffer[parser.buffer_pos] == '*' || parser.buffer[parser.buffer_pos] == '\'' ||
-                parser.buffer[parser.buffer_pos] == '(' || parser.buffer[parser.buffer_pos] == ')' ||
-                parser.buffer[parser.buffer_pos] == '[' || parser.buffer[parser.buffer_pos] == ']' ||
-                parser.buffer[parser.buffer_pos] == '%' {
-                // Check if it is a URI-escape sequence.
-                if parser.buffer[parser.buffer_pos] == '%' {
-                        if !yaml_parser_scan_uri_escapes(parser, directive, start_mark, &s) {
-                                return false
-                        }
-                } else {
-                        s = read(parser, s)
-                }
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-        }
-
-        // Check if the tag is non-empty.
-        if len(s) == 0 {
-                yaml_parser_set_scanner_tag_error(parser, directive,
-                        start_mark, "did not find expected tag URI")
-                return false
-        }
-        *uri = s
-        return true
-}
-
-// Decode an URI-escape sequence corresponding to a single UTF-8 character.
-func yaml_parser_scan_uri_escapes(parser *yaml_parser_t, directive bool, start_mark yaml_mark_t, s *[]byte) bool {
-
-        // Decode the required number of characters.
-        w := 1024
-        for w > 0 {
-                // Check for a URI-escaped octet.
-                if parser.unread < 3 && !yaml_parser_update_buffer(parser, 3) {
-                        return false
-                }
-
-                if !(parser.buffer[parser.buffer_pos] == '%' &&
-                        is_hex(parser.buffer, parser.buffer_pos+1) &&
-                        is_hex(parser.buffer, parser.buffer_pos+2)) {
-                        return yaml_parser_set_scanner_tag_error(parser, directive,
-                                start_mark, "did not find URI escaped octet")
-                }
-
-                // Get the octet.
-                octet := byte((as_hex(parser.buffer, parser.buffer_pos+1) << 4) + as_hex(parser.buffer, parser.buffer_pos+2))
-
-                // If it is the leading octet, determine the length of the UTF-8 sequence.
-                if w == 1024 {
-                        w = width(octet)
-                        if w == 0 {
-                                return yaml_parser_set_scanner_tag_error(parser, directive,
-                                        start_mark, "found an incorrect leading UTF-8 octet")
-                        }
-                } else {
-                        // Check if the trailing octet is correct.
-                        if octet&0xC0 != 0x80 {
-                                return yaml_parser_set_scanner_tag_error(parser, directive,
-                                        start_mark, "found an incorrect trailing UTF-8 octet")
-                        }
-                }
-
-                // Copy the octet and move the pointers.
-                *s = append(*s, octet)
-                skip(parser)
-                skip(parser)
-                skip(parser)
-                w--
-        }
-        return true
-}
-
-// Scan a block scalar.
-func yaml_parser_scan_block_scalar(parser *yaml_parser_t, token *yaml_token_t, literal bool) bool {
-        // Eat the indicator '|' or '>'.
-        start_mark := parser.mark
-        skip(parser)
-
-        // Scan the additional block scalar indicators.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-
-        // Check for a chomping indicator.
-        var chomping, increment int
-        if parser.buffer[parser.buffer_pos] == '+' || parser.buffer[parser.buffer_pos] == '-' {
-                // Set the chomping method and eat the indicator.
-                if parser.buffer[parser.buffer_pos] == '+' {
-                        chomping = +1
-                } else {
-                        chomping = -1
-                }
-                skip(parser)
-
-                // Check for an indentation indicator.
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-                if is_digit(parser.buffer, parser.buffer_pos) {
-                        // Check that the intendation is greater than 0.
-                        if parser.buffer[parser.buffer_pos] == '0' {
-                                yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
-                                        start_mark, "found an intendation indicator equal to 0")
-                                return false
-                        }
-
-                        // Get the intendation level and eat the indicator.
-                        increment = as_digit(parser.buffer, parser.buffer_pos)
-                        skip(parser)
-                }
-
-        } else if is_digit(parser.buffer, parser.buffer_pos) {
-                // Do the same as above, but in the opposite order.
-
-                if parser.buffer[parser.buffer_pos] == '0' {
-                        yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
-                                start_mark, "found an intendation indicator equal to 0")
-                        return false
-                }
-                increment = as_digit(parser.buffer, parser.buffer_pos)
-                skip(parser)
-
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-                if parser.buffer[parser.buffer_pos] == '+' || parser.buffer[parser.buffer_pos] == '-' {
-                        if parser.buffer[parser.buffer_pos] == '+' {
-                                chomping = +1
-                        } else {
-                                chomping = -1
-                        }
-                        skip(parser)
-                }
-        }
-
-        // Eat whitespaces and comments to the end of the line.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-        for is_blank(parser.buffer, parser.buffer_pos) {
-                skip(parser)
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-        }
-        if parser.buffer[parser.buffer_pos] == '#' {
-                for !is_breakz(parser.buffer, parser.buffer_pos) {
-                        skip(parser)
-                        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                                return false
-                        }
-                }
-        }
-
-        // Check if we are at the end of the line.
-        if !is_breakz(parser.buffer, parser.buffer_pos) {
-                yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
-                        start_mark, "did not find expected comment or line break")
-                return false
-        }
-
-        // Eat a line break.
-        if is_break(parser.buffer, parser.buffer_pos) {
-                if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
-                        return false
-                }
-                skip_line(parser)
-        }
-
-        end_mark := parser.mark
-
-        // Set the intendation level if it was specified.
-        var indent int
-        if increment > 0 {
-                if parser.indent >= 0 {
-                        indent = parser.indent + increment
-                } else {
-                        indent = increment
-                }
-        }
-
-        // Scan the leading line breaks and determine the indentation level if needed.
-        var s, leading_break, trailing_breaks []byte
-        if !yaml_parser_scan_block_scalar_breaks(parser, &indent, &trailing_breaks, start_mark, &end_mark) {
-                return false
-        }
-
-        // Scan the block scalar content.
-        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                return false
-        }
-        var leading_blank, trailing_blank bool
-        for parser.mark.column == indent && !is_z(parser.buffer, parser.buffer_pos) {
-                // We are at the beginning of a non-empty line.
-
-                // Is it a trailing whitespace?
-                trailing_blank = is_blank(parser.buffer, parser.buffer_pos)
-
-                // Check if we need to fold the leading line break.
-                if !literal && !leading_blank && !trailing_blank && len(leading_break) > 0 && leading_break[0] == '\n' {
-                        // Do we need to join the lines by space?
-                        if len(trailing_breaks) == 0 {
-                                s = append(s, ' ')
-                        }
-                } else {
-                        s = append(s, leading_break...)
-                }
-                leading_break = leading_break[:0]
-
-                // Append the remaining line breaks.
-                s = append(s, trailing_breaks...)
-                trailing_breaks = trailing_breaks[:0]
-
-                // Is it a leading whitespace?
-                leading_blank = is_blank(parser.buffer, parser.buffer_pos)
-
-                // Consume the current line.
-                for !is_breakz(parser.buffer, parser.buffer_pos) {
-                        s = read(parser, s)
-                        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                                return false
-                        }
-                }
-
-                // Consume the line break.
-                if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
-                        return false
-                }
-
-                leading_break = read_line(parser, leading_break)
-
-                // Eat the following intendation spaces and line breaks.
-                if !yaml_parser_scan_block_scalar_breaks(parser, &indent, &trailing_breaks, start_mark, &end_mark) {
-                        return false
-                }
-        }
-
-        // Chomp the tail.
-        if chomping != -1 {
-                s = append(s, leading_break...)
-        }
-        if chomping == 1 {
-                s = append(s, trailing_breaks...)
-        }
-
-        // Create a token.
-        *token = yaml_token_t{
-                typ:        yaml_SCALAR_TOKEN,
-                start_mark: start_mark,
-                end_mark:   end_mark,
-                value:      s,
-                style:      yaml_LITERAL_SCALAR_STYLE,
-        }
-        if !literal {
-                token.style = yaml_FOLDED_SCALAR_STYLE
-        }
-        return true
-}
-
-// Scan intendation spaces and line breaks for a block scalar.  Determine the
-// intendation level if needed.
-func yaml_parser_scan_block_scalar_breaks(parser *yaml_parser_t, indent *int, breaks *[]byte, start_mark yaml_mark_t, end_mark *yaml_mark_t) bool {
-        *end_mark = parser.mark
-
-        // Eat the intendation spaces and line breaks.
-        max_indent := 0
-        for {
-                // Eat the intendation spaces.
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-                for (*indent == 0 || parser.mark.column < *indent) && is_space(parser.buffer, parser.buffer_pos) {
-                        skip(parser)
-                        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                                return false
-                        }
-                }
-                if parser.mark.column > max_indent {
-                        max_indent = parser.mark.column
-                }
-
-                // Check for a tab character messing the intendation.
-                if (*indent == 0 || parser.mark.column < *indent) && is_tab(parser.buffer, parser.buffer_pos) {
-                        return yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
-                                start_mark, "found a tab character where an intendation space is expected")
-                }
-
-                // Have we found a non-empty line?
-                if !is_break(parser.buffer, parser.buffer_pos) {
-                        break
-                }
-
-                // Consume the line break.
-                if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
-                        return false
-                }
-                // [Go] Should really be returning breaks instead.
-                *breaks = read_line(parser, *breaks)
-                *end_mark = parser.mark
-        }
-
-        // Determine the indentation level if needed.
-        if *indent == 0 {
-                *indent = max_indent
-                if *indent < parser.indent+1 {
-                        *indent = parser.indent + 1
-                }
-                if *indent < 1 {
-                        *indent = 1
-                }
-        }
-        return true
-}
-
-// Scan a quoted scalar.
-func yaml_parser_scan_flow_scalar(parser *yaml_parser_t, token *yaml_token_t, single bool) bool {
-        // Eat the left quote.
-        start_mark := parser.mark
-        skip(parser)
-
-        // Consume the content of the quoted scalar.
-        var s, leading_break, trailing_breaks, whitespaces []byte
-        for {
-                // Check that there are no document indicators at the beginning of the line.
-                if parser.unread < 4 && !yaml_parser_update_buffer(parser, 4) {
-                        return false
-                }
-
-                if parser.mark.column == 0 &&
-                        ((parser.buffer[parser.buffer_pos+0] == '-' &&
-                                parser.buffer[parser.buffer_pos+1] == '-' &&
-                                parser.buffer[parser.buffer_pos+2] == '-') ||
-                                (parser.buffer[parser.buffer_pos+0] == '.' &&
-                                        parser.buffer[parser.buffer_pos+1] == '.' &&
-                                        parser.buffer[parser.buffer_pos+2] == '.')) &&
-                        is_blankz(parser.buffer, parser.buffer_pos+3) {
-                        yaml_parser_set_scanner_error(parser, "while scanning a quoted scalar",
-                                start_mark, "found unexpected document indicator")
-                        return false
-                }
-
-                // Check for EOF.
-                if is_z(parser.buffer, parser.buffer_pos) {
-                        yaml_parser_set_scanner_error(parser, "while scanning a quoted scalar",
-                                start_mark, "found unexpected end of stream")
-                        return false
-                }
-
-                // Consume non-blank characters.
-                leading_blanks := false
-                for !is_blankz(parser.buffer, parser.buffer_pos) {
-                        if single && parser.buffer[parser.buffer_pos] == '\'' && parser.buffer[parser.buffer_pos+1] == '\'' {
-                                // Is is an escaped single quote.
-                                s = append(s, '\'')
-                                skip(parser)
-                                skip(parser)
-
-                        } else if single && parser.buffer[parser.buffer_pos] == '\'' {
-                                // It is a right single quote.
-                                break
-                        } else if !single && parser.buffer[parser.buffer_pos] == '"' {
-                                // It is a right double quote.
-                                break
-
-                        } else if !single && parser.buffer[parser.buffer_pos] == '\\' && is_break(parser.buffer, parser.buffer_pos+1) {
-                                // It is an escaped line break.
-                                if parser.unread < 3 && !yaml_parser_update_buffer(parser, 3) {
-                                        return false
-                                }
-                                skip(parser)
-                                skip_line(parser)
-                                leading_blanks = true
-                                break
-
-                        } else if !single && parser.buffer[parser.buffer_pos] == '\\' {
-                                // It is an escape sequence.
-                                code_length := 0
-
-                                // Check the escape character.
-                                switch parser.buffer[parser.buffer_pos+1] {
-                                case '0':
-                                        s = append(s, 0)
-                                case 'a':
-                                        s = append(s, '\x07')
-                                case 'b':
-                                        s = append(s, '\x08')
-                                case 't', '\t':
-                                        s = append(s, '\x09')
-                                case 'n':
-                                        s = append(s, '\x0A')
-                                case 'v':
-                                        s = append(s, '\x0B')
-                                case 'f':
-                                        s = append(s, '\x0C')
-                                case 'r':
-                                        s = append(s, '\x0D')
-                                case 'e':
-                                        s = append(s, '\x1B')
-                                case ' ':
-                                        s = append(s, '\x20')
-                                case '"':
-                                        s = append(s, '"')
-                                case '\'':
-                                        s = append(s, '\'')
-                                case '\\':
-                                        s = append(s, '\\')
-                                case 'N': // NEL (#x85)
-                                        s = append(s, '\xC2')
-                                        s = append(s, '\x85')
-                                case '_': // #xA0
-                                        s = append(s, '\xC2')
-                                        s = append(s, '\xA0')
-                                case 'L': // LS (#x2028)
-                                        s = append(s, '\xE2')
-                                        s = append(s, '\x80')
-                                        s = append(s, '\xA8')
-                                case 'P': // PS (#x2029)
-                                        s = append(s, '\xE2')
-                                        s = append(s, '\x80')
-                                        s = append(s, '\xA9')
-                                case 'x':
-                                        code_length = 2
-                                case 'u':
-                                        code_length = 4
-                                case 'U':
-                                        code_length = 8
-                                default:
-                                        yaml_parser_set_scanner_error(parser, "while parsing a quoted scalar",
-                                                start_mark, "found unknown escape character")
-                                        return false
-                                }
-
-                                skip(parser)
-                                skip(parser)
-
-                                // Consume an arbitrary escape code.
-                                if code_length > 0 {
-                                        var value int
-
-                                        // Scan the character value.
-                                        if parser.unread < code_length && !yaml_parser_update_buffer(parser, code_length) {
-                                                return false
-                                        }
-                                        for k := 0; k < code_length; k++ {
-                                                if !is_hex(parser.buffer, parser.buffer_pos+k) {
-                                                        yaml_parser_set_scanner_error(parser, "while parsing a quoted scalar",
-                                                                start_mark, "did not find expected hexdecimal number")
-                                                        return false
-                                                }
-                                                value = (value << 4) + as_hex(parser.buffer, parser.buffer_pos+k)
-                                        }
-
-                                        // Check the value and write the character.
-                                        if (value >= 0xD800 && value <= 0xDFFF) || value > 0x10FFFF {
-                                                yaml_parser_set_scanner_error(parser, "while parsing a quoted scalar",
-                                                        start_mark, "found invalid Unicode character escape code")
-                                                return false
-                                        }
-                                        if value <= 0x7F {
-                                                s = append(s, byte(value))
-                                        } else if value <= 0x7FF {
-                                                s = append(s, byte(0xC0+(value>>6)))
-                                                s = append(s, byte(0x80+(value&0x3F)))
-                                        } else if value <= 0xFFFF {
-                                                s = append(s, byte(0xE0+(value>>12)))
-                                                s = append(s, byte(0x80+((value>>6)&0x3F)))
-                                                s = append(s, byte(0x80+(value&0x3F)))
-                                        } else {
-                                                s = append(s, byte(0xF0+(value>>18)))
-                                                s = append(s, byte(0x80+((value>>12)&0x3F)))
-                                                s = append(s, byte(0x80+((value>>6)&0x3F)))
-                                                s = append(s, byte(0x80+(value&0x3F)))
-                                        }
-
-                                        // Advance the pointer.
-                                        for k := 0; k < code_length; k++ {
-                                                skip(parser)
-                                        }
-                                }
-                        } else {
-                                // It is a non-escaped non-blank character.
-                                s = read(parser, s)
-                        }
-                        if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
-                                return false
-                        }
-                }
-
-                // Check if we are at the end of the scalar.
-                if single {
-                        if parser.buffer[parser.buffer_pos] == '\'' {
-                                break
-                        }
-                } else {
-                        if parser.buffer[parser.buffer_pos] == '"' {
-                                break
-                        }
-                }
-
-                // Consume blank characters.
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-
-                for is_blank(parser.buffer, parser.buffer_pos) || is_break(parser.buffer, parser.buffer_pos) {
-                        if is_blank(parser.buffer, parser.buffer_pos) {
-                                // Consume a space or a tab character.
-                                if !leading_blanks {
-                                        whitespaces = read(parser, whitespaces)
-                                } else {
-                                        skip(parser)
-                                }
-                        } else {
-                                if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
-                                        return false
-                                }
-
-                                // Check if it is a first line break.
-                                if !leading_blanks {
-                                        whitespaces = whitespaces[:0]
-                                        leading_break = read_line(parser, leading_break)
-                                        leading_blanks = true
-                                } else {
-                                        trailing_breaks = read_line(parser, trailing_breaks)
-                                }
-                        }
-                        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                                return false
-                        }
-                }
-
-                // Join the whitespaces or fold line breaks.
-                if leading_blanks {
-                        // Do we need to fold line breaks?
-                        if len(leading_break) > 0 && leading_break[0] == '\n' {
-                                if len(trailing_breaks) == 0 {
-                                        s = append(s, ' ')
-                                } else {
-                                        s = append(s, trailing_breaks...)
-                                }
-                        } else {
-                                s = append(s, leading_break...)
-                                s = append(s, trailing_breaks...)
-                        }
-                        trailing_breaks = trailing_breaks[:0]
-                        leading_break = leading_break[:0]
-                } else {
-                        s = append(s, whitespaces...)
-                        whitespaces = whitespaces[:0]
-                }
-        }
-
-        // Eat the right quote.
-        skip(parser)
-        end_mark := parser.mark
-
-        // Create a token.
-        *token = yaml_token_t{
-                typ:        yaml_SCALAR_TOKEN,
-                start_mark: start_mark,
-                end_mark:   end_mark,
-                value:      s,
-                style:      yaml_SINGLE_QUOTED_SCALAR_STYLE,
-        }
-        if !single {
-                token.style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
-        }
-        return true
-}
-
-// Scan a plain scalar.
-func yaml_parser_scan_plain_scalar(parser *yaml_parser_t, token *yaml_token_t) bool {
-
-        var s, leading_break, trailing_breaks, whitespaces []byte
-        var leading_blanks bool
-        var indent = parser.indent + 1
-
-        start_mark := parser.mark
-        end_mark := parser.mark
-
-        // Consume the content of the plain scalar.
-        for {
-                // Check for a document indicator.
-                if parser.unread < 4 && !yaml_parser_update_buffer(parser, 4) {
-                        return false
-                }
-                if parser.mark.column == 0 &&
-                        ((parser.buffer[parser.buffer_pos+0] == '-' &&
-                                parser.buffer[parser.buffer_pos+1] == '-' &&
-                                parser.buffer[parser.buffer_pos+2] == '-') ||
-                                (parser.buffer[parser.buffer_pos+0] == '.' &&
-                                        parser.buffer[parser.buffer_pos+1] == '.' &&
-                                        parser.buffer[parser.buffer_pos+2] == '.')) &&
-                        is_blankz(parser.buffer, parser.buffer_pos+3) {
-                        break
-                }
-
-                // Check for a comment.
-                if parser.buffer[parser.buffer_pos] == '#' {
-                        break
-                }
-
-                // Consume non-blank characters.
-                for !is_blankz(parser.buffer, parser.buffer_pos) {
-
-                        // Check for 'x:x' in the flow context. TODO: Fix the test "spec-08-13".
-                        if parser.flow_level > 0 &&
-                                parser.buffer[parser.buffer_pos] == ':' &&
-                                !is_blankz(parser.buffer, parser.buffer_pos+1) {
-                                yaml_parser_set_scanner_error(parser, "while scanning a plain scalar",
-                                        start_mark, "found unexpected ':'")
-                                return false
-                        }
-
-                        // Check for indicators that may end a plain scalar.
-                        if (parser.buffer[parser.buffer_pos] == ':' && is_blankz(parser.buffer, parser.buffer_pos+1)) ||
-                                (parser.flow_level > 0 &&
-                                        (parser.buffer[parser.buffer_pos] == ',' || parser.buffer[parser.buffer_pos] == ':' ||
-                                                parser.buffer[parser.buffer_pos] == '?' || parser.buffer[parser.buffer_pos] == '[' ||
-                                                parser.buffer[parser.buffer_pos] == ']' || parser.buffer[parser.buffer_pos] == '{' ||
-                                                parser.buffer[parser.buffer_pos] == '}')) {
-                                break
-                        }
-
-                        // Check if we need to join whitespaces and breaks.
-                        if leading_blanks || len(whitespaces) > 0 {
-                                if leading_blanks {
-                                        // Do we need to fold line breaks?
-                                        if leading_break[0] == '\n' {
-                                                if len(trailing_breaks) == 0 {
-                                                        s = append(s, ' ')
-                                                } else {
-                                                        s = append(s, trailing_breaks...)
-                                                }
-                                        } else {
-                                                s = append(s, leading_break...)
-                                                s = append(s, trailing_breaks...)
-                                        }
-                                        trailing_breaks = trailing_breaks[:0]
-                                        leading_break = leading_break[:0]
-                                        leading_blanks = false
-                                } else {
-                                        s = append(s, whitespaces...)
-                                        whitespaces = whitespaces[:0]
-                                }
-                        }
-
-                        // Copy the character.
-                        s = read(parser, s)
-
-                        end_mark = parser.mark
-                        if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
-                                return false
-                        }
-                }
-
-                // Is it the end?
-                if !(is_blank(parser.buffer, parser.buffer_pos) || is_break(parser.buffer, parser.buffer_pos)) {
-                        break
-                }
-
-                // Consume blank characters.
-                if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                        return false
-                }
-
-                for is_blank(parser.buffer, parser.buffer_pos) || is_break(parser.buffer, parser.buffer_pos) {
-                        if is_blank(parser.buffer, parser.buffer_pos) {
-
-                                // Check for tab character that abuse intendation.
-                                if leading_blanks && parser.mark.column < indent && is_tab(parser.buffer, parser.buffer_pos) {
-                                        yaml_parser_set_scanner_error(parser, "while scanning a plain scalar",
-                                                start_mark, "found a tab character that violate intendation")
-                                        return false
-                                }
-
-                                // Consume a space or a tab character.
-                                if !leading_blanks {
-                                        whitespaces = read(parser, whitespaces)
-                                } else {
-                                        skip(parser)
-                                }
-                        } else {
-                                if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
-                                        return false
-                                }
-
-                                // Check if it is a first line break.
-                                if !leading_blanks {
-                                        whitespaces = whitespaces[:0]
-                                        leading_break = read_line(parser, leading_break)
-                                        leading_blanks = true
-                                } else {
-                                        trailing_breaks = read_line(parser, trailing_breaks)
-                                }
-                        }
-                        if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
-                                return false
-                        }
-                }
-
-                // Check intendation level.
-                if parser.flow_level == 0 && parser.mark.column < indent {
-                        break
-                }
-        }
-
-        // Create a token.
-        *token = yaml_token_t{
-                typ:        yaml_SCALAR_TOKEN,
-                start_mark: start_mark,
-                end_mark:   end_mark,
-                value:      s,
-                style:      yaml_PLAIN_SCALAR_STYLE,
-        }
-
-        // Note that we change the 'simple_key_allowed' flag.
-        if leading_blanks {
-                parser.simple_key_allowed = true
-        }
-        return true
-}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/sorter.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/sorter.go
deleted file mode 100644
index d5becb8..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/sorter.go
+++ /dev/null
@@ -1,104 +0,0 @@
-package yaml
-
-import (
-        "reflect"
-        "unicode"
-)
-
-type keyList []reflect.Value
-
-func (l keyList) Len() int      { return len(l) }
-func (l keyList) Swap(i, j int) { l[i], l[j] = l[j], l[i] }
-func (l keyList) Less(i, j int) bool {
-        a := l[i]
-        b := l[j]
-        ak := a.Kind()
-        bk := b.Kind()
-        for (ak == reflect.Interface || ak == reflect.Ptr) && !a.IsNil() {
-                a = a.Elem()
-                ak = a.Kind()
-        }
-        for (bk == reflect.Interface || bk == reflect.Ptr) && !b.IsNil() {
-                b = b.Elem()
-                bk = b.Kind()
-        }
-        af, aok := keyFloat(a)
-        bf, bok := keyFloat(b)
-        if aok && bok {
-                if af != bf {
-                        return af < bf
-                }
-                if ak != bk {
-                        return ak < bk
-                }
-                return numLess(a, b)
-        }
-        if ak != reflect.String || bk != reflect.String {
-                return ak < bk
-        }
-        ar, br := []rune(a.String()), []rune(b.String())
-        for i := 0; i < len(ar) && i < len(br); i++ {
-                if ar[i] == br[i] {
-                        continue
-                }
-                al := unicode.IsLetter(ar[i])
-                bl := unicode.IsLetter(br[i])
-                if al && bl {
-                        return ar[i] < br[i]
-                }
-                if al || bl {
-                        return bl
-                }
-                var ai, bi int
-                var an, bn int64
-                for ai = i; ai < len(ar) && unicode.IsDigit(ar[ai]); ai++ {
-                        an = an*10 + int64(ar[ai]-'0')
-                }
-                for bi = i; bi < len(br) && unicode.IsDigit(br[bi]); bi++ {
-                        bn = bn*10 + int64(br[bi]-'0')
-                }
-                if an != bn {
-                        return an < bn
-                }
-                if ai != bi {
-                        return ai < bi
-                }
-                return ar[i] < br[i]
-        }
-        return len(ar) < len(br)
-}
-
-// keyFloat returns a float value for v if it is a number/bool
-// and whether it is a number/bool or not.
-func keyFloat(v reflect.Value) (f float64, ok bool) {
-        switch v.Kind() {
-        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
-                return float64(v.Int()), true
-        case reflect.Float32, reflect.Float64:
-                return v.Float(), true
-        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
-                return float64(v.Uint()), true
-        case reflect.Bool:
-                if v.Bool() {
-                        return 1, true
-                }
-                return 0, true
-        }
-        return 0, false
-}
-
-// numLess returns whether a < b.
-// a and b must necessarily have the same kind.
-func numLess(a, b reflect.Value) bool {
-        switch a.Kind() {
-        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
-                return a.Int() < b.Int()
-        case reflect.Float32, reflect.Float64:
-                return a.Float() < b.Float()
-        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
-                return a.Uint() < b.Uint()
-        case reflect.Bool:
-                return !a.Bool() && b.Bool()
-        }
-        panic("not a number")
-}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/suite_test.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/suite_test.go
deleted file mode 100644
index cd2856d..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/suite_test.go
+++ /dev/null
@@ -1,12 +0,0 @@
-package yaml_test
-
-import (
-        . "gopkg.in/check.v1"
-        "testing"
-)
-
-func Test(t *testing.T) { TestingT(t) }
-
-type S struct{}
-
-var _ = Suite(&S{})
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/writerc.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/writerc.go
deleted file mode 100644
index 4d6d0fa..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/writerc.go
+++ /dev/null
@@ -1,89 +0,0 @@
-package yaml
-
-// Set the writer error and return false.
-func yaml_emitter_set_writer_error(emitter *yaml_emitter_t, problem string) bool {
-        emitter.error = yaml_WRITER_ERROR
-        emitter.problem = problem
-        return false
-}
-
-// Flush the output buffer.
-func yaml_emitter_flush(emitter *yaml_emitter_t) bool {
-        if emitter.write_handler == nil {
-                panic("write handler not set")
-        }
-
-        // Check if the buffer is empty.
-        if emitter.buffer_pos == 0 {
-                return true
-        }
-
-        // If the output encoding is UTF-8, we don't need to recode the buffer.
-        if emitter.encoding == yaml_UTF8_ENCODING {
-                if err := emitter.write_handler(emitter, emitter.buffer[:emitter.buffer_pos]); err != nil {
-                        return yaml_emitter_set_writer_error(emitter, "write error: "+err.Error())
-                }
-                emitter.buffer_pos = 0
-                return true
-        }
-
-        // Recode the buffer into the raw buffer.
-        var low, high int
-        if emitter.encoding == yaml_UTF16LE_ENCODING {
-                low, high = 0, 1
-        } else {
-                high, low = 1, 0
-        }
-
-        pos := 0
-        for pos < emitter.buffer_pos {
-                // See the "reader.c" code for more details on UTF-8 encoding.  Note
-                // that we assume that the buffer contains a valid UTF-8 sequence.
-
-                // Read the next UTF-8 character.
-                octet := emitter.buffer[pos]
-
-                var w int
-                var value rune
-                switch {
-                case octet&0x80 == 0x00:
-                        w, value = 1, rune(octet&0x7F)
-                case octet&0xE0 == 0xC0:
-                        w, value = 2, rune(octet&0x1F)
-                case octet&0xF0 == 0xE0:
-                        w, value = 3, rune(octet&0x0F)
-                case octet&0xF8 == 0xF0:
-                        w, value = 4, rune(octet&0x07)
-                }
-                for k := 1; k < w; k++ {
-                        octet = emitter.buffer[pos+k]
-                        value = (value << 6) + (rune(octet) & 0x3F)
-                }
-                pos += w
-
-                // Write the character.
-                if value < 0x10000 {
-                        var b [2]byte
-                        b[high] = byte(value >> 8)
-                        b[low] = byte(value & 0xFF)
-                        emitter.raw_buffer = append(emitter.raw_buffer, b[0], b[1])
-                } else {
-                        // Write the character using a surrogate pair (check "reader.c").
-                        var b [4]byte
-                        value -= 0x10000
-                        b[high] = byte(0xD8 + (value >> 18))
-                        b[low] = byte((value >> 10) & 0xFF)
-                        b[high+2] = byte(0xDC + ((value >> 8) & 0xFF))
-                        b[low+2] = byte(value & 0xFF)
-                        emitter.raw_buffer = append(emitter.raw_buffer, b[0], b[1], b[2], b[3])
-                }
-        }
-
-        // Write the raw buffer.
-        if err := emitter.write_handler(emitter, emitter.raw_buffer); err != nil {
-                return yaml_emitter_set_writer_error(emitter, "write error: "+err.Error())
-        }
-        emitter.buffer_pos = 0
-        emitter.raw_buffer = emitter.raw_buffer[:0]
-        return true
-}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/yaml.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/yaml.go
deleted file mode 100644
index 7093bca..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/yaml.go
+++ /dev/null
@@ -1,334 +0,0 @@
-// Package yaml implements YAML support for the Go language.
-//
-// Source code and other details for the project are available at GitHub:
-//
-//   https://github.com/go-yaml/yaml
-//
-package yaml
-
-import (
-        "errors"
-        "fmt"
-        "reflect"
-        "strings"
-        "sync"
-)
-
-// MapSlice encodes and decodes as a YAML map.
-// The order of keys is preserved when encoding and decoding.
-type MapSlice []MapItem
-
-// MapItem is an item in a MapSlice.
-type MapItem struct {
-        Key, Value interface{}
-}
-
-// The Unmarshaler interface may be implemented by types to customize their
-// behavior when being unmarshaled from a YAML document. The UnmarshalYAML
-// method receives a function that may be called to unmarshal the original
-// YAML value into a field or variable. It is safe to call the unmarshal
-// function parameter more than once if necessary.
-type Unmarshaler interface {
-        UnmarshalYAML(unmarshal func(interface{}) error) error
-}
-
-
-// The Marshaler interface may be implemented by types to customize their
-// behavior when being marshaled into a YAML document. The returned value
-// is marshaled in place of the original value implementing Marshaler.
-//
-// If an error is returned by MarshalYAML, the marshaling procedure stops
-// and returns with the provided error.
-type Marshaler interface {
-        MarshalYAML() (interface{}, error)
-}
-
-// Unmarshal decodes the first document found within the in byte slice
-// and assigns decoded values into the out value.
-//
-// Maps and pointers (to a struct, string, int, etc) are accepted as out
-// values. If an internal pointer within a struct is not initialized,
-// the yaml package will initialize it if necessary for unmarshalling
-// the provided data. The out parameter must not be nil.
-//
-// The type of the decoded values should be compatible with the respective
-// values in out. If one or more values cannot be decoded due to a type
-// mismatches, decoding continues partially until the end of the YAML
-// content, and a *yaml.TypeError is returned with details for all
-// missed values.
-//
-// Struct fields are only unmarshalled if they are exported (have an
-// upper case first letter), and are unmarshalled using the field name
-// lowercased as the default key. Custom keys may be defined via the
-// "yaml" name in the field tag: the content preceding the first comma
-// is used as the key, and the following comma-separated options are
-// used to tweak the marshalling process (see Marshal).
-// Conflicting names result in a runtime error.
-//
-// For example:
-//
-//     type T struct {
-//         F int `yaml:"a,omitempty"`
-//         B int
-//     }
-//     var t T
-//     yaml.Unmarshal([]byte("a: 1\nb: 2"), &t)
-//
-// See the documentation of Marshal for the format of tags and a list of
-// supported tag options.
-//
-func Unmarshal(in []byte, out interface{}) (err error) {
-        defer handleErr(&err)
-        d := newDecoder()
-        p := newParser(in)
-        defer p.destroy()
-        node := p.parse()
-        if node != nil {
-                v := reflect.ValueOf(out)
-                if v.Kind() == reflect.Ptr && !v.IsNil() {
-                        v = v.Elem()
-                }
-                d.unmarshal(node, v)
-        }
-        if d.terrors != nil {
-                return &TypeError{d.terrors}
-        }
-        return nil
-}
-
-// Marshal serializes the value provided into a YAML document. The structure
-// of the generated document will reflect the structure of the value itself.
-// Maps and pointers (to struct, string, int, etc) are accepted as the in value.
-//
-// Struct fields are only unmarshalled if they are exported (have an upper case
-// first letter), and are unmarshalled using the field name lowercased as the
-// default key. Custom keys may be defined via the "yaml" name in the field
-// tag: the content preceding the first comma is used as the key, and the
-// following comma-separated options are used to tweak the marshalling process.
-// Conflicting names result in a runtime error.
-//
-// The field tag format accepted is:
-//
-//     `(...) yaml:"[<key>][,<flag1>[,<flag2>]]" (...)`
-//
-// The following flags are currently supported:
-//
-//     omitempty    Only include the field if it's not set to the zero
-//                  value for the type or to empty slices or maps.
-//                  Does not apply to zero valued structs.
-//
-//     flow         Marshal using a flow style (useful for structs,
-//                  sequences and maps.
-//
-//     inline       Inline the struct it's applied to, so its fields
-//                  are processed as if they were part of the outer
-//                  struct.
-//
-// In addition, if the key is "-", the field is ignored.
-//
-// For example:
-//
-//     type T struct {
-//         F int "a,omitempty"
-//         B int
-//     }
-//     yaml.Marshal(&T{B: 2}) // Returns "b: 2\n"
-//     yaml.Marshal(&T{F: 1}} // Returns "a: 1\nb: 0\n"
-//
-func Marshal(in interface{}) (out []byte, err error) {
-        defer handleErr(&err)
-        e := newEncoder()
-        defer e.destroy()
-        e.marshal("", reflect.ValueOf(in))
-        e.finish()
-        out = e.out
-        return
-}
-
-func handleErr(err *error) {
-        if v := recover(); v != nil {
-                if e, ok := v.(yamlError); ok {
-                        *err = e.err
-                } else {
-                        panic(v)
-                }
-        }
-}
-
-type yamlError struct {
-        err error
-}
-
-func fail(err error) {
-        panic(yamlError{err})
-}
-
-func failf(format string, args ...interface{}) {
-        panic(yamlError{fmt.Errorf("yaml: " + format, args...)})
-}
-
-// A TypeError is returned by Unmarshal when one or more fields in
-// the YAML document cannot be properly decoded into the requested
-// types. When this error is returned, the value is still
-// unmarshaled partially.
-type TypeError struct {
-        Errors []string
-}
-
-func (e *TypeError) Error() string {
-        return fmt.Sprintf("yaml: unmarshal errors:\n  %s", strings.Join(e.Errors, "\n  "))
-}
-
-// --------------------------------------------------------------------------
-// Maintain a mapping of keys to structure field indexes
-
-// The code in this section was copied from mgo/bson.
-
-// structInfo holds details for the serialization of fields of
-// a given struct.
-type structInfo struct {
-        FieldsMap  map[string]fieldInfo
-        FieldsList []fieldInfo
-
-        // InlineMap is the number of the field in the struct that
-        // contains an ,inline map, or -1 if there's none.
-        InlineMap int
-}
-
-type fieldInfo struct {
-        Key       string
-        Num       int
-        OmitEmpty bool
-        Flow      bool
-
-        // Inline holds the field index if the field is part of an inlined struct.
-        Inline []int
-}
-
-var structMap = make(map[reflect.Type]*structInfo)
-var fieldMapMutex sync.RWMutex
-
-func getStructInfo(st reflect.Type) (*structInfo, error) {
-        fieldMapMutex.RLock()
-        sinfo, found := structMap[st]
-        fieldMapMutex.RUnlock()
-        if found {
-                return sinfo, nil
-        }
-
-        n := st.NumField()
-        fieldsMap := make(map[string]fieldInfo)
-        fieldsList := make([]fieldInfo, 0, n)
-        inlineMap := -1
-        for i := 0; i != n; i++ {
-                field := st.Field(i)
-                if field.PkgPath != "" {
-                        continue // Private field
-                }
-
-                info := fieldInfo{Num: i}
-
-                tag := field.Tag.Get("yaml")
-                if tag == "" && strings.Index(string(field.Tag), ":") < 0 {
-                        tag = string(field.Tag)
-                }
-                if tag == "-" {
-                        continue
-                }
-
-                inline := false
-                fields := strings.Split(tag, ",")
-                if len(fields) > 1 {
-                        for _, flag := range fields[1:] {
-                                switch flag {
-                                case "omitempty":
-                                        info.OmitEmpty = true
-                                case "flow":
-                                        info.Flow = true
-                                case "inline":
-                                        inline = true
-                                default:
-                                        return nil, errors.New(fmt.Sprintf("Unsupported flag %q in tag %q of type %s", flag, tag, st))
-                                }
-                        }
-                        tag = fields[0]
-                }
-
-                if inline {
-                        switch field.Type.Kind() {
-                        // TODO: Implement support for inline maps.
-                        //case reflect.Map:
-                        //	if inlineMap >= 0 {
-                        //		return nil, errors.New("Multiple ,inline maps in struct " + st.String())
-                        //	}
-                        //	if field.Type.Key() != reflect.TypeOf("") {
-                        //		return nil, errors.New("Option ,inline needs a map with string keys in struct " + st.String())
-                        //	}
-                        //	inlineMap = info.Num
-                        case reflect.Struct:
-                                sinfo, err := getStructInfo(field.Type)
-                                if err != nil {
-                                        return nil, err
-                                }
-                                for _, finfo := range sinfo.FieldsList {
-                                        if _, found := fieldsMap[finfo.Key]; found {
-                                                msg := "Duplicated key '" + finfo.Key + "' in struct " + st.String()
-                                                return nil, errors.New(msg)
-                                        }
-                                        if finfo.Inline == nil {
-                                                finfo.Inline = []int{i, finfo.Num}
-                                        } else {
-                                                finfo.Inline = append([]int{i}, finfo.Inline...)
-                                        }
-                                        fieldsMap[finfo.Key] = finfo
-                                        fieldsList = append(fieldsList, finfo)
-                                }
-                        default:
-                                //return nil, errors.New("Option ,inline needs a struct value or map field")
-                                return nil, errors.New("Option ,inline needs a struct value field")
-                        }
-                        continue
-                }
-
-                if tag != "" {
-                        info.Key = tag
-                } else {
-                        info.Key = strings.ToLower(field.Name)
-                }
-
-                if _, found = fieldsMap[info.Key]; found {
-                        msg := "Duplicated key '" + info.Key + "' in struct " + st.String()
-                        return nil, errors.New(msg)
-                }
-
-                fieldsList = append(fieldsList, info)
-                fieldsMap[info.Key] = info
-        }
-
-        sinfo = &structInfo{fieldsMap, fieldsList, inlineMap}
-
-        fieldMapMutex.Lock()
-        structMap[st] = sinfo
-        fieldMapMutex.Unlock()
-        return sinfo, nil
-}
-
-func isZero(v reflect.Value) bool {
-        switch v.Kind() {
-        case reflect.String:
-                return len(v.String()) == 0
-        case reflect.Interface, reflect.Ptr:
-                return v.IsNil()
-        case reflect.Slice:
-                return v.Len() == 0
-        case reflect.Map:
-                return v.Len() == 0
-        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
-                return v.Int() == 0
-        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
-                return v.Uint() == 0
-        case reflect.Bool:
-                return !v.Bool()
-        }
-        return false
-}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/yamlh.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/yamlh.go
deleted file mode 100644
index b140d52..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/yamlh.go
+++ /dev/null
@@ -1,716 +0,0 @@
-package yaml
-
-import (
-        "io"
-)
-
-// The version directive data.
-type yaml_version_directive_t struct {
-        major int8 // The major version number.
-        minor int8 // The minor version number.
-}
-
-// The tag directive data.
-type yaml_tag_directive_t struct {
-        handle []byte // The tag handle.
-        prefix []byte // The tag prefix.
-}
-
-type yaml_encoding_t int
-
-// The stream encoding.
-const (
-        // Let the parser choose the encoding.
-        yaml_ANY_ENCODING yaml_encoding_t = iota
-
-        yaml_UTF8_ENCODING    // The default UTF-8 encoding.
-        yaml_UTF16LE_ENCODING // The UTF-16-LE encoding with BOM.
-        yaml_UTF16BE_ENCODING // The UTF-16-BE encoding with BOM.
-)
-
-type yaml_break_t int
-
-// Line break types.
-const (
-        // Let the parser choose the break type.
-        yaml_ANY_BREAK yaml_break_t = iota
-
-        yaml_CR_BREAK   // Use CR for line breaks (Mac style).
-        yaml_LN_BREAK   // Use LN for line breaks (Unix style).
-        yaml_CRLN_BREAK // Use CR LN for line breaks (DOS style).
-)
-
-type yaml_error_type_t int
-
-// Many bad things could happen with the parser and emitter.
-const (
-        // No error is produced.
-        yaml_NO_ERROR yaml_error_type_t = iota
-
-        yaml_MEMORY_ERROR   // Cannot allocate or reallocate a block of memory.
-        yaml_READER_ERROR   // Cannot read or decode the input stream.
-        yaml_SCANNER_ERROR  // Cannot scan the input stream.
-        yaml_PARSER_ERROR   // Cannot parse the input stream.
-        yaml_COMPOSER_ERROR // Cannot compose a YAML document.
-        yaml_WRITER_ERROR   // Cannot write to the output stream.
-        yaml_EMITTER_ERROR  // Cannot emit a YAML stream.
-)
-
-// The pointer position.
-type yaml_mark_t struct {
-        index  int // The position index.
-        line   int // The position line.
-        column int // The position column.
-}
-
-// Node Styles
-
-type yaml_style_t int8
-
-type yaml_scalar_style_t yaml_style_t
-
-// Scalar styles.
-const (
-        // Let the emitter choose the style.
-        yaml_ANY_SCALAR_STYLE yaml_scalar_style_t = iota
-
-        yaml_PLAIN_SCALAR_STYLE         // The plain scalar style.
-        yaml_SINGLE_QUOTED_SCALAR_STYLE // The single-quoted scalar style.
-        yaml_DOUBLE_QUOTED_SCALAR_STYLE // The double-quoted scalar style.
-        yaml_LITERAL_SCALAR_STYLE       // The literal scalar style.
-        yaml_FOLDED_SCALAR_STYLE        // The folded scalar style.
-)
-
-type yaml_sequence_style_t yaml_style_t
-
-// Sequence styles.
-const (
-        // Let the emitter choose the style.
-        yaml_ANY_SEQUENCE_STYLE yaml_sequence_style_t = iota
-
-        yaml_BLOCK_SEQUENCE_STYLE // The block sequence style.
-        yaml_FLOW_SEQUENCE_STYLE  // The flow sequence style.
-)
-
-type yaml_mapping_style_t yaml_style_t
-
-// Mapping styles.
-const (
-        // Let the emitter choose the style.
-        yaml_ANY_MAPPING_STYLE yaml_mapping_style_t = iota
-
-        yaml_BLOCK_MAPPING_STYLE // The block mapping style.
-        yaml_FLOW_MAPPING_STYLE  // The flow mapping style.
-)
-
-// Tokens
-
-type yaml_token_type_t int
-
-// Token types.
-const (
-        // An empty token.
-        yaml_NO_TOKEN yaml_token_type_t = iota
-
-        yaml_STREAM_START_TOKEN // A STREAM-START token.
-        yaml_STREAM_END_TOKEN   // A STREAM-END token.
-
-        yaml_VERSION_DIRECTIVE_TOKEN // A VERSION-DIRECTIVE token.
-        yaml_TAG_DIRECTIVE_TOKEN     // A TAG-DIRECTIVE token.
-        yaml_DOCUMENT_START_TOKEN    // A DOCUMENT-START token.
-        yaml_DOCUMENT_END_TOKEN      // A DOCUMENT-END token.
-
-        yaml_BLOCK_SEQUENCE_START_TOKEN // A BLOCK-SEQUENCE-START token.
-        yaml_BLOCK_MAPPING_START_TOKEN  // A BLOCK-SEQUENCE-END token.
-        yaml_BLOCK_END_TOKEN            // A BLOCK-END token.
-
-        yaml_FLOW_SEQUENCE_START_TOKEN // A FLOW-SEQUENCE-START token.
-        yaml_FLOW_SEQUENCE_END_TOKEN   // A FLOW-SEQUENCE-END token.
-        yaml_FLOW_MAPPING_START_TOKEN  // A FLOW-MAPPING-START token.
-        yaml_FLOW_MAPPING_END_TOKEN    // A FLOW-MAPPING-END token.
-
-        yaml_BLOCK_ENTRY_TOKEN // A BLOCK-ENTRY token.
-        yaml_FLOW_ENTRY_TOKEN  // A FLOW-ENTRY token.
-        yaml_KEY_TOKEN         // A KEY token.
-        yaml_VALUE_TOKEN       // A VALUE token.
-
-        yaml_ALIAS_TOKEN  // An ALIAS token.
-        yaml_ANCHOR_TOKEN // An ANCHOR token.
-        yaml_TAG_TOKEN    // A TAG token.
-        yaml_SCALAR_TOKEN // A SCALAR token.
-)
-
-func (tt yaml_token_type_t) String() string {
-        switch tt {
-        case yaml_NO_TOKEN:
-                return "yaml_NO_TOKEN"
-        case yaml_STREAM_START_TOKEN:
-                return "yaml_STREAM_START_TOKEN"
-        case yaml_STREAM_END_TOKEN:
-                return "yaml_STREAM_END_TOKEN"
-        case yaml_VERSION_DIRECTIVE_TOKEN:
-                return "yaml_VERSION_DIRECTIVE_TOKEN"
-        case yaml_TAG_DIRECTIVE_TOKEN:
-                return "yaml_TAG_DIRECTIVE_TOKEN"
-        case yaml_DOCUMENT_START_TOKEN:
-                return "yaml_DOCUMENT_START_TOKEN"
-        case yaml_DOCUMENT_END_TOKEN:
-                return "yaml_DOCUMENT_END_TOKEN"
-        case yaml_BLOCK_SEQUENCE_START_TOKEN:
-                return "yaml_BLOCK_SEQUENCE_START_TOKEN"
-        case yaml_BLOCK_MAPPING_START_TOKEN:
-                return "yaml_BLOCK_MAPPING_START_TOKEN"
-        case yaml_BLOCK_END_TOKEN:
-                return "yaml_BLOCK_END_TOKEN"
-        case yaml_FLOW_SEQUENCE_START_TOKEN:
-                return "yaml_FLOW_SEQUENCE_START_TOKEN"
-        case yaml_FLOW_SEQUENCE_END_TOKEN:
-                return "yaml_FLOW_SEQUENCE_END_TOKEN"
-        case yaml_FLOW_MAPPING_START_TOKEN:
-                return "yaml_FLOW_MAPPING_START_TOKEN"
-        case yaml_FLOW_MAPPING_END_TOKEN:
-                return "yaml_FLOW_MAPPING_END_TOKEN"
-        case yaml_BLOCK_ENTRY_TOKEN:
-                return "yaml_BLOCK_ENTRY_TOKEN"
-        case yaml_FLOW_ENTRY_TOKEN:
-                return "yaml_FLOW_ENTRY_TOKEN"
-        case yaml_KEY_TOKEN:
-                return "yaml_KEY_TOKEN"
-        case yaml_VALUE_TOKEN:
-                return "yaml_VALUE_TOKEN"
-        case yaml_ALIAS_TOKEN:
-                return "yaml_ALIAS_TOKEN"
-        case yaml_ANCHOR_TOKEN:
-                return "yaml_ANCHOR_TOKEN"
-        case yaml_TAG_TOKEN:
-                return "yaml_TAG_TOKEN"
-        case yaml_SCALAR_TOKEN:
-                return "yaml_SCALAR_TOKEN"
-        }
-        return "<unknown token>"
-}
-
-// The token structure.
-type yaml_token_t struct {
-        // The token type.
-        typ yaml_token_type_t
-
-        // The start/end of the token.
-        start_mark, end_mark yaml_mark_t
-
-        // The stream encoding (for yaml_STREAM_START_TOKEN).
-        encoding yaml_encoding_t
-
-        // The alias/anchor/scalar value or tag/tag directive handle
-        // (for yaml_ALIAS_TOKEN, yaml_ANCHOR_TOKEN, yaml_SCALAR_TOKEN, yaml_TAG_TOKEN, yaml_TAG_DIRECTIVE_TOKEN).
-        value []byte
-
-        // The tag suffix (for yaml_TAG_TOKEN).
-        suffix []byte
-
-        // The tag directive prefix (for yaml_TAG_DIRECTIVE_TOKEN).
-        prefix []byte
-
-        // The scalar style (for yaml_SCALAR_TOKEN).
-        style yaml_scalar_style_t
-
-        // The version directive major/minor (for yaml_VERSION_DIRECTIVE_TOKEN).
-        major, minor int8
-}
-
-// Events
-
-type yaml_event_type_t int8
-
-// Event types.
-const (
-        // An empty event.
-        yaml_NO_EVENT yaml_event_type_t = iota
-
-        yaml_STREAM_START_EVENT   // A STREAM-START event.
-        yaml_STREAM_END_EVENT     // A STREAM-END event.
-        yaml_DOCUMENT_START_EVENT // A DOCUMENT-START event.
-        yaml_DOCUMENT_END_EVENT   // A DOCUMENT-END event.
-        yaml_ALIAS_EVENT          // An ALIAS event.
-        yaml_SCALAR_EVENT         // A SCALAR event.
-        yaml_SEQUENCE_START_EVENT // A SEQUENCE-START event.
-        yaml_SEQUENCE_END_EVENT   // A SEQUENCE-END event.
-        yaml_MAPPING_START_EVENT  // A MAPPING-START event.
-        yaml_MAPPING_END_EVENT    // A MAPPING-END event.
-)
-
-// The event structure.
-type yaml_event_t struct {
-
-        // The event type.
-        typ yaml_event_type_t
-
-        // The start and end of the event.
-        start_mark, end_mark yaml_mark_t
-
-        // The document encoding (for yaml_STREAM_START_EVENT).
-        encoding yaml_encoding_t
-
-        // The version directive (for yaml_DOCUMENT_START_EVENT).
-        version_directive *yaml_version_directive_t
-
-        // The list of tag directives (for yaml_DOCUMENT_START_EVENT).
-        tag_directives []yaml_tag_directive_t
-
-        // The anchor (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT, yaml_ALIAS_EVENT).
-        anchor []byte
-
-        // The tag (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT).
-        tag []byte
-
-        // The scalar value (for yaml_SCALAR_EVENT).
-        value []byte
-
-        // Is the document start/end indicator implicit, or the tag optional?
-        // (for yaml_DOCUMENT_START_EVENT, yaml_DOCUMENT_END_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT, yaml_SCALAR_EVENT).
-        implicit bool
-
-        // Is the tag optional for any non-plain style? (for yaml_SCALAR_EVENT).
-        quoted_implicit bool
-
-        // The style (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT).
-        style yaml_style_t
-}
-
-func (e *yaml_event_t) scalar_style() yaml_scalar_style_t     { return yaml_scalar_style_t(e.style) }
-func (e *yaml_event_t) sequence_style() yaml_sequence_style_t { return yaml_sequence_style_t(e.style) }
-func (e *yaml_event_t) mapping_style() yaml_mapping_style_t   { return yaml_mapping_style_t(e.style) }
-
-// Nodes
-
-const (
-        yaml_NULL_TAG      = "tag:yaml.org,2002:null"      // The tag !!null with the only possible value: null.
-        yaml_BOOL_TAG      = "tag:yaml.org,2002:bool"      // The tag !!bool with the values: true and false.
-        yaml_STR_TAG       = "tag:yaml.org,2002:str"       // The tag !!str for string values.
-        yaml_INT_TAG       = "tag:yaml.org,2002:int"       // The tag !!int for integer values.
-        yaml_FLOAT_TAG     = "tag:yaml.org,2002:float"     // The tag !!float for float values.
-        yaml_TIMESTAMP_TAG = "tag:yaml.org,2002:timestamp" // The tag !!timestamp for date and time values.
-
-        yaml_SEQ_TAG = "tag:yaml.org,2002:seq" // The tag !!seq is used to denote sequences.
-        yaml_MAP_TAG = "tag:yaml.org,2002:map" // The tag !!map is used to denote mapping.
-
-        // Not in original libyaml.
-        yaml_BINARY_TAG = "tag:yaml.org,2002:binary"
-        yaml_MERGE_TAG = "tag:yaml.org,2002:merge"
-
-        yaml_DEFAULT_SCALAR_TAG   = yaml_STR_TAG // The default scalar tag is !!str.
-        yaml_DEFAULT_SEQUENCE_TAG = yaml_SEQ_TAG // The default sequence tag is !!seq.
-        yaml_DEFAULT_MAPPING_TAG  = yaml_MAP_TAG // The default mapping tag is !!map.
-)
-
-type yaml_node_type_t int
-
-// Node types.
-const (
-        // An empty node.
-        yaml_NO_NODE yaml_node_type_t = iota
-
-        yaml_SCALAR_NODE   // A scalar node.
-        yaml_SEQUENCE_NODE // A sequence node.
-        yaml_MAPPING_NODE  // A mapping node.
-)
-
-// An element of a sequence node.
-type yaml_node_item_t int
-
-// An element of a mapping node.
-type yaml_node_pair_t struct {
-        key   int // The key of the element.
-        value int // The value of the element.
-}
-
-// The node structure.
-type yaml_node_t struct {
-        typ yaml_node_type_t // The node type.
-        tag []byte           // The node tag.
-
-        // The node data.
-
-        // The scalar parameters (for yaml_SCALAR_NODE).
-        scalar struct {
-                value  []byte              // The scalar value.
-                length int                 // The length of the scalar value.
-                style  yaml_scalar_style_t // The scalar style.
-        }
-
-        // The sequence parameters (for YAML_SEQUENCE_NODE).
-        sequence struct {
-                items_data []yaml_node_item_t    // The stack of sequence items.
-                style      yaml_sequence_style_t // The sequence style.
-        }
-
-        // The mapping parameters (for yaml_MAPPING_NODE).
-        mapping struct {
-                pairs_data  []yaml_node_pair_t   // The stack of mapping pairs (key, value).
-                pairs_start *yaml_node_pair_t    // The beginning of the stack.
-                pairs_end   *yaml_node_pair_t    // The end of the stack.
-                pairs_top   *yaml_node_pair_t    // The top of the stack.
-                style       yaml_mapping_style_t // The mapping style.
-        }
-
-        start_mark yaml_mark_t // The beginning of the node.
-        end_mark   yaml_mark_t // The end of the node.
-
-}
-
-// The document structure.
-type yaml_document_t struct {
-
-        // The document nodes.
-        nodes []yaml_node_t
-
-        // The version directive.
-        version_directive *yaml_version_directive_t
-
-        // The list of tag directives.
-        tag_directives_data  []yaml_tag_directive_t
-        tag_directives_start int // The beginning of the tag directives list.
-        tag_directives_end   int // The end of the tag directives list.
-
-        start_implicit int // Is the document start indicator implicit?
-        end_implicit   int // Is the document end indicator implicit?
-
-        // The start/end of the document.
-        start_mark, end_mark yaml_mark_t
-}
-
-// The prototype of a read handler.
-//
-// The read handler is called when the parser needs to read more bytes from the
-// source. The handler should write not more than size bytes to the buffer.
-// The number of written bytes should be set to the size_read variable.
-//
-// [in,out]   data        A pointer to an application data specified by
-//                        yaml_parser_set_input().
-// [out]      buffer      The buffer to write the data from the source.
-// [in]       size        The size of the buffer.
-// [out]      size_read   The actual number of bytes read from the source.
-//
-// On success, the handler should return 1.  If the handler failed,
-// the returned value should be 0. On EOF, the handler should set the
-// size_read to 0 and return 1.
-type yaml_read_handler_t func(parser *yaml_parser_t, buffer []byte) (n int, err error)
-
-// This structure holds information about a potential simple key.
-type yaml_simple_key_t struct {
-        possible     bool        // Is a simple key possible?
-        required     bool        // Is a simple key required?
-        token_number int         // The number of the token.
-        mark         yaml_mark_t // The position mark.
-}
-
-// The states of the parser.
-type yaml_parser_state_t int
-
-const (
-        yaml_PARSE_STREAM_START_STATE yaml_parser_state_t = iota
-
-        yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE           // Expect the beginning of an implicit document.
-        yaml_PARSE_DOCUMENT_START_STATE                    // Expect DOCUMENT-START.
-        yaml_PARSE_DOCUMENT_CONTENT_STATE                  // Expect the content of a document.
-        yaml_PARSE_DOCUMENT_END_STATE                      // Expect DOCUMENT-END.
-        yaml_PARSE_BLOCK_NODE_STATE                        // Expect a block node.
-        yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE // Expect a block node or indentless sequence.
-        yaml_PARSE_FLOW_NODE_STATE                         // Expect a flow node.
-        yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE        // Expect the first entry of a block sequence.
-        yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE              // Expect an entry of a block sequence.
-        yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE         // Expect an entry of an indentless sequence.
-        yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE           // Expect the first key of a block mapping.
-        yaml_PARSE_BLOCK_MAPPING_KEY_STATE                 // Expect a block mapping key.
-        yaml_PARSE_BLOCK_MAPPING_VALUE_STATE               // Expect a block mapping value.
-        yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE         // Expect the first entry of a flow sequence.
-        yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE               // Expect an entry of a flow sequence.
-        yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE   // Expect a key of an ordered mapping.
-        yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE // Expect a value of an ordered mapping.
-        yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE   // Expect the and of an ordered mapping entry.
-        yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE            // Expect the first key of a flow mapping.
-        yaml_PARSE_FLOW_MAPPING_KEY_STATE                  // Expect a key of a flow mapping.
-        yaml_PARSE_FLOW_MAPPING_VALUE_STATE                // Expect a value of a flow mapping.
-        yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE          // Expect an empty value of a flow mapping.
-        yaml_PARSE_END_STATE                               // Expect nothing.
-)
-
-func (ps yaml_parser_state_t) String() string {
-        switch ps {
-        case yaml_PARSE_STREAM_START_STATE:
-                return "yaml_PARSE_STREAM_START_STATE"
-        case yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE:
-                return "yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE"
-        case yaml_PARSE_DOCUMENT_START_STATE:
-                return "yaml_PARSE_DOCUMENT_START_STATE"
-        case yaml_PARSE_DOCUMENT_CONTENT_STATE:
-                return "yaml_PARSE_DOCUMENT_CONTENT_STATE"
-        case yaml_PARSE_DOCUMENT_END_STATE:
-                return "yaml_PARSE_DOCUMENT_END_STATE"
-        case yaml_PARSE_BLOCK_NODE_STATE:
-                return "yaml_PARSE_BLOCK_NODE_STATE"
-        case yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE:
-                return "yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE"
-        case yaml_PARSE_FLOW_NODE_STATE:
-                return "yaml_PARSE_FLOW_NODE_STATE"
-        case yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE:
-                return "yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE"
-        case yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE:
-                return "yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE"
-        case yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE:
-                return "yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE"
-        case yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE:
-                return "yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE"
-        case yaml_PARSE_BLOCK_MAPPING_KEY_STATE:
-                return "yaml_PARSE_BLOCK_MAPPING_KEY_STATE"
-        case yaml_PARSE_BLOCK_MAPPING_VALUE_STATE:
-                return "yaml_PARSE_BLOCK_MAPPING_VALUE_STATE"
-        case yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE:
-                return "yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE"
-        case yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE:
-                return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE"
-        case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE:
-                return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE"
-        case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE:
-                return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE"
-        case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE:
-                return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE"
-        case yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE:
-                return "yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE"
-        case yaml_PARSE_FLOW_MAPPING_KEY_STATE:
-                return "yaml_PARSE_FLOW_MAPPING_KEY_STATE"
-        case yaml_PARSE_FLOW_MAPPING_VALUE_STATE:
-                return "yaml_PARSE_FLOW_MAPPING_VALUE_STATE"
-        case yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE:
-                return "yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE"
-        case yaml_PARSE_END_STATE:
-                return "yaml_PARSE_END_STATE"
-        }
-        return "<unknown parser state>"
-}
-
-// This structure holds aliases data.
-type yaml_alias_data_t struct {
-        anchor []byte      // The anchor.
-        index  int         // The node id.
-        mark   yaml_mark_t // The anchor mark.
-}
-
-// The parser structure.
-//
-// All members are internal. Manage the structure using the
-// yaml_parser_ family of functions.
-type yaml_parser_t struct {
-
-        // Error handling
-
-        error yaml_error_type_t // Error type.
-
-        problem string // Error description.
-
-        // The byte about which the problem occured.
-        problem_offset int
-        problem_value  int
-        problem_mark   yaml_mark_t
-
-        // The error context.
-        context      string
-        context_mark yaml_mark_t
-
-        // Reader stuff
-
-        read_handler yaml_read_handler_t // Read handler.
-
-        input_file io.Reader // File input data.
-        input      []byte    // String input data.
-        input_pos  int
-
-        eof bool // EOF flag
-
-        buffer     []byte // The working buffer.
-        buffer_pos int    // The current position of the buffer.
-
-        unread int // The number of unread characters in the buffer.
-
-        raw_buffer     []byte // The raw buffer.
-        raw_buffer_pos int    // The current position of the buffer.
-
-        encoding yaml_encoding_t // The input encoding.
-
-        offset int         // The offset of the current position (in bytes).
-        mark   yaml_mark_t // The mark of the current position.
-
-        // Scanner stuff
-
-        stream_start_produced bool // Have we started to scan the input stream?
-        stream_end_produced   bool // Have we reached the end of the input stream?
-
-        flow_level int // The number of unclosed '[' and '{' indicators.
-
-        tokens          []yaml_token_t // The tokens queue.
-        tokens_head     int            // The head of the tokens queue.
-        tokens_parsed   int            // The number of tokens fetched from the queue.
-        token_available bool           // Does the tokens queue contain a token ready for dequeueing.
-
-        indent  int   // The current indentation level.
-        indents []int // The indentation levels stack.
-
-        simple_key_allowed bool                // May a simple key occur at the current position?
-        simple_keys        []yaml_simple_key_t // The stack of simple keys.
-
-        // Parser stuff
-
-        state          yaml_parser_state_t    // The current parser state.
-        states         []yaml_parser_state_t  // The parser states stack.
-        marks          []yaml_mark_t          // The stack of marks.
-        tag_directives []yaml_tag_directive_t // The list of TAG directives.
-
-        // Dumper stuff
-
-        aliases []yaml_alias_data_t // The alias data.
-
-        document *yaml_document_t // The currently parsed document.
-}
-
-// Emitter Definitions
-
-// The prototype of a write handler.
-//
-// The write handler is called when the emitter needs to flush the accumulated
-// characters to the output.  The handler should write @a size bytes of the
-// @a buffer to the output.
-//
-// @param[in,out]   data        A pointer to an application data specified by
-//                              yaml_emitter_set_output().
-// @param[in]       buffer      The buffer with bytes to be written.
-// @param[in]       size        The size of the buffer.
-//
-// @returns On success, the handler should return @c 1.  If the handler failed,
-// the returned value should be @c 0.
-//
-type yaml_write_handler_t func(emitter *yaml_emitter_t, buffer []byte) error
-
-type yaml_emitter_state_t int
-
-// The emitter states.
-const (
-        // Expect STREAM-START.
-        yaml_EMIT_STREAM_START_STATE yaml_emitter_state_t = iota
-
-        yaml_EMIT_FIRST_DOCUMENT_START_STATE       // Expect the first DOCUMENT-START or STREAM-END.
-        yaml_EMIT_DOCUMENT_START_STATE             // Expect DOCUMENT-START or STREAM-END.
-        yaml_EMIT_DOCUMENT_CONTENT_STATE           // Expect the content of a document.
-        yaml_EMIT_DOCUMENT_END_STATE               // Expect DOCUMENT-END.
-        yaml_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE   // Expect the first item of a flow sequence.
-        yaml_EMIT_FLOW_SEQUENCE_ITEM_STATE         // Expect an item of a flow sequence.
-        yaml_EMIT_FLOW_MAPPING_FIRST_KEY_STATE     // Expect the first key of a flow mapping.
-        yaml_EMIT_FLOW_MAPPING_KEY_STATE           // Expect a key of a flow mapping.
-        yaml_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE  // Expect a value for a simple key of a flow mapping.
-        yaml_EMIT_FLOW_MAPPING_VALUE_STATE         // Expect a value of a flow mapping.
-        yaml_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE  // Expect the first item of a block sequence.
-        yaml_EMIT_BLOCK_SEQUENCE_ITEM_STATE        // Expect an item of a block sequence.
-        yaml_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE    // Expect the first key of a block mapping.
-        yaml_EMIT_BLOCK_MAPPING_KEY_STATE          // Expect the key of a block mapping.
-        yaml_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE // Expect a value for a simple key of a block mapping.
-        yaml_EMIT_BLOCK_MAPPING_VALUE_STATE        // Expect a value of a block mapping.
-        yaml_EMIT_END_STATE                        // Expect nothing.
-)
-
-// The emitter structure.
-//
-// All members are internal.  Manage the structure using the @c yaml_emitter_
-// family of functions.
-type yaml_emitter_t struct {
-
-        // Error handling
-
-        error   yaml_error_type_t // Error type.
-        problem string            // Error description.
-
-        // Writer stuff
-
-        write_handler yaml_write_handler_t // Write handler.
-
-        output_buffer *[]byte   // String output data.
-        output_file   io.Writer // File output data.
-
-        buffer     []byte // The working buffer.
-        buffer_pos int    // The current position of the buffer.
-
-        raw_buffer     []byte // The raw buffer.
-        raw_buffer_pos int    // The current position of the buffer.
-
-        encoding yaml_encoding_t // The stream encoding.
-
-        // Emitter stuff
-
-        canonical   bool         // If the output is in the canonical style?
-        best_indent int          // The number of indentation spaces.
-        best_width  int          // The preferred width of the output lines.
-        unicode     bool         // Allow unescaped non-ASCII characters?
-        line_break  yaml_break_t // The preferred line break.
-
-        state  yaml_emitter_state_t   // The current emitter state.
-        states []yaml_emitter_state_t // The stack of states.
-
-        events      []yaml_event_t // The event queue.
-        events_head int            // The head of the event queue.
-
-        indents []int // The stack of indentation levels.
-
-        tag_directives []yaml_tag_directive_t // The list of tag directives.
-
-        indent int // The current indentation level.
-
-        flow_level int // The current flow level.
-
-        root_context       bool // Is it the document root context?
-        sequence_context   bool // Is it a sequence context?
-        mapping_context    bool // Is it a mapping context?
-        simple_key_context bool // Is it a simple mapping key context?
-
-        line       int  // The current line.
-        column     int  // The current column.
-        whitespace bool // If the last character was a whitespace?
-        indention  bool // If the last character was an indentation character (' ', '-', '?', ':')?
-        open_ended bool // If an explicit document end is required?
-
-        // Anchor analysis.
-        anchor_data struct {
-                anchor []byte // The anchor value.
-                alias  bool   // Is it an alias?
-        }
-
-        // Tag analysis.
-        tag_data struct {
-                handle []byte // The tag handle.
-                suffix []byte // The tag suffix.
-        }
-
-        // Scalar analysis.
-        scalar_data struct {
-                value                 []byte              // The scalar value.
-                multiline             bool                // Does the scalar contain line breaks?
-                flow_plain_allowed    bool                // Can the scalar be expessed in the flow plain style?
-                block_plain_allowed   bool                // Can the scalar be expressed in the block plain style?
-                single_quoted_allowed bool                // Can the scalar be expressed in the single quoted style?
-                block_allowed         bool                // Can the scalar be expressed in the literal or folded styles?
-                style                 yaml_scalar_style_t // The output style.
-        }
-
-        // Dumper stuff
-
-        opened bool // If the stream was already opened?
-        closed bool // If the stream was already closed?
-
-        // The information associated with the document nodes.
-        anchors *struct {
-                references int  // The number of references.
-                anchor     int  // The anchor id.
-                serialized bool // If the node has been emitted?
-        }
-
-        last_anchor_id int // The last assigned anchor id.
-
-        document *yaml_document_t // The currently emitted document.
-}
diff --git a/Godeps/_workspace/src/gopkg.in/yaml.v2/yamlprivateh.go b/Godeps/_workspace/src/gopkg.in/yaml.v2/yamlprivateh.go
deleted file mode 100644
index 3f81709..0000000
--- a/Godeps/_workspace/src/gopkg.in/yaml.v2/yamlprivateh.go
+++ /dev/null
@@ -1,173 +0,0 @@
-package yaml
-
-const (
-        // The size of the input raw buffer.
-        input_raw_buffer_size = 512
-
-        // The size of the input buffer.
-        // It should be possible to decode the whole raw buffer.
-        input_buffer_size = input_raw_buffer_size * 3
-
-        // The size of the output buffer.
-        output_buffer_size = 128
-
-        // The size of the output raw buffer.
-        // It should be possible to encode the whole output buffer.
-        output_raw_buffer_size = (output_buffer_size*2 + 2)
-
-        // The size of other stacks and queues.
-        initial_stack_size  = 16
-        initial_queue_size  = 16
-        initial_string_size = 16
-)
-
-// Check if the character at the specified position is an alphabetical
-// character, a digit, '_', or '-'.
-func is_alpha(b []byte, i int) bool {
-        return b[i] >= '0' && b[i] <= '9' || b[i] >= 'A' && b[i] <= 'Z' || b[i] >= 'a' && b[i] <= 'z' || b[i] == '_' || b[i] == '-'
-}
-
-// Check if the character at the specified position is a digit.
-func is_digit(b []byte, i int) bool {
-        return b[i] >= '0' && b[i] <= '9'
-}
-
-// Get the value of a digit.
-func as_digit(b []byte, i int) int {
-        return int(b[i]) - '0'
-}
-
-// Check if the character at the specified position is a hex-digit.
-func is_hex(b []byte, i int) bool {
-        return b[i] >= '0' && b[i] <= '9' || b[i] >= 'A' && b[i] <= 'F' || b[i] >= 'a' && b[i] <= 'f'
-}
-
-// Get the value of a hex-digit.
-func as_hex(b []byte, i int) int {
-        bi := b[i]
-        if bi >= 'A' && bi <= 'F' {
-                return int(bi) - 'A' + 10
-        }
-        if bi >= 'a' && bi <= 'f' {
-                return int(bi) - 'a' + 10
-        }
-        return int(bi) - '0'
-}
-
-// Check if the character is ASCII.
-func is_ascii(b []byte, i int) bool {
-        return b[i] <= 0x7F
-}
-
-// Check if the character at the start of the buffer can be printed unescaped.
-func is_printable(b []byte, i int) bool {
-        return ((b[i] == 0x0A) || // . == #x0A
-                (b[i] >= 0x20 && b[i] <= 0x7E) || // #x20 <= . <= #x7E
-                (b[i] == 0xC2 && b[i+1] >= 0xA0) || // #0xA0 <= . <= #xD7FF
-                (b[i] > 0xC2 && b[i] < 0xED) ||
-                (b[i] == 0xED && b[i+1] < 0xA0) ||
-                (b[i] == 0xEE) ||
-                (b[i] == 0xEF && // #xE000 <= . <= #xFFFD
-                        !(b[i+1] == 0xBB && b[i+2] == 0xBF) && // && . != #xFEFF
-                        !(b[i+1] == 0xBF && (b[i+2] == 0xBE || b[i+2] == 0xBF))))
-}
-
-// Check if the character at the specified position is NUL.
-func is_z(b []byte, i int) bool {
-        return b[i] == 0x00
-}
-
-// Check if the beginning of the buffer is a BOM.
-func is_bom(b []byte, i int) bool {
-        return b[0] == 0xEF && b[1] == 0xBB && b[2] == 0xBF
-}
-
-// Check if the character at the specified position is space.
-func is_space(b []byte, i int) bool {
-        return b[i] == ' '
-}
-
-// Check if the character at the specified position is tab.
-func is_tab(b []byte, i int) bool {
-        return b[i] == '\t'
-}
-
-// Check if the character at the specified position is blank (space or tab).
-func is_blank(b []byte, i int) bool {
-        //return is_space(b, i) || is_tab(b, i)
-        return b[i] == ' ' || b[i] == '\t'
-}
-
-// Check if the character at the specified position is a line break.
-func is_break(b []byte, i int) bool {
-        return (b[i] == '\r' || // CR (#xD)
-                b[i] == '\n' || // LF (#xA)
-                b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
-                b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
-                b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9) // PS (#x2029)
-}
-
-func is_crlf(b []byte, i int) bool {
-        return b[i] == '\r' && b[i+1] == '\n'
-}
-
-// Check if the character is a line break or NUL.
-func is_breakz(b []byte, i int) bool {
-        //return is_break(b, i) || is_z(b, i)
-        return (        // is_break:
-        b[i] == '\r' || // CR (#xD)
-                b[i] == '\n' || // LF (#xA)
-                b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
-                b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
-                b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9 || // PS (#x2029)
-                // is_z:
-                b[i] == 0)
-}
-
-// Check if the character is a line break, space, or NUL.
-func is_spacez(b []byte, i int) bool {
-        //return is_space(b, i) || is_breakz(b, i)
-        return ( // is_space:
-        b[i] == ' ' ||
-                // is_breakz:
-                b[i] == '\r' || // CR (#xD)
-                b[i] == '\n' || // LF (#xA)
-                b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
-                b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
-                b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9 || // PS (#x2029)
-                b[i] == 0)
-}
-
-// Check if the character is a line break, space, tab, or NUL.
-func is_blankz(b []byte, i int) bool {
-        //return is_blank(b, i) || is_breakz(b, i)
-        return ( // is_blank:
-        b[i] == ' ' || b[i] == '\t' ||
-                // is_breakz:
-                b[i] == '\r' || // CR (#xD)
-                b[i] == '\n' || // LF (#xA)
-                b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
-                b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
-                b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9 || // PS (#x2029)
-                b[i] == 0)
-}
-
-// Determine the width of the character.
-func width(b byte) int {
-        // Don't replace these by a switch without first
-        // confirming that it is being inlined.
-        if b&0x80 == 0x00 {
-                return 1
-        }
-        if b&0xE0 == 0xC0 {
-                return 2
-        }
-        if b&0xF0 == 0xE0 {
-                return 3
-        }
-        if b&0xF8 == 0xF0 {
-                return 4
-        }
-        return 0
-
-}
diff --git a/app/app.go b/app/app.go
index 786c62d..128813d 100644
--- a/app/app.go
+++ b/app/app.go
@@ -8,7 +8,7 @@ import (
 	"strings"
 	"sync"
 
-	"github.com/stevenjack/cig/Godeps/_workspace/src/github.com/mitchellh/go-homedir"
+	"github.com/mitchellh/go-homedir"
 	"github.com/stevenjack/cig/output"
 	"github.com/stevenjack/cig/repo"
 )
@@ -18,25 +18,25 @@ func Handle(repoList map[string]string, projectTypeToCheck string, filter string
 
 	for projectType, path := range repoList {
 		if projectTypeToCheck == "" || projectTypeToCheck == projectType {
-                        outputChannel <- output.Print(fmt.Sprintf("\nChecking '%s' (%s) repos...", projectType, path))
+			outputChannel <- output.Print(fmt.Sprintf("\nChecking '%s' (%s) repos...", projectType, path))
 			path = resolvePath(path)
 
 			visit := func(visitedPath string, info os.FileInfo, err error) error {
 				if err != nil {
-                                        outputChannel <- output.Error(fmt.Sprintf("- %s", err.Error()))
+					outputChannel <- output.Error(fmt.Sprintf("- %s", err.Error()))
 					return nil
 				}
 				matched, _ := regexp.MatchString(filter, visitedPath)
 				if info.IsDir() && (filter == "" || matched) {
 					wg.Add(1)
-                                        go repo.Check(path, visitedPath, outputChannel, &wg)
+					go repo.Check(path, visitedPath, outputChannel, &wg)
 				}
 				return nil
 			}
 
 			err := filepath.Walk(path, visit)
 			if err != nil {
-                                outputChannel <- output.Error(err.Error())
+				outputChannel <- output.Error(err.Error())
 			}
 		}
 
diff --git a/app/config.go b/app/config.go
index ff6b95b..8a42e72 100644
--- a/app/config.go
+++ b/app/config.go
@@ -6,34 +6,34 @@ import (
 	"io/ioutil"
 	"path/filepath"
 
-	"github.com/stevenjack/cig/Godeps/_workspace/src/github.com/mitchellh/go-homedir"
-	"github.com/stevenjack/cig/Godeps/_workspace/src/gopkg.in/yaml.v2"
+	"github.com/mitchellh/go-homedir"
+	"gopkg.in/yaml.v2"
 )
 
 func Config(configPath string) (map[string]string, error) {
-        repoList := make(map[string]string)
-        homeDir, err := homedir.Dir()
+	repoList := make(map[string]string)
+	homeDir, err := homedir.Dir()
 
-        if configPath != "" {
-                homeDir = configPath
+	if configPath != "" {
+		homeDir = configPath
 	}
 
 	if err != nil {
 		return nil, errors.New("Couldn't determine home directory")
 	}
 
-        path := filepath.Join(homeDir, ".cig.yaml")
+	path := filepath.Join(homeDir, ".cig.yaml")
 	data, err := ioutil.ReadFile(path)
 
 	if err != nil {
 		return nil, errors.New(fmt.Sprintf("Can't find config '%s'", path))
 	}
 
-        err = yaml.Unmarshal([]byte(data), &repoList)
+	err = yaml.Unmarshal([]byte(data), &repoList)
 
 	if err != nil {
 		return nil, errors.New(fmt.Sprintf("Problem parsing '%s', please check documentation", path))
 	}
 
-        return repoList, nil
+	return repoList, nil
 }
diff --git a/app/config_test.go b/app/config_test.go
index 9678a1e..5ca9da7 100644
--- a/app/config_test.go
+++ b/app/config_test.go
@@ -5,8 +5,6 @@ import (
 	"os"
 	"path/filepath"
 	"testing"
-
-	"github.com/stevenjack/cig/app"
 )
 
 func TestMapReturnedFromCigYaml(t *testing.T) {
@@ -36,5 +34,5 @@ func TestMalformedYamlRasiesError(t *testing.T) {
 func config(config_path string) (map[string]string, error) {
 	cwd, _ := os.Getwd()
 	path := filepath.Join(cwd, "..", "test", "fixtures", config_path)
-	return app.Config(path)
+	return Config(path)
 }
diff --git a/cig.go b/cig.go
index 1bca219..2c884eb 100644
--- a/cig.go
+++ b/cig.go
@@ -3,7 +3,7 @@ package main
 import (
 	"os"
 
-	"github.com/stevenjack/cig/Godeps/_workspace/src/github.com/codegangsta/cli"
+	"github.com/codegangsta/cli"
 	"github.com/stevenjack/cig/app"
 	"github.com/stevenjack/cig/output"
 )
@@ -11,25 +11,25 @@ import (
 const version string = "0.1.5"
 
 func main() {
-        var outputChannel = make(chan output.Payload)
+	var outputChannel = make(chan output.Payload)
 
-        go output.Wait(outputChannel)
-        cliWrapper := mainApp()
+	go output.Wait(outputChannel)
+	cliWrapper := mainApp()
 
-        cliWrapper.Action = func(context *cli.Context) {
-                configPath := context.String("config-path")
-                projectType := context.String("type")
+	cliWrapper.Action = func(context *cli.Context) {
+		configPath := context.String("config-path")
+		projectType := context.String("type")
 		filter := context.String("filter")
-                repoList, err := app.Config(configPath)
+		repoList, err := app.Config(configPath)
 
 		if err != nil {
-                        outputChannel <- output.FatalError(err.Error())
+			outputChannel <- output.FatalError(err.Error())
 		}
 
-                app.Handle(repoList, projectType, filter, outputChannel)
+		app.Handle(repoList, projectType, filter, outputChannel)
 	}
 
-        cliWrapper.Run(os.Args)
+	cliWrapper.Run(os.Args)
 }
 
 func mainApp() *cli.App {
diff --git a/go.mod b/go.mod
new file mode 100644
index 0000000..e306752
--- /dev/null
+++ b/go.mod
@@ -0,0 +1,12 @@
+module github.com/stevenjack/cig
+
+go 1.15
+
+require (
+	github.com/codegangsta/cli v1.6.0
+	github.com/fatih/color v0.0.0-20150405093723-f952d5afece9
+	github.com/mitchellh/go-homedir v0.0.0-20150417221218-1f6da4a72e57
+	github.com/shiena/ansicolor v0.0.0-20150325140317-8368d3b31cf6 // indirect
+	gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect
+	gopkg.in/yaml.v2 v2.0.0-20141029210843-d466437aa4ad
+)
diff --git a/go.sum b/go.sum
new file mode 100644
index 0000000..521228a
--- /dev/null
+++ b/go.sum
@@ -0,0 +1,17 @@
+github.com/codegangsta/cli v1.6.0 h1:rTJOpNcu6Mw3GrR93gqu8voAwTCo85PsrUKfHmsHC8I=
+github.com/codegangsta/cli v1.6.0/go.mod h1:/qJNoX69yVSKu5o4jLyXAENLRyk1uhi7zkbQ3slBdOA=
+github.com/fatih/color v0.0.0-20150405093723-f952d5afece9 h1:dbXg7qKiFy+5P/94XziJqYFS13rfFO/gywhvMsqGJv0=
+github.com/fatih/color v0.0.0-20150405093723-f952d5afece9/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=
+github.com/kr/pretty v0.2.1 h1:Fmg33tUaq4/8ym9TJN1x7sLJnHVwhP33CNkpYV/7rwI=
+github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
+github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
+github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
+github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
+github.com/mitchellh/go-homedir v0.0.0-20150417221218-1f6da4a72e57 h1:NaCy0CpIjzDYSNT5dpXkmpUkAsUUC93O0S8PjKZ7xDc=
+github.com/mitchellh/go-homedir v0.0.0-20150417221218-1f6da4a72e57/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=
+github.com/shiena/ansicolor v0.0.0-20150325140317-8368d3b31cf6 h1:oEmfKc8oxa36aHwHDVjjgQUSWdQK3y3UklfGVfmktwc=
+github.com/shiena/ansicolor v0.0.0-20150325140317-8368d3b31cf6/go.mod h1:nkxAfR/5quYxwPZhyDxgasBMnRtBZd0FCEpawpjMUFg=
+gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
+gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
+gopkg.in/yaml.v2 v2.0.0-20141029210843-d466437aa4ad h1:3SOi6w/NEma/Ir04qIGumn/RZwbXRhJSM7gN9YN8Ajc=
+gopkg.in/yaml.v2 v2.0.0-20141029210843-d466437aa4ad/go.mod h1:JAlM8MvJe8wmxCU4Bli9HhUf9+ttbYbLASfIpnQbh74=
diff --git a/output/output.go b/output/output.go
index b20e19e..6f90f70 100644
--- a/output/output.go
+++ b/output/output.go
@@ -5,7 +5,7 @@ import (
 	"os"
 	"runtime"
 
-	"github.com/stevenjack/cig/Godeps/_workspace/src/github.com/fatih/color"
+	"github.com/fatih/color"
 )
 
 type Payload struct {
diff --git a/repo/repo.go b/repo/repo.go
index 697caca..103e7ce 100644
--- a/repo/repo.go
+++ b/repo/repo.go
@@ -21,52 +21,52 @@ func Check(root string, path string, outputChannel chan output.Payload, wg *sync
 	}
 
 	if exists {
-                modifiedFiles := exec.Command("git", "status", "--porcelain")
-                modifiedFiles.Dir = path
+		modifiedFiles := exec.Command("git", "status", "--porcelain")
+		modifiedFiles.Dir = path
 
-                countOut, _ := modifiedFiles.Output()
-                modifiedLines := strings.Split(string(countOut), "\n")
-                modified := len(modifiedLines) - 1
+		countOut, _ := modifiedFiles.Output()
+		modifiedLines := strings.Split(string(countOut), "\n")
+		modified := len(modifiedLines) - 1
 
 		if err != nil {
-                        outputChannel <- output.FatalError(err.Error())
+			outputChannel <- output.FatalError(err.Error())
 		}
 
 		changes := []string{}
 
-                if modified > 0 && modifiedLines[0] != "" {
+		if modified > 0 && modifiedLines[0] != "" {
 			changes = append(changes, output.ApplyColour(fmt.Sprintf(" M(%d)", modified), "red"))
 		}
 
 		branch := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
 		branch.Dir = path
 		bstdout, _ := branch.Output()
-                branchName := strings.TrimSpace(string(bstdout[:]))
+		branchName := strings.TrimSpace(string(bstdout[:]))
 
-                local := exec.Command("git", "rev-parse", branchName)
+		local := exec.Command("git", "rev-parse", branchName)
 		local.Dir = path
 		lstdout, _ := local.Output()
-                localRef := strings.TrimSpace(string(lstdout[:]))
+		localRef := strings.TrimSpace(string(lstdout[:]))
 
-                remote := exec.Command("git", "rev-parse", fmt.Sprintf("origin/%s", branchName))
+		remote := exec.Command("git", "rev-parse", fmt.Sprintf("origin/%s", branchName))
 		remote.Dir = path
 		rstdout, err := remote.Output()
-                remoteRef := strings.TrimSpace(string(rstdout[:]))
+		remoteRef := strings.TrimSpace(string(rstdout[:]))
 
-                if err == nil && remoteRef != localRef {
+		if err == nil && remoteRef != localRef {
 			changes = append(changes, output.ApplyColour(" P", "blue"))
 		}
 
 		if len(changes) > 0 {
 			var buffer bytes.Buffer
 
-                        repoName := strings.Replace(path, fmt.Sprintf("%s%s", root, string(os.PathSeparator)), "", -1)
+			repoName := strings.Replace(path, fmt.Sprintf("%s%s", root, string(os.PathSeparator)), "", -1)
 
-                        buffer.WriteString(fmt.Sprintf("- %s (%s)", repoName, branchName))
+			buffer.WriteString(fmt.Sprintf("- %s (%s)", repoName, branchName))
 			for _, change := range changes {
 				buffer.WriteString(change)
 			}
-                        outputChannel <- output.Print(buffer.String())
+			outputChannel <- output.Print(buffer.String())
 		}
 
 	}
-- 
2.29.2

