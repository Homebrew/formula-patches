diff -Npur jdk11u-jdk-11.0.9-ga/make/autoconf/flags.m4 jdk11u-jdk-11.0.9-ga-patched/make/autoconf/flags.m4
--- jdk11u-jdk-11.0.9-ga/make/autoconf/flags.m4	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/make/autoconf/flags.m4	2021-01-16 15:56:28.000000000 +0100
@@ -224,10 +224,12 @@ AC_DEFUN([FLAGS_SETUP_SYSROOT_FLAGS],
     # We also need -iframework<path>/System/Library/Frameworks
     $1SYSROOT_CFLAGS="[$]$1SYSROOT_CFLAGS -iframework [$]$1SYSROOT/System/Library/Frameworks"
     $1SYSROOT_LDFLAGS="[$]$1SYSROOT_LDFLAGS -iframework [$]$1SYSROOT/System/Library/Frameworks"
-    # These always need to be set, or we can't find the frameworks embedded in JavaVM.framework
-    # set this here so it doesn't have to be peppered throughout the forest
-    $1SYSROOT_CFLAGS="[$]$1SYSROOT_CFLAGS -F [$]$1SYSROOT/System/Library/Frameworks/JavaVM.framework/Frameworks"
-    $1SYSROOT_LDFLAGS="[$]$1SYSROOT_LDFLAGS -F [$]$1SYSROOT/System/Library/Frameworks/JavaVM.framework/Frameworks"
+    if test -d "[$]$1SYSROOT/System/Library/Frameworks/JavaVM.framework/Frameworks" ; then
+      # These always need to be set on macOS 10.X, or we can't find the frameworks embedded in JavaVM.framework
+      # set this here so it doesn't have to be peppered throughout the forest
+      $1SYSROOT_CFLAGS="[$]$1SYSROOT_CFLAGS -F [$]$1SYSROOT/System/Library/Frameworks/JavaVM.framework/Frameworks"
+      $1SYSROOT_LDFLAGS="[$]$1SYSROOT_LDFLAGS -F [$]$1SYSROOT/System/Library/Frameworks/JavaVM.framework/Frameworks"
+    fi
   fi
 
   AC_SUBST($1SYSROOT_CFLAGS)
diff -Npur jdk11u-jdk-11.0.9-ga/make/autoconf/hotspot.m4 jdk11u-jdk-11.0.9-ga-patched/make/autoconf/hotspot.m4
--- jdk11u-jdk-11.0.9-ga/make/autoconf/hotspot.m4	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/make/autoconf/hotspot.m4	2021-01-16 15:56:28.000000000 +0100
@@ -245,6 +245,12 @@ AC_DEFUN_ONCE([HOTSPOT_ENABLE_DISABLE_AO
     fi
   fi
 
+  if test "x$ENABLE_AOT" = "xtrue"; then
+    # Disable aot on macos-aarch64 as it's not supported yet
+    if test "x$OPENJDK_TARGET_OS" = "xmacosx" && test "x$OPENJDK_TARGET_CPU" = "xaarch64" ; then
+      ENABLE_AOT="false"
+    fi
+  fi
   AC_SUBST(ENABLE_AOT)
 ])
 
@@ -274,6 +280,14 @@ AC_DEFUN_ONCE([HOTSPOT_ENABLE_DISABLE_CD
     fi
   fi
 
+  # Disable CDS on macos-aarch64
+  if test "x$OPENJDK_TARGET_OS" = "xmacosx" && test "x$OPENJDK_TARGET_CPU" = "xaarch64"; then
+    ENABLE_CDS="false"
+    if test "x$enable_cds" = "xyes"; then
+      AC_MSG_ERROR([CDS is currently not supported on AIX. Remove --enable-cds.])
+    fi
+  fi
+
   AC_SUBST(ENABLE_CDS)
 ])
 
diff -Npur jdk11u-jdk-11.0.9-ga/make/autoconf/platform.m4 jdk11u-jdk-11.0.9-ga-patched/make/autoconf/platform.m4
--- jdk11u-jdk-11.0.9-ga/make/autoconf/platform.m4	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/make/autoconf/platform.m4	2021-01-16 15:56:28.000000000 +0100
@@ -49,10 +49,23 @@ AC_DEFUN([PLATFORM_EXTRACT_VARS_FROM_CPU
       VAR_CPU_ENDIAN=little
       ;;
     arm*)
-      VAR_CPU=arm
-      VAR_CPU_ARCH=arm
-      VAR_CPU_BITS=32
-      VAR_CPU_ENDIAN=little
+      # Second argument is the os name from the trip/quad.
+      # on macos-aarch64, triplet returned by autoconf is
+      # arm-darwin*, but on darwin only aarch64 is present.
+      case "$2" in
+        *darwin*)
+          VAR_CPU=aarch64
+          VAR_CPU_ARCH=aarch64
+          VAR_CPU_BITS=64
+          VAR_CPU_ENDIAN=little
+        ;;
+        *)
+          VAR_CPU=arm
+          VAR_CPU_ARCH=arm
+          VAR_CPU_BITS=32
+          VAR_CPU_ENDIAN=little
+        ;;
+      esac
       ;;
     aarch64)
       VAR_CPU=aarch64
@@ -215,7 +228,7 @@ AC_DEFUN([PLATFORM_EXTRACT_TARGET_AND_BU
 
   # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU variables.
   PLATFORM_EXTRACT_VARS_FROM_OS($build_os)
-  PLATFORM_EXTRACT_VARS_FROM_CPU($build_cpu)
+  PLATFORM_EXTRACT_VARS_FROM_CPU($build_cpu, $build_os)
   # ..and setup our own variables. (Do this explicitly to facilitate searching)
   OPENJDK_BUILD_OS="$VAR_OS"
   if test "x$VAR_OS_TYPE" != x; then
@@ -245,7 +258,7 @@ AC_DEFUN([PLATFORM_EXTRACT_TARGET_AND_BU
 
   # Convert the autoconf OS/CPU value to our own data, into the VAR_OS/CPU variables.
   PLATFORM_EXTRACT_VARS_FROM_OS($host_os)
-  PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu)
+  PLATFORM_EXTRACT_VARS_FROM_CPU($host_cpu, $host_os)
   # ... and setup our own variables. (Do this explicitly to facilitate searching)
   OPENJDK_TARGET_OS="$VAR_OS"
   if test "x$VAR_OS_TYPE" != x; then
diff -Npur jdk11u-jdk-11.0.9-ga/make/autoconf/toolchain.m4 jdk11u-jdk-11.0.9-ga-patched/make/autoconf/toolchain.m4
--- jdk11u-jdk-11.0.9-ga/make/autoconf/toolchain.m4	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/make/autoconf/toolchain.m4	2021-01-16 15:56:28.000000000 +0100
@@ -948,9 +948,14 @@ AC_DEFUN_ONCE([TOOLCHAIN_SETUP_BUILD_COM
     # FIXME: we should list the discovered compilers as an exclude pattern!
     # If we do that, we can do this detection before POST_DETECTION, and still
     # find the build compilers in the tools dir, if needed.
-    BASIC_REQUIRE_PROGS(BUILD_CC, [cl cc gcc])
+    if test "x$OPENJDK_BUILD_OS" = xmacosx; then
+      BASIC_REQUIRE_PROGS(BUILD_CC, [clang cl cc gcc])
+      BASIC_REQUIRE_PROGS(BUILD_CXX, [clang++ cl CC g++])
+    else
+      BASIC_REQUIRE_PROGS(BUILD_CC, [cl cc gcc])
+      BASIC_REQUIRE_PROGS(BUILD_CXX, [cl CC g++])
+    fi
     BASIC_FIXUP_EXECUTABLE(BUILD_CC)
-    BASIC_REQUIRE_PROGS(BUILD_CXX, [cl CC g++])
     BASIC_FIXUP_EXECUTABLE(BUILD_CXX)
     BASIC_PATH_PROGS(BUILD_NM, nm gcc-nm)
     BASIC_FIXUP_EXECUTABLE(BUILD_NM)
diff -Npur jdk11u-jdk-11.0.9-ga/make/common/NativeCompilation.gmk jdk11u-jdk-11.0.9-ga-patched/make/common/NativeCompilation.gmk
--- jdk11u-jdk-11.0.9-ga/make/common/NativeCompilation.gmk	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/make/common/NativeCompilation.gmk	2021-01-16 15:56:28.000000000 +0100
@@ -1189,7 +1189,7 @@ define SetupNativeCompilationBody
                 # This only works if the openjdk_codesign identity is present on the system. Let
                 # silently fail otherwise.
                 ifneq ($(CODESIGN), )
-		  $(CODESIGN) -s "$(MACOSX_CODESIGN_IDENTITY)" --timestamp --options runtime \
+		  $(CODESIGN) -f -s "$(MACOSX_CODESIGN_IDENTITY)" --timestamp --options runtime \
 		      --entitlements $$(call GetEntitlementsFile, $$@) $$@
                 endif
   endif
diff -Npur jdk11u-jdk-11.0.9-ga/make/hotspot/lib/CompileJvm.gmk jdk11u-jdk-11.0.9-ga-patched/make/hotspot/lib/CompileJvm.gmk
--- jdk11u-jdk-11.0.9-ga/make/hotspot/lib/CompileJvm.gmk	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/make/hotspot/lib/CompileJvm.gmk	2021-01-16 15:56:28.000000000 +0100
@@ -57,7 +57,7 @@ JVM_LIBS += \
 JVM_EXCLUDE_FILES += args.cc
 JVM_EXCLUDES += adlc
 
-# Needed by vm_version.cpp
+# Needed by abstract_vm_version.cpp
 ifeq ($(OPENJDK_TARGET_CPU), x86_64)
   OPENJDK_TARGET_CPU_VM_VERSION := amd64
 else ifeq ($(OPENJDK_TARGET_CPU), sparcv9)
@@ -158,7 +158,7 @@ $(eval $(call SetupNativeCompilation, BU
     EXCLUDE_PATTERNS := $(JVM_EXCLUDE_PATTERNS), \
     EXTRA_OBJECT_FILES := $(DTRACE_EXTRA_OBJECT_FILES), \
     CFLAGS := $(JVM_CFLAGS), \
-    vm_version.cpp_CXXFLAGS := $(CFLAGS_VM_VERSION), \
+    abstract_vm_version.cpp_CXXFLAGS := $(CFLAGS_VM_VERSION), \
     arguments.cpp_CXXFLAGS := $(CFLAGS_VM_VERSION), \
     DISABLED_WARNINGS_clang := tautological-compare, \
     DISABLED_WARNINGS_solstudio := $(DISABLED_WARNINGS_solstudio), \
@@ -179,11 +179,11 @@ $(eval $(call SetupNativeCompilation, BU
     PRECOMPILED_HEADER_EXCLUDE := $(JVM_PRECOMPILED_HEADER_EXCLUDE), \
 ))
 
-# Always recompile vm_version.cpp if libjvm needs to be relinked. This ensures
+# Always recompile abstract_vm_version.cpp if libjvm needs to be relinked. This ensures
 # that the internal vm version is updated as it relies on __DATE__ and __TIME__
 # macros.
-VM_VERSION_OBJ := $(JVM_OUTPUTDIR)/objs/vm_version$(OBJ_SUFFIX)
-$(VM_VERSION_OBJ): $(filter-out $(VM_VERSION_OBJ) $(JVM_MAPFILE), \
+ABSTRACT_VM_VERSION_OBJ := $(JVM_OUTPUTDIR)/objs/abstract_vm_version$(OBJ_SUFFIX)
+$(ABSTRACT_VM_VERSION_OBJ): $(filter-out $(ABSTRACT_VM_VERSION_OBJ) $(JVM_MAPFILE), \
     $(BUILD_LIBJVM_TARGET_DEPS))
 
 ifneq ($(GENERATE_COMPILE_COMMANDS_ONLY), true)
diff -Npur jdk11u-jdk-11.0.9-ga/make/lib/Lib-jdk.hotspot.agent.gmk jdk11u-jdk-11.0.9-ga-patched/make/lib/Lib-jdk.hotspot.agent.gmk
--- jdk11u-jdk-11.0.9-ga/make/lib/Lib-jdk.hotspot.agent.gmk	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/make/lib/Lib-jdk.hotspot.agent.gmk	2021-01-16 15:56:28.000000000 +0100
@@ -36,7 +36,7 @@ else ifeq ($(OPENJDK_TARGET_OS), solaris
   SA_LDFLAGS := -mt
 
 else ifeq ($(OPENJDK_TARGET_OS), macosx)
-  SA_CFLAGS := -Damd64 -D_GNU_SOURCE -mno-omit-leaf-frame-pointer \
+  SA_CFLAGS := -D_GNU_SOURCE -mno-omit-leaf-frame-pointer \
       -mstack-alignment=16 -fPIC
   LIBSA_EXTRA_SRC := $(SUPPORT_OUTPUTDIR)/gensrc/jdk.hotspot.agent
 else ifeq ($(OPENJDK_TARGET_OS), windows)
diff -Npur jdk11u-jdk-11.0.9-ga/make/test/JtregNativeJdk.gmk jdk11u-jdk-11.0.9-ga-patched/make/test/JtregNativeJdk.gmk
--- jdk11u-jdk-11.0.9-ga/make/test/JtregNativeJdk.gmk	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/make/test/JtregNativeJdk.gmk	2021-01-16 15:56:28.000000000 +0100
@@ -77,8 +77,8 @@ endif
 
 ifeq ($(OPENJDK_TARGET_OS), macosx)
   BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libTestMainKeyWindow := -ObjC
-  BUILD_JDK_JTREG_LIBRARIES_LIBS_libTestMainKeyWindow := -framework JavaVM \
-      -framework Cocoa -framework JavaNativeFoundation
+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libTestMainKeyWindow := -framework Cocoa \
+      -framework JavaNativeFoundation
 else
   BUILD_JDK_JTREG_EXCLUDE += libTestMainKeyWindow.c
 endif
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/aarch64.ad jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/aarch64.ad
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/aarch64.ad	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/aarch64.ad	2021-01-16 15:56:28.000000000 +0100
@@ -533,7 +533,9 @@ reg_class no_special_reg32_no_fp(
     R15,
     R16,
     R17,
+#ifdef __APPLE__
     R18,
+#endif
     R19,
     R20,
     R21,
@@ -566,7 +568,9 @@ reg_class no_special_reg32_with_fp(
     R15,
     R16,
     R17,
+#ifdef __APPLE__
     R18,
+#endif
     R19,
     R20,
     R21,
@@ -602,7 +606,9 @@ reg_class no_special_reg_no_fp(
     R15, R15_H,
     R16, R16_H,
     R17, R17_H,
+#ifdef __APPLE__
     R18, R18_H,
+#endif
     R19, R19_H,
     R20, R20_H,
     R21, R21_H,
@@ -635,7 +641,9 @@ reg_class no_special_reg_with_fp(
     R15, R15_H,
     R16, R16_H,
     R17, R17_H,
+#ifdef __APPLE__
     R18, R18_H,
+#endif
     R19, R19_H,
     R20, R20_H,
     R21, R21_H,
@@ -1612,7 +1620,7 @@ void MachPrologNode::emit(CodeBuffer &cb
   MacroAssembler _masm(&cbuf);
 
   // n.b. frame size includes space for return pc and rfp
-  const long framesize = C->frame_size_in_bytes();
+  const int framesize = C->frame_size_in_bytes();
   assert(framesize%(2*wordSize) == 0, "must preserve 2*wordSize alignment");
 
   // insert a nop at the start of the prolog so we can patch in a
@@ -2997,7 +3005,7 @@ encode %{
         if (con < (address)(uintptr_t)os::vm_page_size()) {
           __ mov(dst_reg, con);
         } else {
-          unsigned long offset;
+          uint64_t offset;
           __ adrp(dst_reg, con, offset);
           __ add(dst_reg, dst_reg, offset);
         }
@@ -3021,7 +3029,7 @@ encode %{
     MacroAssembler _masm(&cbuf);
     address page = (address)$src$$constant;
     Register dst_reg = as_Register($dst$$reg);
-    unsigned long off;
+    uint64_t off;
     __ adrp(dst_reg, Address(page, relocInfo::poll_type), off);
     assert(off == 0, "assumed offset == 0");
   %}
@@ -4056,7 +4064,7 @@ operand immLoffset16()
 // 32 bit integer valid for add sub immediate
 operand immIAddSub()
 %{
-  predicate(Assembler::operand_valid_for_add_sub_immediate((long)n->get_int()));
+  predicate(Assembler::operand_valid_for_add_sub_immediate((int64_t)n->get_int()));
   match(ConI);
   op_cost(0);
   format %{ %}
@@ -4067,7 +4075,7 @@ operand immIAddSub()
 // TODO -- check this is right when e.g the mask is 0x80000000
 operand immILog()
 %{
-  predicate(Assembler::operand_valid_for_logical_immediate(/*is32*/true, (unsigned long)n->get_int()));
+  predicate(Assembler::operand_valid_for_logical_immediate(/*is32*/true, (uint64_t)n->get_int()));
   match(ConI);
 
   op_cost(0);
@@ -4145,7 +4153,7 @@ operand immLAddSub()
 // 64 bit integer valid for logical immediate
 operand immLLog()
 %{
-  predicate(Assembler::operand_valid_for_logical_immediate(/*is32*/false, (unsigned long)n->get_long()));
+  predicate(Assembler::operand_valid_for_logical_immediate(/*is32*/false, (uint64_t)n->get_long()));
   match(ConL);
   op_cost(0);
   format %{ %}
@@ -10235,6 +10243,9 @@ instruct rShiftL_reg_imm(iRegLNoSp dst, 
 
 // BEGIN This section of the file is automatically generated. Do not edit --------------
 
+
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct regL_not_reg(iRegLNoSp dst,
                          iRegL src1, immL_M1 m1,
                          rFlagsReg cr) %{
@@ -10251,6 +10262,9 @@ instruct regL_not_reg(iRegLNoSp dst,
 
   ins_pipe(ialu_reg);
 %}
+
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct regI_not_reg(iRegINoSp dst,
                          iRegIorL2I src1, immI_M1 m1,
                          rFlagsReg cr) %{
@@ -10268,6 +10282,8 @@ instruct regI_not_reg(iRegINoSp dst,
   ins_pipe(ialu_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndI_reg_not_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2, immI_M1 m1,
                          rFlagsReg cr) %{
@@ -10285,6 +10301,8 @@ instruct AndI_reg_not_reg(iRegINoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndL_reg_not_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2, immL_M1 m1,
                          rFlagsReg cr) %{
@@ -10302,6 +10320,8 @@ instruct AndL_reg_not_reg(iRegLNoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrI_reg_not_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2, immI_M1 m1,
                          rFlagsReg cr) %{
@@ -10319,6 +10339,8 @@ instruct OrI_reg_not_reg(iRegINoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrL_reg_not_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2, immL_M1 m1,
                          rFlagsReg cr) %{
@@ -10336,6 +10358,8 @@ instruct OrL_reg_not_reg(iRegLNoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorI_reg_not_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2, immI_M1 m1,
                          rFlagsReg cr) %{
@@ -10353,6 +10377,8 @@ instruct XorI_reg_not_reg(iRegINoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorL_reg_not_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2, immL_M1 m1,
                          rFlagsReg cr) %{
@@ -10370,6 +10396,8 @@ instruct XorL_reg_not_reg(iRegLNoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndI_reg_URShift_not_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, immI_M1 src4, rFlagsReg cr) %{
@@ -10388,6 +10416,8 @@ instruct AndI_reg_URShift_not_reg(iRegIN
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndL_reg_URShift_not_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, immL_M1 src4, rFlagsReg cr) %{
@@ -10406,6 +10436,8 @@ instruct AndL_reg_URShift_not_reg(iRegLN
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndI_reg_RShift_not_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, immI_M1 src4, rFlagsReg cr) %{
@@ -10424,6 +10456,8 @@ instruct AndI_reg_RShift_not_reg(iRegINo
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndL_reg_RShift_not_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, immL_M1 src4, rFlagsReg cr) %{
@@ -10442,6 +10476,8 @@ instruct AndL_reg_RShift_not_reg(iRegLNo
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndI_reg_LShift_not_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, immI_M1 src4, rFlagsReg cr) %{
@@ -10460,6 +10496,8 @@ instruct AndI_reg_LShift_not_reg(iRegINo
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndL_reg_LShift_not_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, immL_M1 src4, rFlagsReg cr) %{
@@ -10478,6 +10516,8 @@ instruct AndL_reg_LShift_not_reg(iRegLNo
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorI_reg_URShift_not_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, immI_M1 src4, rFlagsReg cr) %{
@@ -10496,6 +10536,8 @@ instruct XorI_reg_URShift_not_reg(iRegIN
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorL_reg_URShift_not_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, immL_M1 src4, rFlagsReg cr) %{
@@ -10514,6 +10556,8 @@ instruct XorL_reg_URShift_not_reg(iRegLN
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorI_reg_RShift_not_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, immI_M1 src4, rFlagsReg cr) %{
@@ -10532,6 +10576,8 @@ instruct XorI_reg_RShift_not_reg(iRegINo
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorL_reg_RShift_not_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, immL_M1 src4, rFlagsReg cr) %{
@@ -10550,6 +10596,8 @@ instruct XorL_reg_RShift_not_reg(iRegLNo
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorI_reg_LShift_not_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, immI_M1 src4, rFlagsReg cr) %{
@@ -10568,6 +10616,8 @@ instruct XorI_reg_LShift_not_reg(iRegINo
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorL_reg_LShift_not_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, immL_M1 src4, rFlagsReg cr) %{
@@ -10586,6 +10636,8 @@ instruct XorL_reg_LShift_not_reg(iRegLNo
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrI_reg_URShift_not_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, immI_M1 src4, rFlagsReg cr) %{
@@ -10604,6 +10656,8 @@ instruct OrI_reg_URShift_not_reg(iRegINo
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrL_reg_URShift_not_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, immL_M1 src4, rFlagsReg cr) %{
@@ -10622,6 +10676,8 @@ instruct OrL_reg_URShift_not_reg(iRegLNo
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrI_reg_RShift_not_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, immI_M1 src4, rFlagsReg cr) %{
@@ -10640,6 +10696,8 @@ instruct OrI_reg_RShift_not_reg(iRegINoS
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrL_reg_RShift_not_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, immL_M1 src4, rFlagsReg cr) %{
@@ -10658,6 +10716,8 @@ instruct OrL_reg_RShift_not_reg(iRegLNoS
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrI_reg_LShift_not_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, immI_M1 src4, rFlagsReg cr) %{
@@ -10676,6 +10736,8 @@ instruct OrI_reg_LShift_not_reg(iRegINoS
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrL_reg_LShift_not_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, immL_M1 src4, rFlagsReg cr) %{
@@ -10694,6 +10756,8 @@ instruct OrL_reg_LShift_not_reg(iRegLNoS
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndI_reg_URShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -10713,6 +10777,8 @@ instruct AndI_reg_URShift_reg(iRegINoSp 
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndL_reg_URShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -10732,6 +10798,8 @@ instruct AndL_reg_URShift_reg(iRegLNoSp 
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndI_reg_RShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -10751,6 +10819,8 @@ instruct AndI_reg_RShift_reg(iRegINoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndL_reg_RShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -10770,6 +10840,8 @@ instruct AndL_reg_RShift_reg(iRegLNoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndI_reg_LShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -10789,6 +10861,8 @@ instruct AndI_reg_LShift_reg(iRegINoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AndL_reg_LShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -10808,6 +10882,8 @@ instruct AndL_reg_LShift_reg(iRegLNoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorI_reg_URShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -10827,6 +10903,8 @@ instruct XorI_reg_URShift_reg(iRegINoSp 
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorL_reg_URShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -10846,6 +10924,8 @@ instruct XorL_reg_URShift_reg(iRegLNoSp 
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorI_reg_RShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -10865,6 +10945,8 @@ instruct XorI_reg_RShift_reg(iRegINoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorL_reg_RShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -10884,6 +10966,8 @@ instruct XorL_reg_RShift_reg(iRegLNoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorI_reg_LShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -10903,6 +10987,8 @@ instruct XorI_reg_LShift_reg(iRegINoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct XorL_reg_LShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -10922,6 +11008,8 @@ instruct XorL_reg_LShift_reg(iRegLNoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrI_reg_URShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -10941,6 +11029,8 @@ instruct OrI_reg_URShift_reg(iRegINoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrL_reg_URShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -10960,6 +11050,8 @@ instruct OrL_reg_URShift_reg(iRegLNoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrI_reg_RShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -10979,6 +11071,8 @@ instruct OrI_reg_RShift_reg(iRegINoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrL_reg_RShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -10998,6 +11092,8 @@ instruct OrL_reg_RShift_reg(iRegLNoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrI_reg_LShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -11017,6 +11113,8 @@ instruct OrI_reg_LShift_reg(iRegINoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct OrL_reg_LShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -11036,6 +11134,8 @@ instruct OrL_reg_LShift_reg(iRegLNoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddI_reg_URShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -11055,6 +11155,8 @@ instruct AddI_reg_URShift_reg(iRegINoSp 
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddL_reg_URShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -11074,6 +11176,8 @@ instruct AddL_reg_URShift_reg(iRegLNoSp 
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddI_reg_RShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -11093,6 +11197,8 @@ instruct AddI_reg_RShift_reg(iRegINoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddL_reg_RShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -11112,6 +11218,8 @@ instruct AddL_reg_RShift_reg(iRegLNoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddI_reg_LShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -11131,6 +11239,8 @@ instruct AddI_reg_LShift_reg(iRegINoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddL_reg_LShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -11150,6 +11260,8 @@ instruct AddL_reg_LShift_reg(iRegLNoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubI_reg_URShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -11169,6 +11281,8 @@ instruct SubI_reg_URShift_reg(iRegINoSp 
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubL_reg_URShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -11188,6 +11302,8 @@ instruct SubL_reg_URShift_reg(iRegLNoSp 
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubI_reg_RShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -11207,6 +11323,8 @@ instruct SubI_reg_RShift_reg(iRegINoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubL_reg_RShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -11226,6 +11344,8 @@ instruct SubL_reg_RShift_reg(iRegLNoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubI_reg_LShift_reg(iRegINoSp dst,
                          iRegIorL2I src1, iRegIorL2I src2,
                          immI src3, rFlagsReg cr) %{
@@ -11245,6 +11365,8 @@ instruct SubI_reg_LShift_reg(iRegINoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubL_reg_LShift_reg(iRegLNoSp dst,
                          iRegL src1, iRegL src2,
                          immI src3, rFlagsReg cr) %{
@@ -11264,7 +11386,9 @@ instruct SubL_reg_LShift_reg(iRegLNoSp d
   ins_pipe(ialu_reg_reg_shift);
 %}
 
-
+ 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 
 // Shift Left followed by Shift Right.
 // This idiom is used by the compiler for the i2b bytecode etc.
@@ -11289,6 +11413,9 @@ instruct sbfmL(iRegLNoSp dst, iRegL src,
   ins_pipe(ialu_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
 // Shift Left followed by Shift Right.
 // This idiom is used by the compiler for the i2b bytecode etc.
 instruct sbfmwI(iRegINoSp dst, iRegIorL2I src, immI lshift_count, immI rshift_count)
@@ -11312,6 +11439,9 @@ instruct sbfmwI(iRegINoSp dst, iRegIorL2
   ins_pipe(ialu_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
 // Shift Left followed by Shift Right.
 // This idiom is used by the compiler for the i2b bytecode etc.
 instruct ubfmL(iRegLNoSp dst, iRegL src, immI lshift_count, immI rshift_count)
@@ -11335,6 +11465,9 @@ instruct ubfmL(iRegLNoSp dst, iRegL src,
   ins_pipe(ialu_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
 // Shift Left followed by Shift Right.
 // This idiom is used by the compiler for the i2b bytecode etc.
 instruct ubfmwI(iRegINoSp dst, iRegIorL2I src, immI lshift_count, immI rshift_count)
@@ -11357,8 +11490,11 @@ instruct ubfmwI(iRegINoSp dst, iRegIorL2
 
   ins_pipe(ialu_reg_shift);
 %}
+
 // Bitfield extract with shift & mask
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct ubfxwI(iRegINoSp dst, iRegIorL2I src, immI rshift, immI_bitmask mask)
 %{
   match(Set dst (AndI (URShiftI src rshift) mask));
@@ -11369,13 +11505,16 @@ instruct ubfxwI(iRegINoSp dst, iRegIorL2
   format %{ "ubfxw $dst, $src, $rshift, $mask" %}
   ins_encode %{
     int rshift = $rshift$$constant & 31;
-    long mask = $mask$$constant;
+    intptr_t mask = $mask$$constant;
     int width = exact_log2(mask+1);
     __ ubfxw(as_Register($dst$$reg),
             as_Register($src$$reg), rshift, width);
   %}
   ins_pipe(ialu_reg_shift);
 %}
+
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct ubfxL(iRegLNoSp dst, iRegL src, immI rshift, immL_bitmask mask)
 %{
   match(Set dst (AndL (URShiftL src rshift) mask));
@@ -11386,7 +11525,7 @@ instruct ubfxL(iRegLNoSp dst, iRegL src,
   format %{ "ubfx $dst, $src, $rshift, $mask" %}
   ins_encode %{
     int rshift = $rshift$$constant & 63;
-    long mask = $mask$$constant;
+    intptr_t mask = $mask$$constant;
     int width = exact_log2_long(mask+1);
     __ ubfx(as_Register($dst$$reg),
             as_Register($src$$reg), rshift, width);
@@ -11394,6 +11533,10 @@ instruct ubfxL(iRegLNoSp dst, iRegL src,
   ins_pipe(ialu_reg_shift);
 %}
 
+
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
 // We can use ubfx when extending an And with a mask when we know mask
 // is positive.  We know that because immI_bitmask guarantees it.
 instruct ubfxIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI rshift, immI_bitmask mask)
@@ -11406,7 +11549,7 @@ instruct ubfxIConvI2L(iRegLNoSp dst, iRe
   format %{ "ubfx $dst, $src, $rshift, $mask" %}
   ins_encode %{
     int rshift = $rshift$$constant & 31;
-    long mask = $mask$$constant;
+    intptr_t mask = $mask$$constant;
     int width = exact_log2(mask+1);
     __ ubfx(as_Register($dst$$reg),
             as_Register($src$$reg), rshift, width);
@@ -11414,6 +11557,10 @@ instruct ubfxIConvI2L(iRegLNoSp dst, iRe
   ins_pipe(ialu_reg_shift);
 %}
 
+
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
 // We can use ubfiz when masking by a positive number and then left shifting the result.
 // We know that the mask is positive because immI_bitmask guarantees it.
 instruct ubfizwI(iRegINoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
@@ -11426,13 +11573,17 @@ instruct ubfizwI(iRegINoSp dst, iRegIorL
   format %{ "ubfizw $dst, $src, $lshift, $mask" %}
   ins_encode %{
     int lshift = $lshift$$constant;
-    long mask = $mask$$constant;
+    intptr_t mask = $mask$$constant;
     int width = exact_log2(mask+1);
     __ ubfizw(as_Register($dst$$reg),
           as_Register($src$$reg), lshift, width);
   %}
   ins_pipe(ialu_reg_shift);
 %}
+
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
 // We can use ubfiz when masking by a positive number and then left shifting the result.
 // We know that the mask is positive because immL_bitmask guarantees it.
 instruct ubfizL(iRegLNoSp dst, iRegL src, immI lshift, immL_bitmask mask)
@@ -11445,7 +11596,7 @@ instruct ubfizL(iRegLNoSp dst, iRegL src
   format %{ "ubfiz $dst, $src, $lshift, $mask" %}
   ins_encode %{
     int lshift = $lshift$$constant;
-    long mask = $mask$$constant;
+    intptr_t mask = $mask$$constant;
     int width = exact_log2_long(mask+1);
     __ ubfiz(as_Register($dst$$reg),
           as_Register($src$$reg), lshift, width);
@@ -11453,6 +11604,10 @@ instruct ubfizL(iRegLNoSp dst, iRegL src
   ins_pipe(ialu_reg_shift);
 %}
 
+
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
 // If there is a convert I to L block between and AndI and a LShiftL, we can also match ubfiz
 instruct ubfizIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
 %{
@@ -11464,7 +11619,7 @@ instruct ubfizIConvI2L(iRegLNoSp dst, iR
   format %{ "ubfiz $dst, $src, $lshift, $mask" %}
   ins_encode %{
     int lshift = $lshift$$constant;
-    long mask = $mask$$constant;
+    intptr_t mask = $mask$$constant;
     int width = exact_log2(mask+1);
     __ ubfiz(as_Register($dst$$reg),
              as_Register($src$$reg), lshift, width);
@@ -11472,8 +11627,10 @@ instruct ubfizIConvI2L(iRegLNoSp dst, iR
   ins_pipe(ialu_reg_shift);
 %}
 
-// Rotations
 
+// Rotations 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct extrOrL(iRegLNoSp dst, iRegL src1, iRegL src2, immI lshift, immI rshift, rFlagsReg cr)
 %{
   match(Set dst (OrL (LShiftL src1 lshift) (URShiftL src2 rshift)));
@@ -11489,6 +11646,9 @@ instruct extrOrL(iRegLNoSp dst, iRegL sr
   ins_pipe(ialu_reg_reg_extr);
 %}
 
+
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct extrOrI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI lshift, immI rshift, rFlagsReg cr)
 %{
   match(Set dst (OrI (LShiftI src1 lshift) (URShiftI src2 rshift)));
@@ -11504,6 +11664,9 @@ instruct extrOrI(iRegINoSp dst, iRegIorL
   ins_pipe(ialu_reg_reg_extr);
 %}
 
+
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct extrAddL(iRegLNoSp dst, iRegL src1, iRegL src2, immI lshift, immI rshift, rFlagsReg cr)
 %{
   match(Set dst (AddL (LShiftL src1 lshift) (URShiftL src2 rshift)));
@@ -11519,6 +11682,9 @@ instruct extrAddL(iRegLNoSp dst, iRegL s
   ins_pipe(ialu_reg_reg_extr);
 %}
 
+
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct extrAddI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI lshift, immI rshift, rFlagsReg cr)
 %{
   match(Set dst (AddI (LShiftI src1 lshift) (URShiftI src2 rshift)));
@@ -11535,8 +11701,10 @@ instruct extrAddI(iRegINoSp dst, iRegIor
 %}
 
 
-// rol expander
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 
+// rol expander
 instruct rolL_rReg(iRegLNoSp dst, iRegL src, iRegI shift, rFlagsReg cr)
 %{
   effect(DEF dst, USE src, USE shift);
@@ -11551,8 +11719,10 @@ instruct rolL_rReg(iRegLNoSp dst, iRegL 
   ins_pipe(ialu_reg_reg_vshift);
 %}
 
-// rol expander
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 
+// rol expander
 instruct rolI_rReg(iRegINoSp dst, iRegI src, iRegI shift, rFlagsReg cr)
 %{
   effect(DEF dst, USE src, USE shift);
@@ -11567,6 +11737,8 @@ instruct rolI_rReg(iRegINoSp dst, iRegI 
   ins_pipe(ialu_reg_reg_vshift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct rolL_rReg_Var_C_64(iRegLNoSp dst, iRegL src, iRegI shift, immI_64 c_64, rFlagsReg cr)
 %{
   match(Set dst (OrL (LShiftL src shift) (URShiftL src (SubI c_64 shift))));
@@ -11576,6 +11748,8 @@ instruct rolL_rReg_Var_C_64(iRegLNoSp ds
   %}
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct rolL_rReg_Var_C0(iRegLNoSp dst, iRegL src, iRegI shift, immI0 c0, rFlagsReg cr)
 %{
   match(Set dst (OrL (LShiftL src shift) (URShiftL src (SubI c0 shift))));
@@ -11585,6 +11759,8 @@ instruct rolL_rReg_Var_C0(iRegLNoSp dst,
   %}
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct rolI_rReg_Var_C_32(iRegINoSp dst, iRegI src, iRegI shift, immI_32 c_32, rFlagsReg cr)
 %{
   match(Set dst (OrI (LShiftI src shift) (URShiftI src (SubI c_32 shift))));
@@ -11594,6 +11770,8 @@ instruct rolI_rReg_Var_C_32(iRegINoSp ds
   %}
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct rolI_rReg_Var_C0(iRegINoSp dst, iRegI src, iRegI shift, immI0 c0, rFlagsReg cr)
 %{
   match(Set dst (OrI (LShiftI src shift) (URShiftI src (SubI c0 shift))));
@@ -11603,8 +11781,10 @@ instruct rolI_rReg_Var_C0(iRegINoSp dst,
   %}
 %}
 
-// ror expander
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 
+// ror expander
 instruct rorL_rReg(iRegLNoSp dst, iRegL src, iRegI shift, rFlagsReg cr)
 %{
   effect(DEF dst, USE src, USE shift);
@@ -11618,8 +11798,10 @@ instruct rorL_rReg(iRegLNoSp dst, iRegL 
   ins_pipe(ialu_reg_reg_vshift);
 %}
 
-// ror expander
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 
+// ror expander
 instruct rorI_rReg(iRegINoSp dst, iRegI src, iRegI shift, rFlagsReg cr)
 %{
   effect(DEF dst, USE src, USE shift);
@@ -11633,6 +11815,8 @@ instruct rorI_rReg(iRegINoSp dst, iRegI 
   ins_pipe(ialu_reg_reg_vshift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct rorL_rReg_Var_C_64(iRegLNoSp dst, iRegL src, iRegI shift, immI_64 c_64, rFlagsReg cr)
 %{
   match(Set dst (OrL (URShiftL src shift) (LShiftL src (SubI c_64 shift))));
@@ -11642,6 +11826,8 @@ instruct rorL_rReg_Var_C_64(iRegLNoSp ds
   %}
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct rorL_rReg_Var_C0(iRegLNoSp dst, iRegL src, iRegI shift, immI0 c0, rFlagsReg cr)
 %{
   match(Set dst (OrL (URShiftL src shift) (LShiftL src (SubI c0 shift))));
@@ -11651,6 +11837,8 @@ instruct rorL_rReg_Var_C0(iRegLNoSp dst,
   %}
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct rorI_rReg_Var_C_32(iRegINoSp dst, iRegI src, iRegI shift, immI_32 c_32, rFlagsReg cr)
 %{
   match(Set dst (OrI (URShiftI src shift) (LShiftI src (SubI c_32 shift))));
@@ -11660,6 +11848,8 @@ instruct rorI_rReg_Var_C_32(iRegINoSp ds
   %}
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct rorI_rReg_Var_C0(iRegINoSp dst, iRegI src, iRegI shift, immI0 c0, rFlagsReg cr)
 %{
   match(Set dst (OrI (URShiftI src shift) (LShiftI src (SubI c0 shift))));
@@ -11669,8 +11859,11 @@ instruct rorI_rReg_Var_C0(iRegINoSp dst,
   %}
 %}
 
+
 // Add/subtract (extended)
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtI(iRegLNoSp dst, iRegL src1, iRegIorL2I src2, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (ConvI2L src2)));
@@ -11682,8 +11875,10 @@ instruct AddExtI(iRegLNoSp dst, iRegL sr
             as_Register($src2$$reg), ext::sxtw);
    %}
   ins_pipe(ialu_reg_reg);
-%};
+%}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtI(iRegLNoSp dst, iRegL src1, iRegIorL2I src2, rFlagsReg cr)
 %{
   match(Set dst (SubL src1 (ConvI2L src2)));
@@ -11695,9 +11890,10 @@ instruct SubExtI(iRegLNoSp dst, iRegL sr
             as_Register($src2$$reg), ext::sxtw);
    %}
   ins_pipe(ialu_reg_reg);
-%};
-
+%}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtI_sxth(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI_16 lshift, immI_16 rshift, rFlagsReg cr)
 %{
   match(Set dst (AddI src1 (RShiftI (LShiftI src2 lshift) rshift)));
@@ -11711,6 +11907,8 @@ instruct AddExtI_sxth(iRegINoSp dst, iRe
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtI_sxtb(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI_24 lshift, immI_24 rshift, rFlagsReg cr)
 %{
   match(Set dst (AddI src1 (RShiftI (LShiftI src2 lshift) rshift)));
@@ -11724,6 +11922,8 @@ instruct AddExtI_sxtb(iRegINoSp dst, iRe
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtI_uxtb(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI_24 lshift, immI_24 rshift, rFlagsReg cr)
 %{
   match(Set dst (AddI src1 (URShiftI (LShiftI src2 lshift) rshift)));
@@ -11737,6 +11937,8 @@ instruct AddExtI_uxtb(iRegINoSp dst, iRe
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtL_sxth(iRegLNoSp dst, iRegL src1, iRegL src2, immI_48 lshift, immI_48 rshift, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (RShiftL (LShiftL src2 lshift) rshift)));
@@ -11750,6 +11952,8 @@ instruct AddExtL_sxth(iRegLNoSp dst, iRe
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtL_sxtw(iRegLNoSp dst, iRegL src1, iRegL src2, immI_32 lshift, immI_32 rshift, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (RShiftL (LShiftL src2 lshift) rshift)));
@@ -11763,6 +11967,8 @@ instruct AddExtL_sxtw(iRegLNoSp dst, iRe
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtL_sxtb(iRegLNoSp dst, iRegL src1, iRegL src2, immI_56 lshift, immI_56 rshift, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (RShiftL (LShiftL src2 lshift) rshift)));
@@ -11776,6 +11982,8 @@ instruct AddExtL_sxtb(iRegLNoSp dst, iRe
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtL_uxtb(iRegLNoSp dst, iRegL src1, iRegL src2, immI_56 lshift, immI_56 rshift, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (URShiftL (LShiftL src2 lshift) rshift)));
@@ -11789,7 +11997,8 @@ instruct AddExtL_uxtb(iRegLNoSp dst, iRe
   ins_pipe(ialu_reg_reg);
 %}
 
-
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtI_uxtb_and(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI_255 mask, rFlagsReg cr)
 %{
   match(Set dst (AddI src1 (AndI src2 mask)));
@@ -11803,6 +12012,8 @@ instruct AddExtI_uxtb_and(iRegINoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtI_uxth_and(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI_65535 mask, rFlagsReg cr)
 %{
   match(Set dst (AddI src1 (AndI src2 mask)));
@@ -11816,6 +12027,8 @@ instruct AddExtI_uxth_and(iRegINoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtL_uxtb_and(iRegLNoSp dst, iRegL src1, iRegL src2, immL_255 mask, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (AndL src2 mask)));
@@ -11829,6 +12042,8 @@ instruct AddExtL_uxtb_and(iRegLNoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtL_uxth_and(iRegLNoSp dst, iRegL src1, iRegL src2, immL_65535 mask, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (AndL src2 mask)));
@@ -11842,6 +12057,8 @@ instruct AddExtL_uxth_and(iRegLNoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtL_uxtw_and(iRegLNoSp dst, iRegL src1, iRegL src2, immL_4294967295 mask, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (AndL src2 mask)));
@@ -11855,6 +12072,8 @@ instruct AddExtL_uxtw_and(iRegLNoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtI_uxtb_and(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI_255 mask, rFlagsReg cr)
 %{
   match(Set dst (SubI src1 (AndI src2 mask)));
@@ -11868,6 +12087,8 @@ instruct SubExtI_uxtb_and(iRegINoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtI_uxth_and(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI_65535 mask, rFlagsReg cr)
 %{
   match(Set dst (SubI src1 (AndI src2 mask)));
@@ -11881,6 +12102,8 @@ instruct SubExtI_uxth_and(iRegINoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtL_uxtb_and(iRegLNoSp dst, iRegL src1, iRegL src2, immL_255 mask, rFlagsReg cr)
 %{
   match(Set dst (SubL src1 (AndL src2 mask)));
@@ -11894,6 +12117,8 @@ instruct SubExtL_uxtb_and(iRegLNoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtL_uxth_and(iRegLNoSp dst, iRegL src1, iRegL src2, immL_65535 mask, rFlagsReg cr)
 %{
   match(Set dst (SubL src1 (AndL src2 mask)));
@@ -11907,6 +12132,8 @@ instruct SubExtL_uxth_and(iRegLNoSp dst,
   ins_pipe(ialu_reg_reg);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtL_uxtw_and(iRegLNoSp dst, iRegL src1, iRegL src2, immL_4294967295 mask, rFlagsReg cr)
 %{
   match(Set dst (SubL src1 (AndL src2 mask)));
@@ -11921,6 +12148,8 @@ instruct SubExtL_uxtw_and(iRegLNoSp dst,
 %}
 
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtL_sxtb_shift(iRegLNoSp dst, iRegL src1, iRegL src2, immIExt lshift2, immI_56 lshift1, immI_56 rshift1, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (LShiftL (RShiftL (LShiftL src2 lshift1) rshift1) lshift2)));
@@ -11934,6 +12163,8 @@ instruct AddExtL_sxtb_shift(iRegLNoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtL_sxth_shift(iRegLNoSp dst, iRegL src1, iRegL src2, immIExt lshift2, immI_48 lshift1, immI_48 rshift1, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (LShiftL (RShiftL (LShiftL src2 lshift1) rshift1) lshift2)));
@@ -11947,6 +12178,8 @@ instruct AddExtL_sxth_shift(iRegLNoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtL_sxtw_shift(iRegLNoSp dst, iRegL src1, iRegL src2, immIExt lshift2, immI_32 lshift1, immI_32 rshift1, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (LShiftL (RShiftL (LShiftL src2 lshift1) rshift1) lshift2)));
@@ -11960,6 +12193,8 @@ instruct AddExtL_sxtw_shift(iRegLNoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtL_sxtb_shift(iRegLNoSp dst, iRegL src1, iRegL src2, immIExt lshift2, immI_56 lshift1, immI_56 rshift1, rFlagsReg cr)
 %{
   match(Set dst (SubL src1 (LShiftL (RShiftL (LShiftL src2 lshift1) rshift1) lshift2)));
@@ -11973,6 +12208,8 @@ instruct SubExtL_sxtb_shift(iRegLNoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtL_sxth_shift(iRegLNoSp dst, iRegL src1, iRegL src2, immIExt lshift2, immI_48 lshift1, immI_48 rshift1, rFlagsReg cr)
 %{
   match(Set dst (SubL src1 (LShiftL (RShiftL (LShiftL src2 lshift1) rshift1) lshift2)));
@@ -11986,6 +12223,8 @@ instruct SubExtL_sxth_shift(iRegLNoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtL_sxtw_shift(iRegLNoSp dst, iRegL src1, iRegL src2, immIExt lshift2, immI_32 lshift1, immI_32 rshift1, rFlagsReg cr)
 %{
   match(Set dst (SubL src1 (LShiftL (RShiftL (LShiftL src2 lshift1) rshift1) lshift2)));
@@ -11999,6 +12238,8 @@ instruct SubExtL_sxtw_shift(iRegLNoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtI_sxtb_shift(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immIExt lshift2, immI_24 lshift1, immI_24 rshift1, rFlagsReg cr)
 %{
   match(Set dst (AddI src1 (LShiftI (RShiftI (LShiftI src2 lshift1) rshift1) lshift2)));
@@ -12012,6 +12253,8 @@ instruct AddExtI_sxtb_shift(iRegINoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtI_sxth_shift(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immIExt lshift2, immI_16 lshift1, immI_16 rshift1, rFlagsReg cr)
 %{
   match(Set dst (AddI src1 (LShiftI (RShiftI (LShiftI src2 lshift1) rshift1) lshift2)));
@@ -12025,6 +12268,8 @@ instruct AddExtI_sxth_shift(iRegINoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtI_sxtb_shift(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immIExt lshift2, immI_24 lshift1, immI_24 rshift1, rFlagsReg cr)
 %{
   match(Set dst (SubI src1 (LShiftI (RShiftI (LShiftI src2 lshift1) rshift1) lshift2)));
@@ -12038,6 +12283,8 @@ instruct SubExtI_sxtb_shift(iRegINoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtI_sxth_shift(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immIExt lshift2, immI_16 lshift1, immI_16 rshift1, rFlagsReg cr)
 %{
   match(Set dst (SubI src1 (LShiftI (RShiftI (LShiftI src2 lshift1) rshift1) lshift2)));
@@ -12051,7 +12298,8 @@ instruct SubExtI_sxth_shift(iRegINoSp ds
   ins_pipe(ialu_reg_reg_shift);
 %}
 
-
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtI_shift(iRegLNoSp dst, iRegL src1, iRegIorL2I src2, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (LShiftL (ConvI2L src2) lshift)));
@@ -12063,8 +12311,10 @@ instruct AddExtI_shift(iRegLNoSp dst, iR
             as_Register($src2$$reg), ext::sxtw, ($lshift$$constant));
    %}
   ins_pipe(ialu_reg_reg_shift);
-%};
+%}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtI_shift(iRegLNoSp dst, iRegL src1, iRegIorL2I src2, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst (SubL src1 (LShiftL (ConvI2L src2) lshift)));
@@ -12076,9 +12326,10 @@ instruct SubExtI_shift(iRegLNoSp dst, iR
             as_Register($src2$$reg), ext::sxtw, ($lshift$$constant));
    %}
   ins_pipe(ialu_reg_reg_shift);
-%};
-
+%}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtL_uxtb_and_shift(iRegLNoSp dst, iRegL src1, iRegL src2, immL_255 mask, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (LShiftL (AndL src2 mask) lshift)));
@@ -12092,6 +12343,8 @@ instruct AddExtL_uxtb_and_shift(iRegLNoS
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtL_uxth_and_shift(iRegLNoSp dst, iRegL src1, iRegL src2, immL_65535 mask, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (LShiftL (AndL src2 mask) lshift)));
@@ -12105,6 +12358,8 @@ instruct AddExtL_uxth_and_shift(iRegLNoS
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtL_uxtw_and_shift(iRegLNoSp dst, iRegL src1, iRegL src2, immL_4294967295 mask, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst (AddL src1 (LShiftL (AndL src2 mask) lshift)));
@@ -12118,6 +12373,8 @@ instruct AddExtL_uxtw_and_shift(iRegLNoS
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtL_uxtb_and_shift(iRegLNoSp dst, iRegL src1, iRegL src2, immL_255 mask, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst (SubL src1 (LShiftL (AndL src2 mask) lshift)));
@@ -12131,6 +12388,8 @@ instruct SubExtL_uxtb_and_shift(iRegLNoS
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtL_uxth_and_shift(iRegLNoSp dst, iRegL src1, iRegL src2, immL_65535 mask, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst (SubL src1 (LShiftL (AndL src2 mask) lshift)));
@@ -12144,6 +12403,8 @@ instruct SubExtL_uxth_and_shift(iRegLNoS
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtL_uxtw_and_shift(iRegLNoSp dst, iRegL src1, iRegL src2, immL_4294967295 mask, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst (SubL src1 (LShiftL (AndL src2 mask) lshift)));
@@ -12157,6 +12418,8 @@ instruct SubExtL_uxtw_and_shift(iRegLNoS
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtI_uxtb_and_shift(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI_255 mask, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst (AddI src1 (LShiftI (AndI src2 mask) lshift)));
@@ -12170,6 +12433,8 @@ instruct AddExtI_uxtb_and_shift(iRegINoS
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct AddExtI_uxth_and_shift(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI_65535 mask, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst (AddI src1 (LShiftI (AndI src2 mask) lshift)));
@@ -12183,6 +12448,8 @@ instruct AddExtI_uxth_and_shift(iRegINoS
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtI_uxtb_and_shift(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI_255 mask, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst (SubI src1 (LShiftI (AndI src2 mask) lshift)));
@@ -12196,6 +12463,8 @@ instruct SubExtI_uxtb_and_shift(iRegINoS
   ins_pipe(ialu_reg_reg_shift);
 %}
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct SubExtI_uxth_and_shift(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, immI_65535 mask, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst (SubI src1 (LShiftI (AndI src2 mask) lshift)));
@@ -12208,8 +12477,12 @@ instruct SubExtI_uxth_and_shift(iRegINoS
    %}
   ins_pipe(ialu_reg_reg_shift);
 %}
+
+
+
 // END This section of the file is automatically generated. Do not edit --------------
 
+
 // ============================================================================
 // Floating Point Arithmetic Instructions
 
@@ -12587,7 +12860,7 @@ instruct andI_reg_imm(iRegINoSp dst, iRe
   ins_encode %{
     __ andw(as_Register($dst$$reg),
             as_Register($src1$$reg),
-            (unsigned long)($src2$$constant));
+            (uint64_t)($src2$$constant));
   %}
 
   ins_pipe(ialu_reg_imm);
@@ -12619,7 +12892,7 @@ instruct orI_reg_imm(iRegINoSp dst, iReg
   ins_encode %{
     __ orrw(as_Register($dst$$reg),
             as_Register($src1$$reg),
-            (unsigned long)($src2$$constant));
+            (uint64_t)($src2$$constant));
   %}
 
   ins_pipe(ialu_reg_imm);
@@ -12651,7 +12924,7 @@ instruct xorI_reg_imm(iRegINoSp dst, iRe
   ins_encode %{
     __ eorw(as_Register($dst$$reg),
             as_Register($src1$$reg),
-            (unsigned long)($src2$$constant));
+            (uint64_t)($src2$$constant));
   %}
 
   ins_pipe(ialu_reg_imm);
@@ -12684,7 +12957,7 @@ instruct andL_reg_imm(iRegLNoSp dst, iRe
   ins_encode %{
     __ andr(as_Register($dst$$reg),
             as_Register($src1$$reg),
-            (unsigned long)($src2$$constant));
+            (uint64_t)($src2$$constant));
   %}
 
   ins_pipe(ialu_reg_imm);
@@ -12716,7 +12989,7 @@ instruct orL_reg_imm(iRegLNoSp dst, iReg
   ins_encode %{
     __ orr(as_Register($dst$$reg),
            as_Register($src1$$reg),
-           (unsigned long)($src2$$constant));
+           (uint64_t)($src2$$constant));
   %}
 
   ins_pipe(ialu_reg_imm);
@@ -12748,7 +13021,7 @@ instruct xorL_reg_imm(iRegLNoSp dst, iRe
   ins_encode %{
     __ eor(as_Register($dst$$reg),
            as_Register($src1$$reg),
-           (unsigned long)($src2$$constant));
+           (uint64_t)($src2$$constant));
   %}
 
   ins_pipe(ialu_reg_imm);
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/aarch64_ad.m4 jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/aarch64_ad.m4
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/aarch64_ad.m4	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/aarch64_ad.m4	2021-01-16 15:56:28.000000000 +0100
@@ -1,4 +1,4 @@
-dnl Copyright (c) 2014, Red Hat Inc. All rights reserved.
+dnl Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
 dnl DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 dnl
 dnl This code is free software; you can redistribute it and/or modify it
@@ -23,12 +23,12 @@ dnl 
 dnl Process this file with m4 aarch64_ad.m4 to generate the arithmetic
 dnl and shift patterns patterns used in aarch64.ad.
 dnl
-// BEGIN This section of the file is automatically generated. Do not edit --------------
 dnl
 define(`ORL2I', `ifelse($1,I,orL2I)')
 dnl
 define(`BASE_SHIFT_INSN',
-`
+`// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct $2$1_reg_$4_reg(iReg$1NoSp dst,
                          iReg$1`'ORL2I($1) src1, iReg$1`'ORL2I($1) src2,
                          immI src3, rFlagsReg cr) %{
@@ -46,9 +46,11 @@ instruct $2$1_reg_$4_reg(iReg$1NoSp dst,
   %}
 
   ins_pipe(ialu_reg_reg_shift);
-%}')dnl
+%}
+')dnl
 define(`BASE_INVERTED_INSN',
-`
+`// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct $2$1_reg_not_reg(iReg$1NoSp dst,
                          iReg$1`'ORL2I($1) src1, iReg$1`'ORL2I($1) src2, imm$1_M1 m1,
                          rFlagsReg cr) %{
@@ -68,9 +70,11 @@ dnl into this canonical form.
   %}
 
   ins_pipe(ialu_reg_reg);
-%}')dnl
+%}
+')dnl
 define(`INVERTED_SHIFT_INSN',
-`
+`// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct $2$1_reg_$4_not_reg(iReg$1NoSp dst,
                          iReg$1`'ORL2I($1) src1, iReg$1`'ORL2I($1) src2,
                          immI src3, imm$1_M1 src4, rFlagsReg cr) %{
@@ -91,9 +95,12 @@ dnl into this canonical form.
   %}
 
   ins_pipe(ialu_reg_reg_shift);
-%}')dnl
+%}
+')dnl
 define(`NOT_INSN',
-`instruct reg$1_not_reg(iReg$1NoSp dst,
+`// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+instruct reg$1_not_reg(iReg$1NoSp dst,
                          iReg$1`'ORL2I($1) src1, imm$1_M1 m1,
                          rFlagsReg cr) %{
   match(Set dst (Xor$1 src1 m1));
@@ -108,7 +115,8 @@ define(`NOT_INSN',
   %}
 
   ins_pipe(ialu_reg);
-%}')dnl
+%}
+')dnl
 dnl
 define(`BOTH_SHIFT_INSNS',
 `BASE_SHIFT_INSN(I, $1, ifelse($2,andr,andw,$2w), $3, $4)
@@ -120,7 +128,7 @@ BASE_INVERTED_INSN(L, $1, $2, $3, $4)')d
 dnl
 define(`BOTH_INVERTED_SHIFT_INSNS',
 `INVERTED_SHIFT_INSN(I, $1, $2w, $3, $4, ~0, int)
-INVERTED_SHIFT_INSN(L, $1, $2, $3, $4, ~0l, long)')dnl
+INVERTED_SHIFT_INSN(L, $1, $2, $3, $4, ~0l, jlong)')dnl
 dnl
 define(`ALL_SHIFT_KINDS',
 `BOTH_SHIFT_INSNS($1, $2, URShift, LSR)
@@ -147,8 +155,10 @@ ALL_SHIFT_KINDS(Add, add)
 ALL_SHIFT_KINDS(Sub, sub)
 dnl
 dnl EXTEND mode, rshift_op, src, lshift_count, rshift_count
-define(`EXTEND', `($2$1 (LShift$1 $3 $4) $5)')
-define(`BFM_INSN',`
+define(`EXTEND', `($2$1 (LShift$1 $3 $4) $5)') dnl
+define(`BFM_INSN',`// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
 // Shift Left followed by Shift Right.
 // This idiom is used by the compiler for the i2b bytecode etc.
 instruct $4$1(iReg$1NoSp dst, iReg$1`'ORL2I($1) src, immI lshift_count, immI rshift_count)
@@ -170,7 +180,8 @@ instruct $4$1(iReg$1NoSp dst, iReg$1`'OR
   %}
 
   ins_pipe(ialu_reg_shift);
-%}')
+%}
+')
 BFM_INSN(L, 63, RShift, sbfm)
 BFM_INSN(I, 31, RShift, sbfmw)
 BFM_INSN(L, 63, URShift, ubfm)
@@ -178,7 +189,9 @@ BFM_INSN(I, 31, URShift, ubfmw)
 dnl
 // Bitfield extract with shift & mask
 define(`BFX_INSN',
-`instruct $3$1(iReg$1NoSp dst, iReg$1`'ORL2I($1) src, immI rshift, imm$1_bitmask mask)
+`// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+instruct $3$1(iReg$1NoSp dst, iReg$1`'ORL2I($1) src, immI rshift, imm$1_bitmask mask)
 %{
   match(Set dst (And$1 ($2$1 src rshift) mask));
   // Make sure we are not going to exceed what $3 can do.
@@ -188,16 +201,20 @@ define(`BFX_INSN',
   format %{ "$3 $dst, $src, $rshift, $mask" %}
   ins_encode %{
     int rshift = $rshift$$constant & $4;
-    long mask = $mask$$constant;
+    intptr_t mask = $mask$$constant;
     int width = exact_log2$6(mask+1);
     __ $3(as_Register($dst$$reg),
             as_Register($src$$reg), rshift, width);
   %}
   ins_pipe(ialu_reg_shift);
-%}')
+%}
+')
 BFX_INSN(I, URShift, ubfxw, 31, int)
 BFX_INSN(L, URShift, ubfx,  63, long, _long)
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
 // We can use ubfx when extending an And with a mask when we know mask
 // is positive.  We know that because immI_bitmask guarantees it.
 instruct ubfxIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI rshift, immI_bitmask mask)
@@ -210,7 +227,7 @@ instruct ubfxIConvI2L(iRegLNoSp dst, iRe
   format %{ "ubfx $dst, $src, $rshift, $mask" %}
   ins_encode %{
     int rshift = $rshift$$constant & 31;
-    long mask = $mask$$constant;
+    intptr_t mask = $mask$$constant;
     int width = exact_log2(mask+1);
     __ ubfx(as_Register($dst$$reg),
             as_Register($src$$reg), rshift, width);
@@ -218,10 +235,12 @@ instruct ubfxIConvI2L(iRegLNoSp dst, iRe
   ins_pipe(ialu_reg_shift);
 %}
 
-define(`UBFIZ_INSN',
+define(`UBFIZ_INSN', `// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
 // We can use ubfiz when masking by a positive number and then left shifting the result.
 // We know that the mask is positive because imm$1_bitmask guarantees it.
-`instruct $2$1(iReg$1NoSp dst, iReg$1`'ORL2I($1) src, immI lshift, imm$1_bitmask mask)
+instruct $2$1(iReg$1NoSp dst, iReg$1`'ORL2I($1) src, immI lshift, imm$1_bitmask mask)
 %{
   match(Set dst (LShift$1 (And$1 src mask) lshift));
   predicate((unsigned int)n->in(2)->get_int() <= $3 &&
@@ -231,16 +250,20 @@ define(`UBFIZ_INSN',
   format %{ "$2 $dst, $src, $lshift, $mask" %}
   ins_encode %{
     int lshift = $lshift$$constant;
-    long mask = $mask$$constant;
+    intptr_t mask = $mask$$constant;
     int width = exact_log2$5(mask+1);
     __ $2(as_Register($dst$$reg),
           as_Register($src$$reg), lshift, width);
   %}
   ins_pipe(ialu_reg_shift);
-%}')
+%}
+')
 UBFIZ_INSN(I, ubfizw, 31, int)
 UBFIZ_INSN(L, ubfiz, 63, long, _long)
 
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+
 // If there is a convert I to L block between and AndI and a LShiftL, we can also match ubfiz
 instruct ubfizIConvI2L(iRegLNoSp dst, iRegIorL2I src, immI lshift, immI_bitmask mask)
 %{
@@ -252,7 +275,7 @@ instruct ubfizIConvI2L(iRegLNoSp dst, iR
   format %{ "ubfiz $dst, $src, $lshift, $mask" %}
   ins_encode %{
     int lshift = $lshift$$constant;
-    long mask = $mask$$constant;
+    intptr_t mask = $mask$$constant;
     int width = exact_log2(mask+1);
     __ ubfiz(as_Register($dst$$reg),
              as_Register($src$$reg), lshift, width);
@@ -260,10 +283,12 @@ instruct ubfizIConvI2L(iRegLNoSp dst, iR
   ins_pipe(ialu_reg_shift);
 %}
 
-// Rotations
 
-define(`EXTRACT_INSN',
-`instruct extr$3$1(iReg$1NoSp dst, iReg$1`'ORL2I($1) src1, iReg$1`'ORL2I($1) src2, immI lshift, immI rshift, rFlagsReg cr)
+// Rotations dnl
+define(`EXTRACT_INSN',`
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
+instruct extr$3$1(iReg$1NoSp dst, iReg$1`'ORL2I($1) src1, iReg$1`'ORL2I($1) src2, immI lshift, immI rshift, rFlagsReg cr)
 %{
   match(Set dst ($3$1 (LShift$1 src1 lshift) (URShift$1 src2 rshift)));
   predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & $2));
@@ -282,9 +307,10 @@ EXTRACT_INSN(L, 63, Or, extr)
 EXTRACT_INSN(I, 31, Or, extrw)
 EXTRACT_INSN(L, 63, Add, extr)
 EXTRACT_INSN(I, 31, Add, extrw)
-define(`ROL_EXPAND', `
-// $2 expander
+define(`ROL_EXPAND', `// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 
+// $2 expander
 instruct $2$1_rReg(iReg$1NoSp dst, iReg$1 src, iRegI shift, rFlagsReg cr)
 %{
   effect(DEF dst, USE src, USE shift);
@@ -297,10 +323,12 @@ instruct $2$1_rReg(iReg$1NoSp dst, iReg$
             rscratch1);
     %}
   ins_pipe(ialu_reg_reg_vshift);
-%}')dnl
-define(`ROR_EXPAND', `
-// $2 expander
+%}
+')
+define(`ROR_EXPAND', `// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 
+// $2 expander
 instruct $2$1_rReg(iReg$1NoSp dst, iReg$1 src, iRegI shift, rFlagsReg cr)
 %{
   effect(DEF dst, USE src, USE shift);
@@ -312,8 +340,10 @@ instruct $2$1_rReg(iReg$1NoSp dst, iReg$
             as_Register($shift$$reg));
     %}
   ins_pipe(ialu_reg_reg_vshift);
-%}')dnl
-define(ROL_INSN, `
+%}
+')dnl
+define(ROL_INSN, `// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct $3$1_rReg_Var_C$2(iReg$1NoSp dst, iReg$1 src, iRegI shift, immI$2 c$2, rFlagsReg cr)
 %{
   match(Set dst (Or$1 (LShift$1 src shift) (URShift$1 src (SubI c$2 shift))));
@@ -321,8 +351,10 @@ instruct $3$1_rReg_Var_C$2(iReg$1NoSp ds
   expand %{
     $3$1_rReg(dst, src, shift, cr);
   %}
-%}')dnl
-define(ROR_INSN, `
+%}
+')dnl
+define(ROR_INSN, `// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct $3$1_rReg_Var_C$2(iReg$1NoSp dst, iReg$1 src, iRegI shift, immI$2 c$2, rFlagsReg cr)
 %{
   match(Set dst (Or$1 (URShift$1 src shift) (LShift$1 src (SubI c$2 shift))));
@@ -330,7 +362,8 @@ instruct $3$1_rReg_Var_C$2(iReg$1NoSp ds
   expand %{
     $3$1_rReg(dst, src, shift, cr);
   %}
-%}')dnl
+%}
+')dnl
 ROL_EXPAND(L, rol, rorv)
 ROL_EXPAND(I, rol, rorvw)
 ROL_INSN(L, _64, rol)
@@ -347,6 +380,8 @@ ROR_INSN(I, 0, ror)
 // Add/subtract (extended)
 dnl ADD_SUB_EXTENDED(mode, size, add node, shift node, insn, shift type, wordsize
 define(`ADD_SUB_CONV', `
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct $3Ext$1(iReg$2NoSp dst, iReg$2`'ORL2I($2) src1, iReg$1`'ORL2I($1) src2, rFlagsReg cr)
 %{
   match(Set dst ($3$2 src1 (ConvI2L src2)));
@@ -359,10 +394,12 @@ instruct $3Ext$1(iReg$2NoSp dst, iReg$2`
    %}
   ins_pipe(ialu_reg_reg);
 %}')dnl
-ADD_SUB_CONV(I,L,Add,add,sxtw);
-ADD_SUB_CONV(I,L,Sub,sub,sxtw);
+ADD_SUB_CONV(I,L,Add,add,sxtw)
+ADD_SUB_CONV(I,L,Sub,sub,sxtw)
 dnl
 define(`ADD_SUB_EXTENDED', `
+// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct $3Ext$1_$6(iReg$1NoSp dst, iReg$1`'ORL2I($1) src1, iReg$1`'ORL2I($1) src2, immI_`'eval($7-$2) lshift, immI_`'eval($7-$2) rshift, rFlagsReg cr)
 %{
   match(Set dst ($3$1 src1 EXTEND($1, $4, src2, lshift, rshift)));
@@ -374,7 +411,7 @@ instruct $3Ext$1_$6(iReg$1NoSp dst, iReg
             as_Register($src2$$reg), ext::$6);
    %}
   ins_pipe(ialu_reg_reg);
-%}')
+%}')dnl
 ADD_SUB_EXTENDED(I,16,Add,RShift,add,sxth,32)
 ADD_SUB_EXTENDED(I,8,Add,RShift,add,sxtb,32)
 ADD_SUB_EXTENDED(I,8,Add,URShift,add,uxtb,32)
@@ -384,7 +421,8 @@ ADD_SUB_EXTENDED(L,8,Add,RShift,add,sxtb
 ADD_SUB_EXTENDED(L,8,Add,URShift,add,uxtb,64)
 dnl
 dnl ADD_SUB_ZERO_EXTEND(mode, size, add node, insn, shift type)
-define(`ADD_SUB_ZERO_EXTEND', `
+define(`ADD_SUB_ZERO_EXTEND', `// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct $3Ext$1_$5_and(iReg$1NoSp dst, iReg$1`'ORL2I($1) src1, iReg$1`'ORL2I($1) src2, imm$1_$2 mask, rFlagsReg cr)
 %{
   match(Set dst ($3$1 src1 (And$1 src2 mask)));
@@ -396,7 +434,8 @@ instruct $3Ext$1_$5_and(iReg$1NoSp dst, 
             as_Register($src2$$reg), ext::$5);
    %}
   ins_pipe(ialu_reg_reg);
-%}')
+%}
+')
 dnl
 ADD_SUB_ZERO_EXTEND(I,255,Add,addw,uxtb)
 ADD_SUB_ZERO_EXTEND(I,65535,Add,addw,uxth)
@@ -411,7 +450,8 @@ ADD_SUB_ZERO_EXTEND(L,65535,Sub,sub,uxth
 ADD_SUB_ZERO_EXTEND(L,4294967295,Sub,sub,uxtw)
 dnl
 dnl ADD_SUB_ZERO_EXTEND_SHIFT(mode, size, add node, insn, ext type)
-define(`ADD_SUB_EXTENDED_SHIFT', `
+define(`ADD_SUB_EXTENDED_SHIFT', `// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct $3Ext$1_$6_shift(iReg$1NoSp dst, iReg$1`'ORL2I($1) src1, iReg$1`'ORL2I($1) src2, immIExt lshift2, immI_`'eval($7-$2) lshift1, immI_`'eval($7-$2) rshift1, rFlagsReg cr)
 %{
   match(Set dst ($3$1 src1 (LShift$1 EXTEND($1, $4, src2, lshift1, rshift1) lshift2)));
@@ -423,7 +463,8 @@ instruct $3Ext$1_$6_shift(iReg$1NoSp dst
             as_Register($src2$$reg), ext::$6, ($lshift2$$constant));
    %}
   ins_pipe(ialu_reg_reg_shift);
-%}')
+%}
+')
 dnl                   $1 $2 $3   $4   $5   $6  $7
 ADD_SUB_EXTENDED_SHIFT(L,8,Add,RShift,add,sxtb,64)
 ADD_SUB_EXTENDED_SHIFT(L,16,Add,RShift,add,sxth,64)
@@ -440,7 +481,8 @@ ADD_SUB_EXTENDED_SHIFT(I,8,Sub,RShift,su
 ADD_SUB_EXTENDED_SHIFT(I,16,Sub,RShift,subw,sxth,32)
 dnl
 dnl ADD_SUB_CONV_SHIFT(mode, add node, insn, ext type)
-define(`ADD_SUB_CONV_SHIFT', `
+define(`ADD_SUB_CONV_SHIFT', `// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct $2ExtI_shift(iReg$1NoSp dst, iReg$1`'ORL2I($1) src1, iRegIorL2I src2, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst ($2$1 src1 (LShiftL (ConvI2L src2) lshift)));
@@ -452,13 +494,14 @@ instruct $2ExtI_shift(iReg$1NoSp dst, iR
             as_Register($src2$$reg), ext::$4, ($lshift$$constant));
    %}
   ins_pipe(ialu_reg_reg_shift);
-%}')
-dnl
-ADD_SUB_CONV_SHIFT(L,Add,add,sxtw);
-ADD_SUB_CONV_SHIFT(L,Sub,sub,sxtw);
+%}
+')dnl
+ADD_SUB_CONV_SHIFT(L,Add,add,sxtw)
+ADD_SUB_CONV_SHIFT(L,Sub,sub,sxtw)
 dnl
 dnl ADD_SUB_ZERO_EXTEND(mode, size, add node, insn, ext type)
-define(`ADD_SUB_ZERO_EXTEND_SHIFT', `
+define(`ADD_SUB_ZERO_EXTEND_SHIFT', `// This pattern is automatically generated from aarch64_ad.m4
+// DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
 instruct $3Ext$1_$5_and_shift(iReg$1NoSp dst, iReg$1`'ORL2I($1) src1, iReg$1`'ORL2I($1) src2, imm$1_$2 mask, immIExt lshift, rFlagsReg cr)
 %{
   match(Set dst ($3$1 src1 (LShift$1 (And$1 src2 mask) lshift)));
@@ -470,8 +513,8 @@ instruct $3Ext$1_$5_and_shift(iReg$1NoSp
             as_Register($src2$$reg), ext::$5, ($lshift$$constant));
    %}
   ins_pipe(ialu_reg_reg_shift);
-%}')
-dnl
+%}
+')dnl
 dnl                       $1 $2  $3  $4  $5
 ADD_SUB_ZERO_EXTEND_SHIFT(L,255,Add,add,uxtb)
 ADD_SUB_ZERO_EXTEND_SHIFT(L,65535,Add,add,uxth)
@@ -487,4 +530,4 @@ dnl
 ADD_SUB_ZERO_EXTEND_SHIFT(I,255,Sub,subw,uxtb)
 ADD_SUB_ZERO_EXTEND_SHIFT(I,65535,Sub,subw,uxth)
 dnl
-// END This section of the file is automatically generated. Do not edit --------------
+
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/assembler_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/assembler_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/assembler_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/assembler_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -31,7 +31,7 @@
 #include "interpreter/interpreter.hpp"
 
 #ifndef PRODUCT
-const unsigned long Assembler::asm_bp = 0x00007fffee09ac88;
+const uintptr_t Assembler::asm_bp = 0x00007fffee09ac88;
 #endif
 
 #include "compiler/disassembler.hpp"
@@ -134,14 +134,14 @@ void entry(CodeBuffer *cb) {
     __ subs(r11, r5, 582u);                            //       subs    x11, x5, #582
 
 // LogicalImmOp
-    __ andw(r23, r22, 32768ul);                        //       and     w23, w22, #0x8000
-    __ orrw(r4, r10, 4042322160ul);                    //       orr     w4, w10, #0xf0f0f0f0
-    __ eorw(r0, r24, 4042322160ul);                    //       eor     w0, w24, #0xf0f0f0f0
-    __ andsw(r19, r29, 2139127680ul);                  //       ands    w19, w29, #0x7f807f80
-    __ andr(r5, r10, 4503599627354112ul);              //       and     x5, x10, #0xfffffffffc000
-    __ orr(r12, r30, 18445618178097414144ul);          //       orr     x12, x30, #0xfffc0000fffc0000
-    __ eor(r30, r5, 262128ul);                         //       eor     x30, x5, #0x3fff0
-    __ ands(r26, r23, 4194300ul);                      //       ands    x26, x23, #0x3ffffc
+    __ andw(r23, r22, 32768ull);                        //       and     w23, w22, #0x8000
+    __ orrw(r4, r10, 4042322160ull);                    //       orr     w4, w10, #0xf0f0f0f0
+    __ eorw(r0, r24, 4042322160ull);                    //       eor     w0, w24, #0xf0f0f0f0
+    __ andsw(r19, r29, 2139127680ull);                  //       ands    w19, w29, #0x7f807f80
+    __ andr(r5, r10, 4503599627354112ull);              //       and     x5, x10, #0xfffffffffc000
+    __ orr(r12, r30, 18445618178097414144ull);          //       orr     x12, x30, #0xfffc0000fffc0000
+    __ eor(r30, r5, 262128ull);                         //       eor     x30, x5, #0x3fff0
+    __ ands(r26, r23, 4194300ull);                      //       ands    x26, x23, #0x3ffffc
 
 // AbsOp
     __ b(__ pc());                                     //       b       .
@@ -1226,7 +1226,7 @@ extern "C" {
       Disassembler::decode((address)start, (address)start + len);
   }
 
-  JNIEXPORT void das1(unsigned long insn) {
+  JNIEXPORT void das1(uintptr_t insn) {
     das(insn, 1);
   }
 }
@@ -1265,7 +1265,7 @@ void Address::lea(MacroAssembler *as, Re
   }
 }
 
-void Assembler::adrp(Register reg1, const Address &dest, unsigned long &byte_offset) {
+void Assembler::adrp(Register reg1, const Address &dest, uint64_t &byte_offset) {
   ShouldNotReachHere();
 }
 
@@ -1274,7 +1274,7 @@ void Assembler::adrp(Register reg1, cons
 #define starti Instruction_aarch64 do_not_use(this); set_current(&do_not_use)
 
   void Assembler::adr(Register Rd, address adr) {
-    long offset = adr - pc();
+    intptr_t offset = adr - pc();
     int offset_lo = offset & 3;
     offset >>= 2;
     starti;
@@ -1285,7 +1285,7 @@ void Assembler::adrp(Register reg1, cons
   void Assembler::_adrp(Register Rd, address adr) {
     uint64_t pc_page = (uint64_t)pc() >> 12;
     uint64_t adr_page = (uint64_t)adr >> 12;
-    long offset = adr_page - pc_page;
+    intptr_t offset = adr_page - pc_page;
     int offset_lo = offset & 3;
     offset >>= 2;
     starti;
@@ -1434,9 +1434,8 @@ void Assembler::add_sub_immediate(Regist
   srf(Rn, 5);
 }
 
-bool Assembler::operand_valid_for_add_sub_immediate(long imm) {
-  bool shift = false;
-  unsigned long uimm = uabs(imm);
+bool Assembler::operand_valid_for_add_sub_immediate(int64_t imm) {
+  uint64_t uimm = (uint64_t)uabs((jlong)imm);
   if (uimm < (1 << 12))
     return true;
   if (uimm < (1 << 24)
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/assembler_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/assembler_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/assembler_aarch64.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/assembler_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -199,7 +199,7 @@ public:
     return extend(uval, msb - lsb);
   }
 
-  static void patch(address a, int msb, int lsb, unsigned long val) {
+  static void patch(address a, int msb, int lsb, uint64_t val) {
     int nbits = msb - lsb + 1;
     guarantee(val < (1U << nbits), "Field too big for insn");
     assert_cond(msb >= lsb);
@@ -212,9 +212,9 @@ public:
     *(unsigned *)a = target;
   }
 
-  static void spatch(address a, int msb, int lsb, long val) {
+  static void spatch(address a, int msb, int lsb, int64_t val) {
     int nbits = msb - lsb + 1;
-    long chk = val >> (nbits - 1);
+    int64_t chk = val >> (nbits - 1);
     guarantee (chk == -1 || chk == 0, "Field too big for insn");
     unsigned uval = val;
     unsigned mask = (1U << nbits) - 1;
@@ -245,9 +245,9 @@ public:
     f(val, bit, bit);
   }
 
-  void sf(long val, int msb, int lsb) {
+  void sf(int64_t val, int msb, int lsb) {
     int nbits = msb - lsb + 1;
-    long chk = val >> (nbits - 1);
+    int64_t chk = val >> (nbits - 1);
     guarantee (chk == -1 || chk == 0, "Field too big for insn");
     unsigned uval = val;
     unsigned mask = (1U << nbits) - 1;
@@ -355,7 +355,7 @@ class Address {
  private:
   Register _base;
   Register _index;
-  long _offset;
+  int64_t _offset;
   enum mode _mode;
   extend _ext;
 
@@ -380,8 +380,14 @@ class Address {
     : _mode(base_plus_offset), _base(r), _offset(o), _index(noreg), _target(0) { }
   Address(Register r, long o)
     : _mode(base_plus_offset), _base(r), _offset(o), _index(noreg), _target(0) { }
+  Address(Register r, long long o)
+    : _mode(base_plus_offset), _base(r), _offset(o), _index(noreg), _target(0) { }
+  Address(Register r, unsigned int o)
+    : _mode(base_plus_offset), _base(r), _offset(o), _index(noreg), _target(0) { }
   Address(Register r, unsigned long o)
     : _mode(base_plus_offset), _base(r), _offset(o), _index(noreg), _target(0) { }
+  Address(Register r, unsigned long long o)
+    : _mode(base_plus_offset), _base(r), _offset(o), _index(noreg), _target(0) { }
 #ifdef ASSERT
   Address(Register r, ByteSize disp)
     : _mode(base_plus_offset), _base(r), _offset(in_bytes(disp)),
@@ -421,7 +427,7 @@ class Address {
               "wrong mode");
     return _base;
   }
-  long offset() const {
+  int64_t offset() const {
     return _offset;
   }
   Register index() const {
@@ -553,10 +559,10 @@ class Address {
 
   void lea(MacroAssembler *, Register) const;
 
-  static bool offset_ok_for_immed(long offset, int shift = 0) {
+  static bool offset_ok_for_immed(int64_t offset, int shift = 0) {
     unsigned mask = (1 << shift) - 1;
     if (offset < 0 || offset & mask) {
-      return (uabs(offset) < (1 << (20 - 12))); // Unscaled offset
+      return (uabs((julong)offset) < (1 << (20 - 12))); // Unscaled offset
     } else {
       return ((offset >> shift) < (1 << (21 - 10 + 1))); // Scaled, unsigned offset
     }
@@ -613,10 +619,10 @@ typedef enum {
 class Assembler : public AbstractAssembler {
 
 #ifndef PRODUCT
-  static const unsigned long asm_bp;
+  static const uintptr_t asm_bp;
 
   void emit_long(jint x) {
-    if ((unsigned long)pc() == asm_bp)
+    if ((uintptr_t)pc() == asm_bp)
       asm volatile ("nop");
     AbstractAssembler::emit_int32(x);
   }
@@ -659,7 +665,7 @@ public:
   void f(unsigned val, int msb) {
     current->f(val, msb, msb);
   }
-  void sf(long val, int msb, int lsb) {
+  void sf(int64_t val, int msb, int lsb) {
     current->sf(val, msb, lsb);
   }
   void rf(Register reg, int lsb) {
@@ -709,7 +715,7 @@ public:
     wrap_label(Rd, L, &Assembler::_adrp);
   }
 
-  void adrp(Register Rd, const Address &dest, unsigned long &offset);
+  void adrp(Register Rd, const Address &dest, uint64_t &offset);
 
 #undef INSN
 
@@ -833,7 +839,7 @@ public:
   // architecture.  In debug mode we shrink it in order to test
   // trampolines, but not so small that branches in the interpreter
   // are out of range.
-  static const unsigned long branch_range = NOT_DEBUG(128 * M) DEBUG_ONLY(2 * M);
+  static const uint64_t branch_range = NOT_DEBUG(128 * M) DEBUG_ONLY(2 * M);
 
   static bool reachable_from_branch_at(address branch, address target) {
     return uabs(target - branch) < branch_range;
@@ -843,7 +849,7 @@ public:
 #define INSN(NAME, opcode)                                              \
   void NAME(address dest) {                                             \
     starti;                                                             \
-    long offset = (dest - pc()) >> 2;                                   \
+    int64_t offset = (dest - pc()) >> 2;                                \
     DEBUG_ONLY(assert(reachable_from_branch_at(pc(), dest), "debug only")); \
     f(opcode, 31), f(0b00101, 30, 26), sf(offset, 25, 0);               \
   }                                                                     \
@@ -860,7 +866,7 @@ public:
   // Compare & branch (immediate)
 #define INSN(NAME, opcode)                              \
   void NAME(Register Rt, address dest) {                \
-    long offset = (dest - pc()) >> 2;                   \
+    int64_t offset = (dest - pc()) >> 2;                \
     starti;                                             \
     f(opcode, 31, 24), sf(offset, 23, 5), rf(Rt, 0);    \
   }                                                     \
@@ -878,7 +884,7 @@ public:
   // Test & branch (immediate)
 #define INSN(NAME, opcode)                                              \
   void NAME(Register Rt, int bitpos, address dest) {                    \
-    long offset = (dest - pc()) >> 2;                                   \
+    int64_t offset = (dest - pc()) >> 2;                                \
     int b5 = bitpos >> 5;                                               \
     bitpos &= 0x1f;                                                     \
     starti;                                                             \
@@ -899,7 +905,7 @@ public:
     {EQ, NE, HS, CS=HS, LO, CC=LO, MI, PL, VS, VC, HI, LS, GE, LT, GT, LE, AL, NV};
 
   void br(Condition  cond, address dest) {
-    long offset = (dest - pc()) >> 2;
+    int64_t offset = (dest - pc()) >> 2;
     starti;
     f(0b0101010, 31, 25), f(0, 24), sf(offset, 23, 5), f(0, 4), f(cond, 3, 0);
   }
@@ -1278,7 +1284,7 @@ public:
   // Load register (literal)
 #define INSN(NAME, opc, V)                                              \
   void NAME(Register Rt, address dest) {                                \
-    long offset = (dest - pc()) >> 2;                                   \
+    int64_t offset = (dest - pc()) >> 2;                                \
     starti;                                                             \
     f(opc, 31, 30), f(0b011, 29, 27), f(V, 26), f(0b00, 25, 24),        \
       sf(offset, 23, 5);                                                \
@@ -1303,7 +1309,7 @@ public:
 
 #define INSN(NAME, opc, V)                                              \
   void NAME(FloatRegister Rt, address dest) {                           \
-    long offset = (dest - pc()) >> 2;                                   \
+    int64_t offset = (dest - pc()) >> 2;                                \
     starti;                                                             \
     f(opc, 31, 30), f(0b011, 29, 27), f(V, 26), f(0b00, 25, 24),        \
       sf(offset, 23, 5);                                                \
@@ -1318,7 +1324,7 @@ public:
 
 #define INSN(NAME, opc, V)                                              \
   void NAME(address dest, prfop op = PLDL1KEEP) {                       \
-    long offset = (dest - pc()) >> 2;                                   \
+    int64_t offset = (dest - pc()) >> 2;                                \
     starti;                                                             \
     f(opc, 31, 30), f(0b011, 29, 27), f(V, 26), f(0b00, 25, 24),        \
       sf(offset, 23, 5);                                                \
@@ -1394,7 +1400,7 @@ public:
       assert(size == 0b10 || size == 0b11, "bad operand size in ldr");
       assert(op == 0b01, "literal form can only be used with loads");
       f(size & 0b01, 31, 30), f(0b011, 29, 27), f(0b00, 25, 24);
-      long offset = (adr.target() - pc()) >> 2;
+      int64_t offset = (adr.target() - pc()) >> 2;
       sf(offset, 23, 5);
       code_section()->relocate(pc(), adr.rspec());
       return;
@@ -2612,7 +2618,7 @@ void ext(FloatRegister Vd, SIMD_Arrangem
   virtual void bang_stack_with_offset(int offset);
 
   static bool operand_valid_for_logical_immediate(bool is32, uint64_t imm);
-  static bool operand_valid_for_add_sub_immediate(long imm);
+  static bool operand_valid_for_add_sub_immediate(int64_t imm);
   static bool operand_valid_for_float_immediate(double imm);
 
   void emit_data64(jlong data, relocInfo::relocType rtype, int format = 0);
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/c1_Defs_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/c1_Defs_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/c1_Defs_aarch64.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/c1_Defs_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -44,13 +44,13 @@ enum {
   pd_nof_cpu_regs_frame_map = RegisterImpl::number_of_registers,       // number of registers used during code emission
   pd_nof_fpu_regs_frame_map = FloatRegisterImpl::number_of_registers,  // number of registers used during code emission
 
-  pd_nof_caller_save_cpu_regs_frame_map = 19 - 2,  // number of registers killed by calls
+  pd_nof_caller_save_cpu_regs_frame_map = 19 - 2 BSD_ONLY(- 1 /* r18 */),  // number of registers killed by calls
   pd_nof_caller_save_fpu_regs_frame_map = 32,  // number of registers killed by calls
 
-  pd_first_callee_saved_reg = 19 - 2,
-  pd_last_callee_saved_reg = 26 - 2,
+  pd_first_callee_saved_reg = 19 - 2 BSD_ONLY(- 1 /* r18 */),
+  pd_last_callee_saved_reg = 26 - 2 BSD_ONLY(- 1 /* r18 */),
 
-  pd_last_allocatable_cpu_reg = 16,
+  pd_last_allocatable_cpu_reg = 16 BSD_ONLY(- 1 /* r18 */),
 
   pd_nof_cpu_regs_reg_alloc
     = pd_last_allocatable_cpu_reg + 1,  // number of registers that are visible to register allocator
@@ -60,9 +60,9 @@ enum {
   pd_nof_fpu_regs_linearscan = pd_nof_fpu_regs_frame_map, // number of registers visible to linear scan
   pd_nof_xmm_regs_linearscan = 0, // like sparc we don't have any of these
   pd_first_cpu_reg = 0,
-  pd_last_cpu_reg = 16,
+  pd_last_cpu_reg = 16 BSD_ONLY(- 1 /* r18 */),
   pd_first_byte_reg = 0,
-  pd_last_byte_reg = 16,
+  pd_last_byte_reg = 16 BSD_ONLY(- 1 /* r18 */),
   pd_first_fpu_reg = pd_nof_cpu_regs_frame_map,
   pd_last_fpu_reg =  pd_first_fpu_reg + 31,
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/c1_FrameMap_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -181,7 +181,9 @@ void FrameMap::initialize() {
   map_register(i, r15); r15_opr = LIR_OprFact::single_cpu(i); i++;
   map_register(i, r16); r16_opr = LIR_OprFact::single_cpu(i); i++;
   map_register(i, r17); r17_opr = LIR_OprFact::single_cpu(i); i++;
+#ifndef __APPLE__
   map_register(i, r18); r18_opr = LIR_OprFact::single_cpu(i); i++;
+#endif
   map_register(i, r19); r19_opr = LIR_OprFact::single_cpu(i); i++;
   map_register(i, r20); r20_opr = LIR_OprFact::single_cpu(i); i++;
   map_register(i, r21); r21_opr = LIR_OprFact::single_cpu(i); i++;
@@ -199,6 +201,10 @@ void FrameMap::initialize() {
   map_register(i, r8); r8_opr = LIR_OprFact::single_cpu(i); i++;   // rscratch1
   map_register(i, r9); r9_opr = LIR_OprFact::single_cpu(i); i++;   // rscratch2
 
+#ifdef __APPLE__
+  map_register(i, r18); r18_opr = LIR_OprFact::single_cpu(i); i++;   // rscratch2
+#endif
+
   rscratch1_opr = r8_opr;
   rscratch2_opr = r9_opr;
   rscratch1_long_opr = LIR_OprFact::double_cpu(r8_opr->cpu_regnr(), r8_opr->cpu_regnr());
@@ -227,7 +233,9 @@ void FrameMap::initialize() {
   _caller_save_cpu_regs[13] = r15_opr;
   _caller_save_cpu_regs[14] = r16_opr;
   _caller_save_cpu_regs[15] = r17_opr;
+#ifndef __APPLE__
   _caller_save_cpu_regs[16] = r18_opr;
+#endif
 
   for (int i = 0; i < 8; i++) {
     _caller_save_fpu_regs[i] = LIR_OprFact::single_fpu(i);
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1378,7 +1378,7 @@ void LIR_Assembler::emit_typecheck_helpe
     __ load_klass(klass_RInfo, obj);
     if (k->is_loaded()) {
       // See if we get an immediate positive hit
-      __ ldr(rscratch1, Address(klass_RInfo, long(k->super_check_offset())));
+      __ ldr(rscratch1, Address(klass_RInfo, int64_t(k->super_check_offset())));
       __ cmp(k_RInfo, rscratch1);
       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k->super_check_offset()) {
         __ br(Assembler::NE, *failure_target);
@@ -2626,7 +2626,7 @@ void LIR_Assembler::emit_updatecrc32(LIR
   Register res = op->result_opr()->as_register();
 
   assert_different_registers(val, crc, res);
-  unsigned long offset;
+  uint64_t offset;
   __ adrp(res, ExternalAddress(StubRoutines::crc_table_addr()), offset);
   if (offset) __ add(res, res, offset);
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/frame_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/frame_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/frame_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/frame_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -672,14 +672,14 @@ intptr_t* frame::real_fp() const {
 
 #define DESCRIBE_FP_OFFSET(name)                                        \
   {                                                                     \
-    unsigned long *p = (unsigned long *)fp;                             \
-    printf("0x%016lx 0x%016lx %s\n", (unsigned long)(p + frame::name##_offset), \
+    uintptr_t *p = (uintptr_t *)fp;                                     \
+    printf("0x%016lx 0x%016lx %s\n", (uintptr_t)(p + frame::name##_offset), \
            p[frame::name##_offset], #name);                             \
   }
 
-static __thread unsigned long nextfp;
-static __thread unsigned long nextpc;
-static __thread unsigned long nextsp;
+static __thread uintptr_t nextfp;
+static __thread uintptr_t nextpc;
+static __thread uintptr_t nextsp;
 static __thread RegisterMap *reg_map;
 
 static void printbc(Method *m, intptr_t bcx) {
@@ -698,7 +698,7 @@ static void printbc(Method *m, intptr_t 
   printf("%s : %s ==> %s\n", m->name_and_sig_as_C_string(), buf, name);
 }
 
-void internal_pf(unsigned long sp, unsigned long fp, unsigned long pc, unsigned long bcx) {
+void internal_pf(uintptr_t sp, uintptr_t fp, uintptr_t pc, uintptr_t bcx) {
   if (! fp)
     return;
 
@@ -712,7 +712,7 @@ void internal_pf(unsigned long sp, unsig
   DESCRIBE_FP_OFFSET(interpreter_frame_locals);
   DESCRIBE_FP_OFFSET(interpreter_frame_bcp);
   DESCRIBE_FP_OFFSET(interpreter_frame_initial_sp);
-  unsigned long *p = (unsigned long *)fp;
+  uintptr_t *p = (uintptr_t *)fp;
 
   // We want to see all frames, native and Java.  For compiled and
   // interpreted frames we have special information that allows us to
@@ -722,16 +722,16 @@ void internal_pf(unsigned long sp, unsig
   if (this_frame.is_compiled_frame() ||
       this_frame.is_interpreted_frame()) {
     frame sender = this_frame.sender(reg_map);
-    nextfp = (unsigned long)sender.fp();
-    nextpc = (unsigned long)sender.pc();
-    nextsp = (unsigned long)sender.unextended_sp();
+    nextfp = (uintptr_t)sender.fp();
+    nextpc = (uintptr_t)sender.pc();
+    nextsp = (uintptr_t)sender.unextended_sp();
   } else {
     nextfp = p[frame::link_offset];
     nextpc = p[frame::return_addr_offset];
-    nextsp = (unsigned long)&p[frame::sender_sp_offset];
+    nextsp = (uintptr_t)&p[frame::sender_sp_offset];
   }
 
-  if (bcx == -1ul)
+  if (bcx == -1ULL)
     bcx = p[frame::interpreter_frame_bcp_offset];
 
   if (Interpreter::contains((address)pc)) {
@@ -765,8 +765,8 @@ extern "C" void npf() {
   internal_pf (nextsp, nextfp, nextpc, -1);
 }
 
-extern "C" void pf(unsigned long sp, unsigned long fp, unsigned long pc,
-                   unsigned long bcx, unsigned long thread) {
+extern "C" void pf(uintptr_t sp, uintptr_t fp, uintptr_t pc,
+                   uintptr_t bcx, uintptr_t thread) {
   if (!reg_map) {
     reg_map = NEW_C_HEAP_OBJ(RegisterMap, mtNone);
     ::new (reg_map) RegisterMap((JavaThread*)thread, false);
@@ -785,9 +785,9 @@ extern "C" void pf(unsigned long sp, uns
 // support for printing out where we are in a Java method
 // needs to be passed current fp and bcp register values
 // prints method name, bc index and bytecode name
-extern "C" void pm(unsigned long fp, unsigned long bcx) {
+extern "C" void pm(uintptr_t fp, uintptr_t bcx) {
   DESCRIBE_FP_OFFSET(interpreter_frame_method);
-  unsigned long *p = (unsigned long *)fp;
+  uintptr_t *p = (uintptr_t *)fp;
   Method* m = (Method*)p[frame::interpreter_frame_method_offset];
   printbc(m, bcx);
 }
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/gc/shared/barrierSetAssembler_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/gc/shared/barrierSetAssembler_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/gc/shared/barrierSetAssembler_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/gc/shared/barrierSetAssembler_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -172,7 +172,7 @@ void BarrierSetAssembler::eden_allocate(
     Label retry;
     __ bind(retry);
     {
-      unsigned long offset;
+      uint64_t offset;
       __ adrp(rscratch1, ExternalAddress((address) Universe::heap()->end_addr()), offset);
       __ ldr(heap_end, Address(rscratch1, offset));
     }
@@ -181,7 +181,7 @@ void BarrierSetAssembler::eden_allocate(
 
     // Get the current top of the heap
     {
-      unsigned long offset;
+      uint64_t offset;
       __ adrp(rscratch1, heap_top, offset);
       // Use add() here after ARDP, rather than lea().
       // lea() does not generate anything if its offset is zero.
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/immediate_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/immediate_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/immediate_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/immediate_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -63,9 +63,9 @@ int compare_immediate_pair(const void *i
 // helper functions used by expandLogicalImmediate
 
 // for i = 1, ... N result<i-1> = 1 other bits are zero
-static inline u_int64_t ones(int N)
+static inline uint64_t ones(int N)
 {
-  return (N == 64 ? (u_int64_t)-1UL : ((1UL << N) - 1));
+  return (N == 64 ? -1ULL : (1ULL << N) - 1);
 }
 
 /*
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/interp_masm_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/interp_masm_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/interp_masm_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/interp_masm_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -168,7 +168,7 @@ void InterpreterMacroAssembler::get_unsi
 }
 
 void InterpreterMacroAssembler::get_dispatch() {
-  unsigned long offset;
+  uint64_t offset;
   adrp(rdispatch, ExternalAddress((address)Interpreter::dispatch_table()), offset);
   lea(rdispatch, Address(rdispatch, offset));
 }
@@ -754,7 +754,7 @@ void InterpreterMacroAssembler::lock_obj
     // copy
     mov(rscratch1, sp);
     sub(swap_reg, swap_reg, rscratch1);
-    ands(swap_reg, swap_reg, (unsigned long)(7 - os::vm_page_size()));
+    ands(swap_reg, swap_reg, (uint64_t)(7 - os::vm_page_size()));
 
     // Save the test result, for recursive case, the result is zero
     str(swap_reg, Address(lock_reg, mark_offset));
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/interpreterRT_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,6 +39,29 @@
 
 #define __ _masm->
 
+//describe amount of space in bytes occupied by type on native stack
+#ifdef __APPLE__
+    const int nativeByteSpace        = sizeof(jbyte);
+    const int nativeShortSpace       = sizeof(jshort);
+    const int nativeIntSpace         = sizeof(jint);
+    const int nativeLongSpace        = wordSize;
+    const int nativeFloatSpace       = nativeIntSpace;
+    const int nativeDoubleSpace      = nativeLongSpace;
+#else
+    const int nativeByteSpace        = wordSize;
+    const int nativeShortSpace       = wordSize;
+    const int nativeIntSpace         = wordSize;
+    const int nativeLongSpace        = wordSize;
+    const int nativeFloatSpace       = nativeIntSpace;
+    const int nativeDoubleSpace      = nativeLongSpace;
+#endif
+
+template <typename T>
+static inline void store_and_inc(char* &to, T value, int inc_size) {
+  *(T *)to = value;
+  to = to + inc_size;
+}
+
 // Implementation of SignatureHandlerGenerator
 Register InterpreterRuntime::SignatureHandlerGenerator::from() { return rlocals; }
 Register InterpreterRuntime::SignatureHandlerGenerator::to()   { return sp; }
@@ -52,6 +75,95 @@ InterpreterRuntime::SignatureHandlerGene
   _stack_offset = 0;
 }
 
+// On macos/aarch64 native stack is packed, int/float are using only 4 bytes
+// on stack. Natural alignment for types are still in place,
+// for example double/long should be 8 bytes alligned
+
+void InterpreterRuntime::SignatureHandlerGenerator::pass_byte() {
+  const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
+
+  switch (_num_int_args) {
+  case 0:
+    __ ldr(c_rarg1, src);
+    _num_int_args++;
+    break;
+  case 1:
+    __ ldr(c_rarg2, src);
+    _num_int_args++;
+    break;
+  case 2:
+    __ ldr(c_rarg3, src);
+    _num_int_args++;
+    break;
+  case 3:
+    __ ldr(c_rarg4, src);
+    _num_int_args++;
+    break;
+  case 4:
+    __ ldr(c_rarg5, src);
+    _num_int_args++;
+    break;
+  case 5:
+    __ ldr(c_rarg6, src);
+    _num_int_args++;
+    break;
+  case 6:
+    __ ldr(c_rarg7, src);
+    _num_int_args++;
+    break;
+  default:
+    __ ldrb(r0, src);
+    __ strb(r0, Address(to(), _stack_offset));
+    _stack_offset += nativeByteSpace;
+
+    _num_int_args++;
+    break;
+  }
+}
+
+void InterpreterRuntime::SignatureHandlerGenerator::pass_short() {
+  const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
+
+  switch (_num_int_args) {
+  case 0:
+    __ ldr(c_rarg1, src);
+    _num_int_args++;
+    break;
+  case 1:
+    __ ldr(c_rarg2, src);
+    _num_int_args++;
+    break;
+  case 2:
+    __ ldr(c_rarg3, src);
+    _num_int_args++;
+    break;
+  case 3:
+    __ ldr(c_rarg4, src);
+    _num_int_args++;
+    break;
+  case 4:
+    __ ldr(c_rarg5, src);
+    _num_int_args++;
+    break;
+  case 5:
+    __ ldr(c_rarg6, src);
+    _num_int_args++;
+    break;
+  case 6:
+    __ ldr(c_rarg7, src);
+    _num_int_args++;
+    break;
+  default:
+    _stack_offset = align_up(_stack_offset, nativeShortSpace);
+    __ ldrh(r0, src);
+    __ strh(r0, Address(to(), _stack_offset));
+    _stack_offset += nativeShortSpace;
+
+    _num_int_args++;
+    break;
+  }
+}
+
 void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 
@@ -85,9 +197,10 @@ void InterpreterRuntime::SignatureHandle
     _num_int_args++;
     break;
   default:
+    _stack_offset = align_up(_stack_offset, nativeIntSpace);
     __ ldr(r0, src);
     __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += wordSize;
+    _stack_offset += nativeIntSpace;
     _num_int_args++;
     break;
   }
@@ -126,9 +239,10 @@ void InterpreterRuntime::SignatureHandle
     _num_int_args++;
     break;
   default:
+    _stack_offset = align_up(_stack_offset, nativeLongSpace);
     __ ldr(r0, src);
     __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += wordSize;
+    _stack_offset += nativeLongSpace;
     _num_int_args++;
     break;
   }
@@ -140,9 +254,10 @@ void InterpreterRuntime::SignatureHandle
   if (_num_fp_args < Argument::n_float_register_parameters_c) {
     __ ldrs(as_FloatRegister(_num_fp_args++), src);
   } else {
+      _stack_offset = align_up(_stack_offset, nativeFloatSpace);
     __ ldrw(r0, src);
     __ strw(r0, Address(to(), _stack_offset));
-    _stack_offset += wordSize;
+    _stack_offset += nativeFloatSpace;
     _num_fp_args++;
   }
 }
@@ -153,9 +268,10 @@ void InterpreterRuntime::SignatureHandle
   if (_num_fp_args < Argument::n_float_register_parameters_c) {
     __ ldrd(as_FloatRegister(_num_fp_args++), src);
   } else {
+    _stack_offset = align_up(_stack_offset, nativeDoubleSpace);
     __ ldr(r0, src);
     __ str(r0, Address(to(), _stack_offset));
-    _stack_offset += wordSize;
+    _stack_offset += nativeDoubleSpace;
     _num_fp_args++;
   }
 }
@@ -248,6 +364,7 @@ void InterpreterRuntime::SignatureHandle
       __ cbnz(temp(), L);
       __ mov(r0, zr);
       __ bind(L);
+      _stack_offset = align_up(_stack_offset, wordSize);
       __ str(r0, Address(to(), _stack_offset));
       _stack_offset += wordSize;
       _num_int_args++;
@@ -277,13 +394,46 @@ class SlowSignatureHandler
   : public NativeSignatureIterator {
  private:
   address   _from;
-  intptr_t* _to;
+  char*     _to;
   intptr_t* _int_args;
   intptr_t* _fp_args;
   intptr_t* _fp_identifiers;
   unsigned int _num_int_args;
   unsigned int _num_fp_args;
 
+
+  virtual void pass_byte()
+  {
+    NOT_BSD(return pass_int();)
+    jbyte from_obj = *(jbyte *)(_from+Interpreter::local_offset_in_bytes(0));
+    _from -= Interpreter::stackElementSize;
+
+    if (_num_int_args < Argument::n_int_register_parameters_c-1) {
+      *_int_args++ = from_obj;
+      _num_int_args++;
+    } else {
+      store_and_inc(_to, from_obj, nativeByteSpace);
+
+      _num_int_args++;
+    }
+  }
+
+  virtual void pass_short()
+  {
+    NOT_BSD(return pass_int();)
+    jshort from_obj = *(jshort *)(_from+Interpreter::local_offset_in_bytes(0));
+    _from -= Interpreter::stackElementSize;
+
+    if (_num_int_args < Argument::n_int_register_parameters_c-1) {
+      *_int_args++ = from_obj;
+      _num_int_args++;
+    } else {
+      _to = align_up(_to, nativeShortSpace);
+      store_and_inc(_to, from_obj, nativeShortSpace);
+
+      _num_int_args++;
+    }
+  }
   virtual void pass_int()
   {
     jint from_obj = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));
@@ -293,7 +443,9 @@ class SlowSignatureHandler
       *_int_args++ = from_obj;
       _num_int_args++;
     } else {
-      *_to++ = from_obj;
+      _to = align_up(_to, nativeIntSpace);
+      store_and_inc(_to, from_obj, nativeIntSpace);
+
       _num_int_args++;
     }
   }
@@ -307,7 +459,8 @@ class SlowSignatureHandler
       *_int_args++ = from_obj;
       _num_int_args++;
     } else {
-      *_to++ = from_obj;
+      _to = align_up(_to, nativeLongSpace);
+      store_and_inc(_to, from_obj, nativeLongSpace);
       _num_int_args++;
     }
   }
@@ -321,7 +474,8 @@ class SlowSignatureHandler
       *_int_args++ = (*from_addr == 0) ? NULL : (intptr_t)from_addr;
       _num_int_args++;
     } else {
-      *_to++ = (*from_addr == 0) ? NULL : (intptr_t) from_addr;
+      _to = align_up(_to, wordSize);
+      store_and_inc(_to, (*from_addr == 0) ? (intptr_t)NULL : (intptr_t) from_addr, wordSize);
       _num_int_args++;
     }
   }
@@ -335,7 +489,9 @@ class SlowSignatureHandler
       *_fp_args++ = from_obj;
       _num_fp_args++;
     } else {
-      *_to++ = from_obj;
+      _to = align_up(_to, nativeFloatSpace);
+      store_and_inc(_to, from_obj, nativeFloatSpace);
+
       _num_fp_args++;
     }
   }
@@ -347,10 +503,11 @@ class SlowSignatureHandler
 
     if (_num_fp_args < Argument::n_float_register_parameters_c) {
       *_fp_args++ = from_obj;
-      *_fp_identifiers |= (1 << _num_fp_args); // mark as double
+      *_fp_identifiers |= (1ull << _num_fp_args); // mark as double
       _num_fp_args++;
     } else {
-      *_to++ = from_obj;
+      _to = align_up(_to, nativeDoubleSpace);
+      store_and_inc(_to, from_obj, nativeDoubleSpace);
       _num_fp_args++;
     }
   }
@@ -360,7 +517,7 @@ class SlowSignatureHandler
     : NativeSignatureIterator(method)
   {
     _from = from;
-    _to   = to;
+    _to   = (char *)to;
 
     _int_args = to - (method->is_static() ? 16 : 17);
     _fp_args =  to - 8;
@@ -383,7 +540,7 @@ IRT_ENTRY(address,
 
   // handle arguments
   SlowSignatureHandler ssh(m, (address)from, to);
-  ssh.iterate(UCONST64(-1));
+  ssh.iterate((uint64_t)CONST64(-1));
 
   // return result handler
   return Interpreter::result_handler(m->result_type());
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/interpreterRT_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -38,6 +38,8 @@ class SignatureHandlerGenerator: public 
   unsigned int _num_int_args;
   int _stack_offset;
 
+  void pass_byte();
+  void pass_short();
   void pass_int();
   void pass_long();
   void pass_float();
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/jniFastGetField_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/jniFastGetField_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/jniFastGetField_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/jniFastGetField_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 2004, 2017, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -73,7 +73,7 @@ address JNI_FastGetField::generate_fast_
 
   Label slow;
 
-  unsigned long offset;
+  uint64_t offset;
   __ adrp(rcounter_addr,
           SafepointSynchronize::safepoint_counter_addr(), offset);
   Address safepoint_counter_addr(rcounter_addr, offset);
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -65,8 +65,8 @@
 // Return the total length (in bytes) of the instructions.
 int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
   int instructions = 1;
-  assert((uint64_t)target < (1ul << 48), "48-bit overflow in address constant");
-  long offset = (target - branch) >> 2;
+  assert((uint64_t)target < (1ull << 48), "48-bit overflow in address constant");
+  intptr_t offset = (target - branch) >> 2;
   unsigned insn = *(unsigned*)branch;
   if ((Instruction_aarch64::extract(insn, 29, 24) & 0b111011) == 0b011000) {
     // Load register (literal)
@@ -129,9 +129,9 @@ int MacroAssembler::pd_patch_instruction
                      Instruction_aarch64::extract(insn2, 4, 0)) {
         // movk #imm16<<32
         Instruction_aarch64::patch(branch + 4, 20, 5, (uint64_t)target >> 32);
-        long dest = ((long)target & 0xffffffffL) | ((long)branch & 0xffff00000000L);
-        long pc_page = (long)branch >> 12;
-        long adr_page = (long)dest >> 12;
+        uintptr_t dest = ((uintptr_t)target & 0xffffffffULL) | ((uintptr_t)branch & 0xffff00000000ULL);
+        uintptr_t pc_page = (uintptr_t)branch >> 12;
+        uintptr_t adr_page = (uintptr_t)dest >> 12;
         offset = adr_page - pc_page;
         instructions = 2;
       }
@@ -200,7 +200,7 @@ int MacroAssembler::patch_narrow_klass(a
 }
 
 address MacroAssembler::target_addr_for_insn(address insn_addr, unsigned insn) {
-  long offset = 0;
+  intptr_t offset = 0;
   if ((Instruction_aarch64::extract(insn, 29, 24) & 0b011011) == 0b00011000) {
     // Load register (literal)
     offset = Instruction_aarch64::sextract(insn, 23, 5);
@@ -292,7 +292,7 @@ void MacroAssembler::safepoint_poll(Labe
     ldr(rscratch1, Address(rthread, Thread::polling_page_offset()));
     tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);
   } else {
-    unsigned long offset;
+    uint64_t offset;
     adrp(rscratch1, ExternalAddress(SafepointSynchronize::address_of_state()), offset);
     ldrw(rscratch1, Address(rscratch1, offset));
     assert(SafepointSynchronize::_not_synchronized == 0, "rewrite this code");
@@ -400,7 +400,7 @@ void MacroAssembler::far_call(Address en
   assert(CodeCache::find_blob(entry.target()) != NULL,
          "destination of far call not found in code cache");
   if (far_branches()) {
-    unsigned long offset;
+    uint64_t offset;
     // We can use ADRP here because we know that the total size of
     // the code cache cannot exceed 2Gb.
     adrp(tmp, entry, offset);
@@ -418,7 +418,7 @@ void MacroAssembler::far_jump(Address en
   assert(CodeCache::find_blob(entry.target()) != NULL,
          "destination of far call not found in code cache");
   if (far_branches()) {
-    unsigned long offset;
+    uint64_t offset;
     // We can use ADRP here because we know that the total size of
     // the code cache cannot exceed 2Gb.
     adrp(tmp, entry, offset);
@@ -830,7 +830,7 @@ void MacroAssembler::c2bool(Register x) 
 address MacroAssembler::ic_call(address entry, jint method_index) {
   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
   // address const_ptr = long_constant((jlong)Universe::non_oop_word());
-  // unsigned long offset;
+  // uintptr_t offset;
   // ldr_constant(rscratch2, const_ptr);
   movptr(rscratch2, (uintptr_t)Universe::non_oop_word());
   return trampoline_call(Address(entry, rh));
@@ -1480,11 +1480,11 @@ void MacroAssembler::movptr(Register r, 
 #ifndef PRODUCT
   {
     char buffer[64];
-    snprintf(buffer, sizeof(buffer), "0x%"PRIX64, imm64);
+    snprintf(buffer, sizeof(buffer), "0x%"PRIX64, (uint64_t)imm64);
     block_comment(buffer);
   }
 #endif
-  assert(imm64 < (1ul << 48), "48-bit overflow in address constant");
+  assert(imm64 < (1ull << 48), "48-bit overflow in address constant");
   movz(r, imm64 & 0xffff);
   imm64 >>= 16;
   movk(r, imm64 & 0xffff, 16);
@@ -1543,7 +1543,7 @@ void MacroAssembler::mov_immediate64(Reg
 #ifndef PRODUCT
   {
     char buffer[64];
-    snprintf(buffer, sizeof(buffer), "0x%"PRIX64, imm64);
+    snprintf(buffer, sizeof(buffer), "0x%"PRIX64, (uint64_t)imm64);
     block_comment(buffer);
   }
 #endif
@@ -1688,7 +1688,7 @@ void MacroAssembler::mov_immediate32(Reg
 // not actually be used: you must use the Address that is returned.
 // It is up to you to ensure that the shift provided matches the size
 // of your data.
-Address MacroAssembler::form_address(Register Rd, Register base, long byte_offset, int shift) {
+Address MacroAssembler::form_address(Register Rd, Register base, int64_t byte_offset, int shift) {
   if (Address::offset_ok_for_immed(byte_offset, shift))
     // It fits; no need for any heroics
     return Address(base, byte_offset);
@@ -1703,9 +1703,9 @@ Address MacroAssembler::form_address(Reg
 
   // See if we can do this with two 12-bit offsets
   {
-    unsigned long word_offset = byte_offset >> shift;
-    unsigned long masked_offset = word_offset & 0xfff000;
-    if (Address::offset_ok_for_immed(word_offset - masked_offset)
+    uint64_t word_offset = byte_offset >> shift;
+    uint64_t masked_offset = word_offset & 0xfff000;
+    if (Address::offset_ok_for_immed(word_offset - masked_offset, 0)
         && Assembler::operand_valid_for_add_sub_immediate(masked_offset << shift)) {
       add(Rd, base, masked_offset << shift);
       word_offset -= masked_offset;
@@ -1945,7 +1945,7 @@ void MacroAssembler::decrement(Register 
   if (value < (1 << 12)) { sub(reg, reg, value); return; }
   /* else */ {
     assert(reg != rscratch2, "invalid dst for register decrement");
-    mov(rscratch2, (unsigned long)value);
+    mov(rscratch2, (uint64_t)value);
     sub(reg, reg, rscratch2);
   }
 }
@@ -2482,43 +2482,43 @@ void MacroAssembler::debug64(char* msg, 
 #endif
     if (os::message_box(msg, "Execution stopped, print registers?")) {
       ttyLocker ttyl;
-      tty->print_cr(" pc = 0x%016lx", pc);
+      tty->print_cr(" pc = 0x%016" PRIx64, pc);
 #ifndef PRODUCT
       tty->cr();
       findpc(pc);
       tty->cr();
 #endif
-      tty->print_cr(" r0 = 0x%016lx", regs[0]);
-      tty->print_cr(" r1 = 0x%016lx", regs[1]);
-      tty->print_cr(" r2 = 0x%016lx", regs[2]);
-      tty->print_cr(" r3 = 0x%016lx", regs[3]);
-      tty->print_cr(" r4 = 0x%016lx", regs[4]);
-      tty->print_cr(" r5 = 0x%016lx", regs[5]);
-      tty->print_cr(" r6 = 0x%016lx", regs[6]);
-      tty->print_cr(" r7 = 0x%016lx", regs[7]);
-      tty->print_cr(" r8 = 0x%016lx", regs[8]);
-      tty->print_cr(" r9 = 0x%016lx", regs[9]);
-      tty->print_cr("r10 = 0x%016lx", regs[10]);
-      tty->print_cr("r11 = 0x%016lx", regs[11]);
-      tty->print_cr("r12 = 0x%016lx", regs[12]);
-      tty->print_cr("r13 = 0x%016lx", regs[13]);
-      tty->print_cr("r14 = 0x%016lx", regs[14]);
-      tty->print_cr("r15 = 0x%016lx", regs[15]);
-      tty->print_cr("r16 = 0x%016lx", regs[16]);
-      tty->print_cr("r17 = 0x%016lx", regs[17]);
-      tty->print_cr("r18 = 0x%016lx", regs[18]);
-      tty->print_cr("r19 = 0x%016lx", regs[19]);
-      tty->print_cr("r20 = 0x%016lx", regs[20]);
-      tty->print_cr("r21 = 0x%016lx", regs[21]);
-      tty->print_cr("r22 = 0x%016lx", regs[22]);
-      tty->print_cr("r23 = 0x%016lx", regs[23]);
-      tty->print_cr("r24 = 0x%016lx", regs[24]);
-      tty->print_cr("r25 = 0x%016lx", regs[25]);
-      tty->print_cr("r26 = 0x%016lx", regs[26]);
-      tty->print_cr("r27 = 0x%016lx", regs[27]);
-      tty->print_cr("r28 = 0x%016lx", regs[28]);
-      tty->print_cr("r30 = 0x%016lx", regs[30]);
-      tty->print_cr("r31 = 0x%016lx", regs[31]);
+      tty->print_cr(" r0 = 0x%016" PRIx64, regs[0]);
+      tty->print_cr(" r1 = 0x%016" PRIx64, regs[1]);
+      tty->print_cr(" r2 = 0x%016" PRIx64, regs[2]);
+      tty->print_cr(" r3 = 0x%016" PRIx64, regs[3]);
+      tty->print_cr(" r4 = 0x%016" PRIx64, regs[4]);
+      tty->print_cr(" r5 = 0x%016" PRIx64, regs[5]);
+      tty->print_cr(" r6 = 0x%016" PRIx64, regs[6]);
+      tty->print_cr(" r7 = 0x%016" PRIx64, regs[7]);
+      tty->print_cr(" r8 = 0x%016" PRIx64, regs[8]);
+      tty->print_cr(" r9 = 0x%016" PRIx64, regs[9]);
+      tty->print_cr("r10 = 0x%016" PRIx64, regs[10]);
+      tty->print_cr("r11 = 0x%016" PRIx64, regs[11]);
+      tty->print_cr("r12 = 0x%016" PRIx64, regs[12]);
+      tty->print_cr("r13 = 0x%016" PRIx64, regs[13]);
+      tty->print_cr("r14 = 0x%016" PRIx64, regs[14]);
+      tty->print_cr("r15 = 0x%016" PRIx64, regs[15]);
+      tty->print_cr("r16 = 0x%016" PRIx64, regs[16]);
+      tty->print_cr("r17 = 0x%016" PRIx64, regs[17]);
+      tty->print_cr("r18 = 0x%016" PRIx64, regs[18]);
+      tty->print_cr("r19 = 0x%016" PRIx64, regs[19]);
+      tty->print_cr("r20 = 0x%016" PRIx64, regs[20]);
+      tty->print_cr("r21 = 0x%016" PRIx64, regs[21]);
+      tty->print_cr("r22 = 0x%016" PRIx64, regs[22]);
+      tty->print_cr("r23 = 0x%016" PRIx64, regs[23]);
+      tty->print_cr("r24 = 0x%016" PRIx64, regs[24]);
+      tty->print_cr("r25 = 0x%016" PRIx64, regs[25]);
+      tty->print_cr("r26 = 0x%016" PRIx64, regs[26]);
+      tty->print_cr("r27 = 0x%016" PRIx64, regs[27]);
+      tty->print_cr("r28 = 0x%016" PRIx64, regs[28]);
+      tty->print_cr("r30 = 0x%016" PRIx64, regs[30]);
+      tty->print_cr("r31 = 0x%016" PRIx64, regs[31]);
       BREAKPOINT;
     }
     ThreadStateTransition::transition(thread, _thread_in_vm, saved_state);
@@ -2532,7 +2532,7 @@ void MacroAssembler::debug64(char* msg, 
 
 void MacroAssembler::push_call_clobbered_registers() {
   int step = 4 * wordSize;
-  push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);
+  push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2) BSD_ONLY(- r18), sp);
   sub(sp, sp, step);
   mov(rscratch1, -step);
   // Push v0-v7, v16-v31.
@@ -2552,7 +2552,7 @@ void MacroAssembler::pop_call_clobbered_
           as_FloatRegister(i+3), T1D, Address(post(sp, 4 * wordSize)));
   }
 
-  pop(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);
+  pop(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2) BSD_ONLY(- r18), sp);
 }
 
 void MacroAssembler::push_CPU_state(bool save_vectors) {
@@ -2624,19 +2624,19 @@ Address MacroAssembler::spill_address(in
 // Returns true if it is, else false.
 bool MacroAssembler::merge_alignment_check(Register base,
                                            size_t size,
-                                           long cur_offset,
-                                           long prev_offset) const {
+                                           int64_t cur_offset,
+                                           int64_t prev_offset) const {
   if (AvoidUnalignedAccesses) {
     if (base == sp) {
       // Checks whether low offset if aligned to pair of registers.
-      long pair_mask = size * 2 - 1;
-      long offset = prev_offset > cur_offset ? cur_offset : prev_offset;
+      int64_t pair_mask = size * 2 - 1;
+      int64_t offset = prev_offset > cur_offset ? cur_offset : prev_offset;
       return (offset & pair_mask) == 0;
     } else { // If base is not sp, we can't guarantee the access is aligned.
       return false;
     }
   } else {
-    long mask = size - 1;
+    int64_t mask = size - 1;
     // Load/store pair instruction only supports element size aligned offset.
     return (cur_offset & mask) == 0 && (prev_offset & mask) == 0;
   }
@@ -2669,8 +2669,8 @@ bool MacroAssembler::ldst_can_merge(Regi
     return false;
   }
 
-  long max_offset = 63 * prev_size_in_bytes;
-  long min_offset = -64 * prev_size_in_bytes;
+  int64_t max_offset = 63 * prev_size_in_bytes;
+  int64_t min_offset = -64 * prev_size_in_bytes;
 
   assert(prev_ldst->is_not_pre_post_index(), "pre-index or post-index is not supported to be merged.");
 
@@ -2679,8 +2679,8 @@ bool MacroAssembler::ldst_can_merge(Regi
     return false;
   }
 
-  long cur_offset = adr.offset();
-  long prev_offset = prev_ldst->offset();
+  int64_t cur_offset = adr.offset();
+  int64_t prev_offset = prev_ldst->offset();
   size_t diff = abs(cur_offset - prev_offset);
   if (diff != prev_size_in_bytes) {
     return false;
@@ -2697,7 +2697,7 @@ bool MacroAssembler::ldst_can_merge(Regi
     return false;
   }
 
-  long low_offset = prev_offset > cur_offset ? cur_offset : prev_offset;
+  int64_t low_offset = prev_offset > cur_offset ? cur_offset : prev_offset;
   // Offset range must be in ldp/stp instruction's range.
   if (low_offset > max_offset || low_offset < min_offset) {
     return false;
@@ -2722,7 +2722,7 @@ void MacroAssembler::merge_ldst(Register
   address prev = pc() - NativeInstruction::instruction_size;
   NativeLdSt* prev_ldst = NativeLdSt_at(prev);
 
-  long offset;
+  int64_t offset;
 
   if (adr.offset() < prev_ldst->offset()) {
     offset = adr.offset();
@@ -3268,7 +3268,7 @@ void MacroAssembler::kernel_crc32(Regist
         Register table0, Register table1, Register table2, Register table3,
         Register tmp, Register tmp2, Register tmp3) {
   Label L_by16, L_by16_loop, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;
-  unsigned long offset;
+  uint64_t offset;
 
   if (UseCRC32) {
       kernel_crc32_using_crc32(crc, buf, len, table0, table1, table2, table3);
@@ -3570,7 +3570,7 @@ void MacroAssembler::kernel_crc32c(Regis
 SkipIfEqual::SkipIfEqual(
     MacroAssembler* masm, const bool* flag_addr, bool value) {
   _masm = masm;
-  unsigned long offset;
+  uint64_t offset;
   _masm->adrp(rscratch1, ExternalAddress((address)flag_addr), offset);
   _masm->ldrb(rscratch1, Address(rscratch1, offset));
   _masm->cbzw(rscratch1, _label);
@@ -3599,7 +3599,7 @@ void MacroAssembler::addptr(const Addres
 }
 
 void MacroAssembler::cmpptr(Register src1, Address src2) {
-  unsigned long offset;
+  uint64_t offset;
   adrp(rscratch1, src2, offset);
   ldr(rscratch1, Address(rscratch1, offset));
   cmp(src1, rscratch1);
@@ -4185,7 +4185,7 @@ void MacroAssembler::get_polling_page(Re
   if (SafepointMechanism::uses_thread_local_poll()) {
     ldr(dest, Address(rthread, Thread::polling_page_offset()));
   } else {
-    unsigned long off;
+    uint64_t off;
     adrp(dest, Address(page, rtype), off);
     assert(off == 0, "polling page must be page aligned");
   }
@@ -4207,13 +4207,12 @@ address MacroAssembler::read_polling_pag
   return inst_mark();
 }
 
-void MacroAssembler::adrp(Register reg1, const Address &dest, unsigned long &byte_offset) {
-  relocInfo::relocType rtype = dest.rspec().reloc()->type();
-  unsigned long low_page = (unsigned long)CodeCache::low_bound() >> 12;
-  unsigned long high_page = (unsigned long)(CodeCache::high_bound()-1) >> 12;
-  unsigned long dest_page = (unsigned long)dest.target() >> 12;
-  long offset_low = dest_page - low_page;
-  long offset_high = dest_page - high_page;
+void MacroAssembler::adrp(Register reg1, const Address &dest, uint64_t &byte_offset) {
+  uint64_t low_page = (uint64_t)CodeCache::low_bound() >> 12;
+  uint64_t high_page = (uint64_t)(CodeCache::high_bound()-1) >> 12;
+  uint64_t dest_page = (uint64_t)dest.target() >> 12;
+  int64_t offset_low = dest_page - low_page;
+  int64_t offset_high = dest_page - high_page;
 
   assert(is_valid_AArch64_address(dest.target()), "bad address");
   assert(dest.getMode() == Address::literal, "ADRP must be applied to a literal address");
@@ -4225,14 +4224,14 @@ void MacroAssembler::adrp(Register reg1,
   if (offset_high >= -(1<<20) && offset_low < (1<<20)) {
     _adrp(reg1, dest.target());
   } else {
-    unsigned long target = (unsigned long)dest.target();
-    unsigned long adrp_target
-      = (target & 0xffffffffUL) | ((unsigned long)pc() & 0xffff00000000UL);
+    uint64_t target = (uint64_t)dest.target();
+    uint64_t adrp_target
+      = (target & 0xffffffffULL) | ((uint64_t)pc() & 0xffff00000000ULL);
 
     _adrp(reg1, (address)adrp_target);
     movk(reg1, target >> 32, 32);
   }
-  byte_offset = (unsigned long)dest.target() & 0xfff;
+  byte_offset = (uint64_t)dest.target() & 0xfff;
 }
 
 void MacroAssembler::load_byte_map_base(Register reg) {
@@ -4242,7 +4241,7 @@ void MacroAssembler::load_byte_map_base(
   if (is_valid_AArch64_address((address)byte_map_base)) {
     // Strictly speaking the byte_map_base isn't an address at all,
     // and it might even be negative.
-    unsigned long offset;
+    uint64_t offset;
     adrp(reg, ExternalAddress((address)byte_map_base), offset);
     // We expect offset to be zero with most collectors.
     if (offset != 0) {
@@ -5771,7 +5770,7 @@ void MacroAssembler::char_array_compress
 // aarch64_get_thread_helper() clobbers only r0, r1, and flags.
 //
 void MacroAssembler::get_thread(Register dst) {
-  RegSet saved_regs = RegSet::range(r0, r1) + lr - dst;
+  RegSet saved_regs = RegSet::range(r0, r1) + BSD_ONLY(RegSet::range(r2, r17)) + lr - dst;
   push(saved_regs, sp);
 
   mov(lr, CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper));
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/macroAssembler_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -88,7 +88,7 @@ class MacroAssembler: public Assembler {
       = (operand_valid_for_logical_immediate(false /*is32*/,
                                              (uint64_t)Universe::narrow_klass_base())
          && ((uint64_t)Universe::narrow_klass_base()
-             > (1UL << log2_intptr(Universe::narrow_klass_range()))));
+             > (1UL << log2_intptr((uintptr_t)Universe::narrow_klass_range()))));
   }
 
  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
@@ -456,31 +456,20 @@ public:
   // now mov instructions for loading absolute addresses and 32 or
   // 64 bit integers
 
-  inline void mov(Register dst, address addr)
-  {
-    mov_immediate64(dst, (u_int64_t)addr);
-  }
+  inline void mov(Register dst, address addr)             { mov_immediate64(dst, (uint64_t)addr); }
 
-  inline void mov(Register dst, u_int64_t imm64)
-  {
-    mov_immediate64(dst, imm64);
-  }
+  inline void mov(Register dst, int imm64)                { mov_immediate64(dst, (uint64_t)imm64); }
+  inline void mov(Register dst, long imm64)               { mov_immediate64(dst, (uint64_t)imm64); }
+  inline void mov(Register dst, long long imm64)          { mov_immediate64(dst, (uint64_t)imm64); }
+  inline void mov(Register dst, unsigned int imm64)       { mov_immediate64(dst, (uint64_t)imm64); }
+  inline void mov(Register dst, unsigned long imm64)      { mov_immediate64(dst, (uint64_t)imm64); }
+  inline void mov(Register dst, unsigned long long imm64) { mov_immediate64(dst, (uint64_t)imm64); }
 
   inline void movw(Register dst, u_int32_t imm32)
   {
     mov_immediate32(dst, imm32);
   }
 
-  inline void mov(Register dst, long l)
-  {
-    mov(dst, (u_int64_t)l);
-  }
-
-  inline void mov(Register dst, int i)
-  {
-    mov(dst, (long)i);
-  }
-
   void mov(Register dst, RegisterOrConstant src) {
     if (src.is_register())
       mov(dst, src.as_register());
@@ -1134,7 +1123,7 @@ public:
   void sub(Register Rd, Register Rn, RegisterOrConstant decrement);
   void subw(Register Rd, Register Rn, RegisterOrConstant decrement);
 
-  void adrp(Register reg1, const Address &dest, unsigned long &byte_offset);
+  void adrp(Register reg1, const Address &dest, uint64_t &byte_offset);
 
   void tableswitch(Register index, jint lowbound, jint highbound,
                    Label &jumptable, Label &jumptable_end, int stride = 1) {
@@ -1151,7 +1140,7 @@ public:
   // actually be used: you must use the Address that is returned.  It
   // is up to you to ensure that the shift provided matches the size
   // of your data.
-  Address form_address(Register Rd, Register base, long byte_offset, int shift);
+  Address form_address(Register Rd, Register base, int64_t byte_offset, int shift);
 
   // Return true iff an address is within the 48-bit AArch64 address
   // space.
@@ -1176,7 +1165,7 @@ public:
     if (NearCpool) {
       ldr(dest, const_addr);
     } else {
-      unsigned long offset;
+      uint64_t offset;
       adrp(dest, InternalAddress(const_addr.target()), offset);
       ldr(dest, Address(dest, offset));
     }
@@ -1288,7 +1277,7 @@ private:
   // Uses rscratch2 if the address is not directly reachable
   Address spill_address(int size, int offset, Register tmp=rscratch2);
 
-  bool merge_alignment_check(Register base, size_t size, long cur_offset, long prev_offset) const;
+  bool merge_alignment_check(Register base, size_t size, int64_t cur_offset, int64_t prev_offset) const;
 
   // Check whether two loads/stores can be merged into ldp/stp.
   bool ldst_can_merge(Register rx, const Address &adr, size_t cur_size_in_bytes, bool is_store) const;
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/macroAssembler_aarch64_log.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/macroAssembler_aarch64_log.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/macroAssembler_aarch64_log.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/macroAssembler_aarch64_log.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -260,9 +260,9 @@ void MacroAssembler::fast_log(FloatRegis
                               Register tmp4, Register tmp5) {
   Label DONE, CHECK_CORNER_CASES, SMALL_VALUE, MAIN,
       CHECKED_CORNER_CASES, RETURN_MINF_OR_NAN;
-  const long INF_OR_NAN_PREFIX = 0x7FF0;
-  const long MINF_OR_MNAN_PREFIX = 0xFFF0;
-  const long ONE_PREFIX = 0x3FF0;
+  const int64_t INF_OR_NAN_PREFIX = 0x7FF0;
+  const int64_t MINF_OR_MNAN_PREFIX = 0xFFF0;
+  const int64_t ONE_PREFIX = 0x3FF0;
     movz(tmp2, ONE_PREFIX, 48);
     movz(tmp4, 0x0010, 48);
     fmovd(rscratch1, v0); // rscratch1 = AS_LONG_BITS(X)
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/macroAssembler_aarch64_trig.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/macroAssembler_aarch64_trig.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/macroAssembler_aarch64_trig.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/macroAssembler_aarch64_trig.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -201,9 +201,9 @@
 // NOTE: fpu registers are actively reused. See comments in code about their usage
 void MacroAssembler::generate__ieee754_rem_pio2(address npio2_hw,
     address two_over_pi, address pio2) {
-  const long PIO2_1t = 0x3DD0B4611A626331UL;
-  const long PIO2_2  = 0x3DD0B4611A600000UL;
-  const long PIO2_2t = 0x3BA3198A2E037073UL;
+  const int64_t PIO2_1t = 0x3DD0B4611A626331ULL;
+  const int64_t PIO2_2  = 0x3DD0B4611A600000ULL;
+  const int64_t PIO2_2t = 0x3BA3198A2E037073ULL;
   Label X_IS_NEGATIVE, X_IS_MEDIUM_OR_LARGE, X_IS_POSITIVE_LONG_PI, LARGE_ELSE,
       REDUCTION_DONE, X_IS_MEDIUM_BRANCH_DONE, X_IS_LARGE, NX_SET,
       X_IS_NEGATIVE_LONG_PI;
@@ -689,7 +689,7 @@ void MacroAssembler::generate__kernel_re
       RECOMP_FOR1_CHECK;
   Register tmp2 = r1, n = r2, jv = r4, tmp5 = r5, jx = r6,
       tmp3 = r7, iqBase = r10, ih = r11, tmp4 = r12, tmp1 = r13,
-      jz = r14, j = r15, twoOverPiBase = r16, i = r17, qBase = r18;
+      jz = r14, j = r15, twoOverPiBase = r16, i = r17, qBase = r20;
     // jp = jk == init_jk[prec] = init_jk[2] == {2,3,4,6}[2] == 4
     // jx = nx - 1
     lea(twoOverPiBase, ExternalAddress(two_over_pi));
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/nativeInst_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/nativeInst_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/nativeInst_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/nativeInst_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, 2018, Red Hat Inc. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -301,7 +301,7 @@ void NativeMovRegMem::set_offset(int x) 
   unsigned insn = *(unsigned*)pc;
   if (maybe_cpool_ref(pc)) {
     address addr = MacroAssembler::target_addr_for_insn(pc);
-    *(long*)addr = x;
+    *(int64_t*)addr = x;
   } else {
     MacroAssembler::pd_patch_instruction(pc, (address)intptr_t(x));
     ICache::invalidate_range(instruction_address(), instruction_size);
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/register_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/register_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/register_aarch64.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/register_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -64,7 +64,7 @@ class RegisterImpl: public AbstractRegis
 
   // Return the bit which represents this register.  This is intended
   // to be ORed into a bitmask: for usage see class RegSet below.
-  unsigned long bit(bool should_set = true) const { return should_set ? 1 << encoding() : 0; }
+  uint64_t bit(bool should_set = true) const { return should_set ? 1 << encoding() : 0; }
 };
 
 // The integer registers of the aarch64 architecture
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -396,7 +396,7 @@ static void gen_c2i_adapter(MacroAssembl
     // 3    8 T_BOOL
     // -    0 return address
     //
-    // However to make thing extra confusing. Because we can fit a long/double in
+    // However to make thing extra confusing. Because we can fit a Java long/double in
     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
     // leaves one slot empty and only stores to a single slot. In this case the
     // slot that is occupied is the T_VOID slot. See I said it was confusing.
@@ -429,7 +429,7 @@ static void gen_c2i_adapter(MacroAssembl
           __ str(rscratch1, Address(sp, next_off));
 #ifdef ASSERT
           // Overwrite the unused slot with known junk
-          __ mov(rscratch1, 0xdeadffffdeadaaaaul);
+          __ mov(rscratch1, (uint64_t)0xdeadffffdeadaaaaull);
           __ str(rscratch1, Address(sp, st_off));
 #endif /* ASSERT */
         } else {
@@ -446,10 +446,9 @@ static void gen_c2i_adapter(MacroAssembl
         // Two VMREgs|OptoRegs can be T_OBJECT, T_ADDRESS, T_DOUBLE, T_LONG
         // T_DOUBLE and T_LONG use two slots in the interpreter
         if ( sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
-          // long/double in gpr
+          // jlong/double in gpr
 #ifdef ASSERT
-          // Overwrite the unused slot with known junk
-          __ mov(rscratch1, 0xdeadffffdeadaaabul);
+          __ mov(rscratch1, (uint64_t)0xdeadffffdeadaaabull);
           __ str(rscratch1, Address(sp, st_off));
 #endif /* ASSERT */
           __ str(r, Address(sp, next_off));
@@ -465,7 +464,7 @@ static void gen_c2i_adapter(MacroAssembl
       } else {
 #ifdef ASSERT
         // Overwrite the unused slot with known junk
-        __ mov(rscratch1, 0xdeadffffdeadaaacul);
+        __ mov(rscratch1, (uint64_t)0xdeadffffdeadaaacull);
         __ str(rscratch1, Address(sp, st_off));
 #endif /* ASSERT */
         __ strd(r_1->as_FloatRegister(), Address(sp, next_off));
@@ -745,6 +744,11 @@ int SharedRuntime::c_calling_convention(
         if (int_args < Argument::n_int_register_parameters_c) {
           regs[i].set1(INT_ArgReg[int_args++]->as_VMReg());
         } else {
+#ifdef __APPLE__
+          // Less-than word types are stored one after another.
+          // The code unable to handle this, bailout.
+          return -1;
+#endif
           regs[i].set1(VMRegImpl::stack2reg(stk_args));
           stk_args += 2;
         }
@@ -767,6 +771,11 @@ int SharedRuntime::c_calling_convention(
         if (fp_args < Argument::n_float_register_parameters_c) {
           regs[i].set1(FP_ArgReg[fp_args++]->as_VMReg());
         } else {
+#ifdef __APPLE__
+          // Less-than word types are stored one after another.
+          // The code unable to handle this, bailout.
+          return -1;
+#endif
           regs[i].set1(VMRegImpl::stack2reg(stk_args));
           stk_args += 2;
         }
@@ -1343,6 +1352,10 @@ nmethod* SharedRuntime::generate_native_
   int out_arg_slots;
   out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
 
+  if (out_arg_slots < 0) {
+    return NULL;
+  }
+
   // Compute framesize for the wrapper.  We need to handlize all oops in
   // incoming registers
 
@@ -1675,7 +1688,7 @@ nmethod* SharedRuntime::generate_native_
 
   Label dtrace_method_entry, dtrace_method_entry_done;
   {
-    unsigned long offset;
+    uint64_t offset;
     __ adrp(rscratch1, ExternalAddress((address)&DTraceMethodProbes), offset);
     __ ldrb(rscratch1, Address(rscratch1, offset));
     __ cbnzw(rscratch1, dtrace_method_entry);
@@ -1926,7 +1939,7 @@ nmethod* SharedRuntime::generate_native_
 
   Label dtrace_method_exit, dtrace_method_exit_done;
   {
-    unsigned long offset;
+    uint64_t offset;
     __ adrp(rscratch1, ExternalAddress((address)&DTraceMethodProbes), offset);
     __ ldrb(rscratch1, Address(rscratch1, offset));
     __ cbnzw(rscratch1, dtrace_method_exit);
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/stubGenerator_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1072,7 +1072,7 @@ class StubGenerator: public StubCodeGene
     Label copy4, copy8, copy16, copy32, copy80, copy128, copy_big, finish;
     const Register t2 = r5, t3 = r6, t4 = r7, t5 = r8;
     const Register t6 = r9, t7 = r10, t8 = r11, t9 = r12;
-    const Register send = r17, dend = r18;
+    const Register send = r17, dend = r16;
 
     if (PrefetchCopyIntervalInBytes > 0)
       __ prfm(Address(s, 0), PLDL1KEEP);
@@ -1264,7 +1264,7 @@ class StubGenerator: public StubCodeGene
 #ifdef ASSERT
     __ mov(rscratch1, (uint64_t)0xdeadbeef);
     __ orr(rscratch1, rscratch1, rscratch1, Assembler::LSL, 32);
-    for (Register r = r3; r <= r18; r++)
+    for (Register r = r3; r <= NOT_BSD(r18) BSD_ONLY(r17); r++)
       if (r != rscratch1) __ mov(r, rscratch1);
 #endif
   }
@@ -1689,10 +1689,10 @@ class StubGenerator: public StubCodeGene
     RegSet wb_pre_saved_regs = RegSet::range(c_rarg0, c_rarg4);
     RegSet wb_post_saved_regs = RegSet::of(count);
 
-    // Registers used as temps (r18, r19, r20 are save-on-entry)
+    // Registers used as temps (r19, r20, r21, r22 are save-on-entry)
+    const Register copied_oop  = r22;       // actual oop copied
     const Register count_save  = r21;       // orig elementscount
     const Register start_to    = r20;       // destination array start address
-    const Register copied_oop  = r18;       // actual oop copied
     const Register r19_klass   = r19;       // oop._klass
 
     //---------------------------------------------------------------
@@ -1730,7 +1730,7 @@ class StubGenerator: public StubCodeGene
      // Empty array:  Nothing to do.
     __ cbz(count, L_done);
 
-    __ push(RegSet::of(r18, r19, r20, r21), sp);
+    __ push(RegSet::of(r19, r20, r21, r22), sp);
 
 #ifdef ASSERT
     BLOCK_COMMENT("assert consistent ckoff/ckval");
@@ -1799,7 +1799,7 @@ class StubGenerator: public StubCodeGene
     bs->arraycopy_epilogue(_masm, decorators, is_oop, start_to, count_save, rscratch1, wb_post_saved_regs);
 
     __ bind(L_done_pop);
-    __ pop(RegSet::of(r18, r19, r20, r21), sp);
+    __ pop(RegSet::of(r19, r20, r21, r22), sp);
     inc_counter_np(SharedRuntime::_checkcast_array_copy_ctr);
 
     __ bind(L_done);
@@ -1975,7 +1975,7 @@ class StubGenerator: public StubCodeGene
     // registers used as temp
     const Register scratch_length    = r16; // elements count to copy
     const Register scratch_src_klass = r17; // array klass
-    const Register lh                = r18; // layout helper
+    const Register lh                = r15; // layout helper
 
     //  if (length < 0) return -1;
     __ movw(scratch_length, length);        // length (elements count, 32-bits value)
@@ -2046,7 +2046,7 @@ class StubGenerator: public StubCodeGene
     //
 
     const Register rscratch1_offset = rscratch1;    // array offset
-    const Register r18_elsize = lh; // element size
+    const Register r15_elsize = lh; // element size
 
     __ ubfx(rscratch1_offset, lh, Klass::_lh_header_size_shift,
            exact_log2(Klass::_lh_header_size_mask+1));   // array_offset
@@ -2067,8 +2067,8 @@ class StubGenerator: public StubCodeGene
     // The possible values of elsize are 0-3, i.e. exact_log2(element
     // size in bytes).  We do a simple bitwise binary search.
   __ BIND(L_copy_bytes);
-    __ tbnz(r18_elsize, 1, L_copy_ints);
-    __ tbnz(r18_elsize, 0, L_copy_shorts);
+    __ tbnz(r15_elsize, 1, L_copy_ints);
+    __ tbnz(r15_elsize, 0, L_copy_shorts);
     __ lea(from, Address(src, src_pos));// src_addr
     __ lea(to,   Address(dst, dst_pos));// dst_addr
     __ movw(count, scratch_length); // length
@@ -2081,7 +2081,7 @@ class StubGenerator: public StubCodeGene
     __ b(RuntimeAddress(short_copy_entry));
 
   __ BIND(L_copy_ints);
-    __ tbnz(r18_elsize, 0, L_copy_longs);
+    __ tbnz(r15_elsize, 0, L_copy_longs);
     __ lea(from, Address(src, src_pos, Address::lsl(2)));// src_addr
     __ lea(to,   Address(dst, dst_pos, Address::lsl(2)));// dst_addr
     __ movw(count, scratch_length); // length
@@ -2092,8 +2092,8 @@ class StubGenerator: public StubCodeGene
     {
       BLOCK_COMMENT("assert long copy {");
       Label L;
-      __ andw(lh, lh, Klass::_lh_log2_element_size_mask); // lh -> r18_elsize
-      __ cmpw(r18_elsize, LogBytesPerLong);
+      __ andw(lh, lh, Klass::_lh_log2_element_size_mask); // lh -> r15_elsize
+      __ cmpw(r15_elsize, LogBytesPerLong);
       __ br(Assembler::EQ, L);
       __ stop("must be long copy, but elsize is wrong");
       __ bind(L);
@@ -2111,8 +2111,8 @@ class StubGenerator: public StubCodeGene
 
     Label L_plain_copy, L_checkcast_copy;
     //  test array classes for subtyping
-    __ load_klass(r18, dst);
-    __ cmp(scratch_src_klass, r18); // usual case is exact equality
+    __ load_klass(r15, dst);
+    __ cmp(scratch_src_klass, r15); // usual case is exact equality
     __ br(Assembler::NE, L_checkcast_copy);
 
     // Identically typed arrays can be copied without element-wise checks.
@@ -2128,17 +2128,17 @@ class StubGenerator: public StubCodeGene
     __ b(RuntimeAddress(oop_copy_entry));
 
   __ BIND(L_checkcast_copy);
-    // live at this point:  scratch_src_klass, scratch_length, r18 (dst_klass)
+    // live at this point:  scratch_src_klass, scratch_length, r15 (dst_klass)
     {
       // Before looking at dst.length, make sure dst is also an objArray.
-      __ ldrw(rscratch1, Address(r18, lh_offset));
+      __ ldrw(rscratch1, Address(r15, lh_offset));
       __ movw(rscratch2, objArray_lh);
       __ eorw(rscratch1, rscratch1, rscratch2);
       __ cbnzw(rscratch1, L_failed);
 
       // It is safe to examine both src.length and dst.length.
       arraycopy_range_checks(src, src_pos, dst, dst_pos, scratch_length,
-                             r18, L_failed);
+                             r15, L_failed);
 
       __ load_klass(dst_klass, dst); // reload
 
@@ -3215,8 +3215,8 @@ class StubGenerator: public StubCodeGene
 
     // Max number of bytes we can process before having to take the mod
     // 0x15B0 is 5552 in decimal, the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1
-    unsigned long BASE = 0xfff1;
-    unsigned long NMAX = 0x15B0;
+    uint64_t BASE = 0xfff1;
+    uint64_t NMAX = 0x15B0;
 
     __ mov(base, BASE);
     __ mov(nmax, NMAX);
@@ -4833,40 +4833,49 @@ class StubGenerator: public StubCodeGene
       if (squaring)
         Pb_base = Pa_base;
       else
-        Pb_base = ++reg;
-      Pn_base = ++reg;
-      Rlen= ++reg;
-      inv = ++reg;
-      Pm_base = ++reg;
+        Pb_base = next_reg(reg);
+      Pn_base = next_reg(reg);
+      Rlen= next_reg(reg);
+      inv = next_reg(reg);
+      Pm_base = next_reg(reg);
 
                           // Working registers:
-      Ra =  ++reg;        // The current digit of a, b, n, and m.
-      Rb =  ++reg;
-      Rm =  ++reg;
-      Rn =  ++reg;
-
-      Pa =  ++reg;        // Pointers to the current/next digit of a, b, n, and m.
-      Pb =  ++reg;
-      Pm =  ++reg;
-      Pn =  ++reg;
-
-      t0 =  ++reg;        // Three registers which form a
-      t1 =  ++reg;        // triple-precision accumuator.
-      t2 =  ++reg;
-
-      Ri =  ++reg;        // Inner and outer loop indexes.
-      Rj =  ++reg;
-
-      Rhi_ab = ++reg;     // Product registers: low and high parts
-      Rlo_ab = ++reg;     // of a*b and m*n.
-      Rhi_mn = ++reg;
-      Rlo_mn = ++reg;
+      Ra =  next_reg(reg);        // The current digit of a, b, n, and m.
+      Rb =  next_reg(reg);
+      Rm =  next_reg(reg);
+      Rn =  next_reg(reg);
+
+      Pa =  next_reg(reg);        // Pointers to the current/next digit of a, b, n, and m.
+      Pb =  next_reg(reg);
+      Pm =  next_reg(reg);
+      Pn =  next_reg(reg);
+
+      t0 =  next_reg(reg);        // Three registers which form a
+      t1 =  next_reg(reg);        // triple-precision accumuator.
+      t2 =  next_reg(reg);
+
+      Ri =  next_reg(reg);        // Inner and outer loop indexes.
+      Rj =  next_reg(reg);
+
+      Rhi_ab = next_reg(reg);     // Product registers: low and high parts
+      Rlo_ab = next_reg(reg);     // of a*b and m*n.
+      Rhi_mn = next_reg(reg);
+      Rlo_mn = next_reg(reg);
 
       // r19 and up are callee-saved.
       _toSave = RegSet::range(r19, reg) + Pm_base;
     }
 
   private:
+    Register next_reg(Register &reg) {
+#ifdef __APPLE__
+      // skip r18 on macOSs, it should not be used
+      return ++reg == r18 ? ++reg : reg;
+#else
+      return ++reg;
+#endif
+    }
+
     void save_regs() {
       push(_toSave, sp);
     }
@@ -5319,12 +5328,12 @@ class StubGenerator: public StubCodeGene
     // In C, approximately:
 
     // void
-    // montgomery_multiply(unsigned long Pa_base[], unsigned long Pb_base[],
-    //                     unsigned long Pn_base[], unsigned long Pm_base[],
-    //                     unsigned long inv, int len) {
-    //   unsigned long t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
-    //   unsigned long *Pa, *Pb, *Pn, *Pm;
-    //   unsigned long Ra, Rb, Rn, Rm;
+    // montgomery_multiply(julong Pa_base[], julong Pb_base[],
+    //                     julong Pn_base[], julong Pm_base[],
+    //                     julong inv, int len) {
+    //   julong t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
+    //   julong *Pa, *Pb, *Pn, *Pm;
+    //   julong Ra, Rb, Rn, Rm;
 
     //   int i;
 
@@ -5532,11 +5541,12 @@ class StubGenerator: public StubCodeGene
     // In C, approximately:
 
     // void
-    // montgomery_square(unsigned long Pa_base[], unsigned long Pn_base[],
-    //                   unsigned long Pm_base[], unsigned long inv, int len) {
-    //   unsigned long t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
-    //   unsigned long *Pa, *Pb, *Pn, *Pm;
-    //   unsigned long Ra, Rb, Rn, Rm;
+    // montgomery_multiply(julong Pa_base[], julong Pb_base[],
+    //                     julong Pn_base[], julong Pm_base[],
+    //                     julong inv, int len) {
+    //   julong t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
+    //   julong *Pa, *Pb, *Pn, *Pm;
+    //   julong Ra, Rb, Rn, Rm;
 
     //   int i;
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/templateInterpreterGenerator_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1003,7 +1003,7 @@ address TemplateInterpreterGenerator::ge
     __ ldrw(val, Address(esp, 0));              // byte value
     __ ldrw(crc, Address(esp, wordSize));       // Initial CRC
 
-    unsigned long offset;
+    uint64_t offset;
     __ adrp(tbl, ExternalAddress(StubRoutines::crc_table_addr()), offset);
     __ add(tbl, tbl, offset);
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/vm_version_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -24,100 +24,33 @@
  */
 
 #include "precompiled.hpp"
-#include "asm/macroAssembler.hpp"
-#include "asm/macroAssembler.inline.hpp"
-#include "memory/resourceArea.hpp"
+#include "runtime/arguments.hpp"
 #include "runtime/java.hpp"
-#include "runtime/stubCodeGenerator.hpp"
+#include "runtime/vm_version.hpp"
 #include "utilities/macros.hpp"
-#include "vm_version_aarch64.hpp"
 
 #include OS_HEADER_INLINE(os)
 
-#include <sys/auxv.h>
-#include <asm/hwcap.h>
-
-#ifndef HWCAP_AES
-#define HWCAP_AES   (1<<3)
-#endif
-
-#ifndef HWCAP_PMULL
-#define HWCAP_PMULL (1<<4)
-#endif
-
-#ifndef HWCAP_SHA1
-#define HWCAP_SHA1  (1<<5)
-#endif
-
-#ifndef HWCAP_SHA2
-#define HWCAP_SHA2  (1<<6)
-#endif
-
-#ifndef HWCAP_CRC32
-#define HWCAP_CRC32 (1<<7)
-#endif
-
-#ifndef HWCAP_ATOMICS
-#define HWCAP_ATOMICS (1<<8)
-#endif
-
 int VM_Version::_cpu;
 int VM_Version::_model;
 int VM_Version::_model2;
 int VM_Version::_variant;
 int VM_Version::_revision;
 int VM_Version::_stepping;
-VM_Version::PsrInfo VM_Version::_psr_info   = { 0, };
-
-static BufferBlob* stub_blob;
-static const int stub_size = 550;
-
-extern "C" {
-  typedef void (*getPsrInfo_stub_t)(void*);
-}
-static getPsrInfo_stub_t getPsrInfo_stub = NULL;
-
-
-class VM_Version_StubGenerator: public StubCodeGenerator {
- public:
-
-  VM_Version_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}
-
-  address generate_getPsrInfo() {
-    StubCodeMark mark(this, "VM_Version", "getPsrInfo_stub");
-#   define __ _masm->
-    address start = __ pc();
-
-    // void getPsrInfo(VM_Version::PsrInfo* psr_info);
-
-    address entry = __ pc();
-
-    __ enter();
 
-    __ get_dczid_el0(rscratch1);
-    __ strw(rscratch1, Address(c_rarg0, in_bytes(VM_Version::dczid_el0_offset())));
+int VM_Version::_zva_length;
+int VM_Version::_dcache_line_size;
+int VM_Version::_icache_line_size;
+int VM_Version::_initial_sve_vector_length;
 
-    __ get_ctr_el0(rscratch1);
-    __ strw(rscratch1, Address(c_rarg0, in_bytes(VM_Version::ctr_el0_offset())));
-
-    __ leave();
-    __ ret(lr);
-
-#   undef __
-
-    return start;
-  }
-};
-
-
-void VM_Version::get_processor_features() {
+void VM_Version::initialize() {
   _supports_cx8 = true;
   _supports_atomic_getset4 = true;
   _supports_atomic_getadd4 = true;
   _supports_atomic_getset8 = true;
   _supports_atomic_getadd8 = true;
 
-  getPsrInfo_stub(&_psr_info);
+  get_os_cpu_info();
 
   int dcache_line = VM_Version::dcache_line_size();
 
@@ -159,34 +92,6 @@ void VM_Version::get_processor_features(
     SoftwarePrefetchHintDistance &= ~7;
   }
 
-  unsigned long auxv = getauxval(AT_HWCAP);
-
-  char buf[512];
-
-  _features = auxv;
-
-  int cpu_lines = 0;
-  if (FILE *f = fopen("/proc/cpuinfo", "r")) {
-    char buf[128], *p;
-    while (fgets(buf, sizeof (buf), f) != NULL) {
-      if ((p = strchr(buf, ':')) != NULL) {
-        long v = strtol(p+1, NULL, 0);
-        if (strncmp(buf, "CPU implementer", sizeof "CPU implementer" - 1) == 0) {
-          _cpu = v;
-          cpu_lines++;
-        } else if (strncmp(buf, "CPU variant", sizeof "CPU variant" - 1) == 0) {
-          _variant = v;
-        } else if (strncmp(buf, "CPU part", sizeof "CPU part" - 1) == 0) {
-          if (_model != v)  _model2 = _model;
-          _model = v;
-        } else if (strncmp(buf, "CPU revision", sizeof "CPU revision" - 1) == 0) {
-          _revision = v;
-        }
-      }
-    }
-    fclose(f);
-  }
-
   // Enable vendor specific features
 
   // ThunderX
@@ -237,27 +142,31 @@ void VM_Version::get_processor_features(
   }
 
   if (_cpu == CPU_ARM && (_model == 0xd07 || _model2 == 0xd07)) _features |= CPU_STXR_PREFETCH;
-  // If an olde style /proc/cpuinfo (cpu_lines == 1) then if _model is an A57 (0xd07)
+  // If an olde style /proc/cpuinfo (cores == 1) then if _model is an A57 (0xd07)
   // we assume the worst and assume we could be on a big little system and have
   // undisclosed A53 cores which we could be swapped to at any stage
-  if (_cpu == CPU_ARM && cpu_lines == 1 && _model == 0xd07) _features |= CPU_A53MAC;
+  if (_cpu == CPU_ARM && os::processor_count() == 1 && _model == 0xd07) _features |= CPU_A53MAC;
 
+  char buf[512];
   sprintf(buf, "0x%02x:0x%x:0x%03x:%d", _cpu, _variant, _model, _revision);
   if (_model2) sprintf(buf+strlen(buf), "(0x%03x)", _model2);
-  if (auxv & HWCAP_ASIMD) strcat(buf, ", simd");
-  if (auxv & HWCAP_CRC32) strcat(buf, ", crc");
-  if (auxv & HWCAP_AES)   strcat(buf, ", aes");
-  if (auxv & HWCAP_SHA1)  strcat(buf, ", sha1");
-  if (auxv & HWCAP_SHA2)  strcat(buf, ", sha256");
-  if (auxv & HWCAP_ATOMICS) strcat(buf, ", lse");
+  if (_features & CPU_ASIMD) strcat(buf, ", simd");
+  if (_features & CPU_CRC32) strcat(buf, ", crc");
+  if (_features & CPU_AES)   strcat(buf, ", aes");
+  if (_features & CPU_SHA1)  strcat(buf, ", sha1");
+  if (_features & CPU_SHA2)  strcat(buf, ", sha256");
+  if (_features & CPU_SHA512) strcat(buf, ", sha512");
+  if (_features & CPU_LSE) strcat(buf, ", lse");
+  if (_features & CPU_SVE) strcat(buf, ", sve");
+  if (_features & CPU_SVE2) strcat(buf, ", sve2");
 
   _features_string = os::strdup(buf);
 
   if (FLAG_IS_DEFAULT(UseCRC32)) {
-    UseCRC32 = (auxv & HWCAP_CRC32) != 0;
+    UseCRC32 = (_features & CPU_CRC32) != 0;
   }
 
-  if (UseCRC32 && (auxv & HWCAP_CRC32) == 0) {
+  if (UseCRC32 && (_features & CPU_CRC32) == 0) {
     warning("UseCRC32 specified, but not supported on this CPU");
     FLAG_SET_DEFAULT(UseCRC32, false);
   }
@@ -271,7 +180,7 @@ void VM_Version::get_processor_features(
     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
   }
 
-  if (auxv & HWCAP_ATOMICS) {
+  if (_features & CPU_LSE) {
     if (FLAG_IS_DEFAULT(UseLSE))
       FLAG_SET_DEFAULT(UseLSE, true);
   } else {
@@ -281,7 +190,7 @@ void VM_Version::get_processor_features(
     }
   }
 
-  if (auxv & HWCAP_AES) {
+  if (_features & CPU_AES) {
     UseAES = UseAES || FLAG_IS_DEFAULT(UseAES);
     UseAESIntrinsics =
         UseAESIntrinsics || (UseAES && FLAG_IS_DEFAULT(UseAESIntrinsics));
@@ -309,7 +218,7 @@ void VM_Version::get_processor_features(
     UseCRC32Intrinsics = true;
   }
 
-  if (auxv & HWCAP_CRC32) {
+  if (_features & CPU_CRC32) {
     if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
       FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
     }
@@ -322,7 +231,7 @@ void VM_Version::get_processor_features(
     FLAG_SET_DEFAULT(UseFMA, true);
   }
 
-  if (auxv & (HWCAP_SHA1 | HWCAP_SHA2)) {
+  if (_features & (CPU_SHA1 | CPU_SHA2)) {
     if (FLAG_IS_DEFAULT(UseSHA)) {
       FLAG_SET_DEFAULT(UseSHA, true);
     }
@@ -331,7 +240,7 @@ void VM_Version::get_processor_features(
     FLAG_SET_DEFAULT(UseSHA, false);
   }
 
-  if (UseSHA && (auxv & HWCAP_SHA1)) {
+  if (UseSHA && (_features & CPU_SHA1)) {
     if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {
       FLAG_SET_DEFAULT(UseSHA1Intrinsics, true);
     }
@@ -340,7 +249,7 @@ void VM_Version::get_processor_features(
     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
   }
 
-  if (UseSHA && (auxv & HWCAP_SHA2)) {
+  if (UseSHA && (_features & CPU_SHA2)) {
     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
     }
@@ -358,7 +267,7 @@ void VM_Version::get_processor_features(
     FLAG_SET_DEFAULT(UseSHA, false);
   }
 
-  if (auxv & HWCAP_PMULL) {
+  if (_features & CPU_PMULL) {
     if (FLAG_IS_DEFAULT(UseGHASHIntrinsics)) {
       FLAG_SET_DEFAULT(UseGHASHIntrinsics, true);
     }
@@ -416,22 +325,6 @@ void VM_Version::get_processor_features(
     OptoScheduling = true;
   }
 #endif
-}
-
-void VM_Version::initialize() {
-  ResourceMark rm;
-
-  stub_blob = BufferBlob::create("getPsrInfo_stub", stub_size);
-  if (stub_blob == NULL) {
-    vm_exit_during_initialization("Unable to allocate getPsrInfo_stub");
-  }
-
-  CodeBuffer c(stub_blob);
-  VM_Version_StubGenerator g(&c);
-  getPsrInfo_stub = CAST_TO_FN_PTR(getPsrInfo_stub_t,
-                                   g.generate_getPsrInfo());
-
-  get_processor_features();
 
   UNSUPPORTED_OPTION(CriticalJNINatives);
 }
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/vm_version_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -26,8 +26,8 @@
 #ifndef CPU_AARCH64_VM_VM_VERSION_AARCH64_HPP
 #define CPU_AARCH64_VM_VM_VERSION_AARCH64_HPP
 
+#include "runtime/abstract_vm_version.hpp"
 #include "runtime/globals_extension.hpp"
-#include "runtime/vm_version.hpp"
 #include "utilities/sizes.hpp"
 
 class VM_Version : public Abstract_VM_Version {
@@ -41,12 +41,19 @@ protected:
   static int _revision;
   static int _stepping;
 
-  struct PsrInfo {
-    uint32_t dczid_el0;
-    uint32_t ctr_el0;
-  };
-  static PsrInfo _psr_info;
-  static void get_processor_features();
+  static int _zva_length;
+  static int _dcache_line_size;
+  static int _icache_line_size;
+  static int _initial_sve_vector_length;
+
+  // Read additional info using OS-specific interfaces
+  static void get_os_cpu_info();
+
+  // Sets the SVE length and returns a new actual value or negative on error.
+  // If the len is larger than the system largest supported SVE vector length,
+  // the function sets the largest supported value.
+  static int set_and_get_current_sve_vector_lenght(int len);
+  static int get_current_sve_vector_length();
 
 public:
   // Initialization
@@ -79,6 +86,7 @@ public:
     CPU_QUALCOM   = 'Q',
     CPU_MARVELL   = 'V',
     CPU_INTEL     = 'i',
+    CPU_APPLE     = 'a',
   };
 
   enum Feature_Flag {
@@ -91,9 +99,14 @@ public:
     CPU_SHA2         = (1<<6),
     CPU_CRC32        = (1<<7),
     CPU_LSE          = (1<<8),
-    CPU_STXR_PREFETCH= (1 << 29),
-    CPU_A53MAC       = (1 << 30),
-    CPU_DMB_ATOMICS  = (1 << 31),
+    CPU_DCPOP        = (1<<16),
+    CPU_SHA512       = (1<<21),
+    CPU_SVE          = (1<<22),
+    // flags above must follow Linux HWCAP
+    CPU_SVE2         = (1<<28),
+    CPU_STXR_PREFETCH= (1<<29),
+    CPU_A53MAC       = (1<<30),
+    CPU_DMB_ATOMICS  = (1<<31),
   };
 
   static int cpu_family()                     { return _cpu; }
@@ -101,24 +114,16 @@ public:
   static int cpu_model2()                     { return _model2; }
   static int cpu_variant()                    { return _variant; }
   static int cpu_revision()                   { return _revision; }
-  static ByteSize dczid_el0_offset() { return byte_offset_of(PsrInfo, dczid_el0); }
-  static ByteSize ctr_el0_offset()   { return byte_offset_of(PsrInfo, ctr_el0); }
-  static bool is_zva_enabled() {
-    // Check the DZP bit (bit 4) of dczid_el0 is zero
-    // and block size (bit 0~3) is not zero.
-    return ((_psr_info.dczid_el0 & 0x10) == 0 &&
-            (_psr_info.dczid_el0 & 0xf) != 0);
-  }
+
+  static bool is_zva_enabled() { return 0 <= _zva_length; }
   static int zva_length() {
     assert(is_zva_enabled(), "ZVA not available");
-    return 4 << (_psr_info.dczid_el0 & 0xf);
-  }
-  static int icache_line_size() {
-    return (1 << (_psr_info.ctr_el0 & 0x0f)) * 4;
-  }
-  static int dcache_line_size() {
-    return (1 << ((_psr_info.ctr_el0 >> 16) & 0x0f)) * 4;
+    return _zva_length;
   }
+
+  static int icache_line_size() { return _icache_line_size; }
+  static int dcache_line_size() { return _dcache_line_size; }
+  static int get_initial_sve_vector_length()  { return _initial_sve_vector_length; };
 };
 
 #endif // CPU_AARCH64_VM_VM_VERSION_AARCH64_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/vm_version_ext_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/vm_version_ext_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/aarch64/vm_version_ext_aarch64.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/aarch64/vm_version_ext_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -25,8 +25,8 @@
 #ifndef CPU_AARCH64_VM_VM_VERSION_EXT_AARCH64_HPP
 #define CPU_AARCH64_VM_VM_VERSION_EXT_AARCH64_HPP
 
+#include "runtime/vm_version.hpp"
 #include "utilities/macros.hpp"
-#include "vm_version_aarch64.hpp"
 
 class VM_Version_Ext : public VM_Version {
  private:
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/arm/register_arm.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/arm/register_arm.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/arm/register_arm.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/arm/register_arm.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -26,7 +26,7 @@
 #define CPU_ARM_VM_REGISTER_ARM_HPP
 
 #include "asm/register.hpp"
-#include "vm_version_arm.hpp"
+#include "runtime/vm_version.hpp"
 
 class VMRegImpl;
 typedef VMRegImpl* VMReg;
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/arm/vm_version_arm.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/arm/vm_version_arm.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/arm/vm_version_arm.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/arm/vm_version_arm.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -25,8 +25,8 @@
 #ifndef CPU_ARM_VM_VM_VERSION_ARM_HPP
 #define CPU_ARM_VM_VM_VERSION_ARM_HPP
 
+#include "runtime/abstract_vm_version.hpp"
 #include "runtime/globals_extension.hpp"
-#include "runtime/vm_version.hpp"
 
 class VM_Version: public Abstract_VM_Version {
   friend class JVMCIVMStructs;
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/arm/vm_version_arm_32.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/arm/vm_version_arm_32.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/arm/vm_version_arm_32.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/arm/vm_version_arm_32.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,7 +29,7 @@
 #include "runtime/java.hpp"
 #include "runtime/os.inline.hpp"
 #include "runtime/stubCodeGenerator.hpp"
-#include "vm_version_arm.hpp"
+#include "runtime/vm_version.hpp"
 
 int  VM_Version::_stored_pc_adjustment = 4;
 int  VM_Version::_arm_arch             = 5;
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/arm/vm_version_ext_arm.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/arm/vm_version_ext_arm.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/arm/vm_version_ext_arm.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/arm/vm_version_ext_arm.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -25,8 +25,8 @@
 #ifndef CPU_ARM_VM_VM_VERSION_EXT_ARM_HPP
 #define CPU_ARM_VM_VM_VERSION_EXT_ARM_HPP
 
+#include "runtime/vm_version.hpp"
 #include "utilities/macros.hpp"
-#include "vm_version_arm.hpp"
 
 class VM_Version_Ext : public VM_Version {
  private:
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/ppc/vm_version_ext_ppc.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/ppc/vm_version_ext_ppc.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/ppc/vm_version_ext_ppc.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/ppc/vm_version_ext_ppc.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -25,8 +25,8 @@
 #ifndef CPU_PPC_VM_VM_VERSION_EXT_PPC_HPP
 #define CPU_PPC_VM_VM_VERSION_EXT_PPC_HPP
 
+#include "runtime/vm_version.hpp"
 #include "utilities/macros.hpp"
-#include "vm_version_ppc.hpp"
 
 #define CPU_INFO        "cpu_info"
 #define CPU_TYPE        "fpu_type"
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/ppc/vm_version_ppc.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/ppc/vm_version_ppc.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/ppc/vm_version_ppc.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/ppc/vm_version_ppc.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -32,10 +32,10 @@
 #include "runtime/java.hpp"
 #include "runtime/os.hpp"
 #include "runtime/stubCodeGenerator.hpp"
+#include "runtime/vm_version.hpp"
 #include "utilities/align.hpp"
 #include "utilities/defaultStream.hpp"
 #include "utilities/globalDefinitions.hpp"
-#include "vm_version_ppc.hpp"
 
 #include <sys/sysinfo.h>
 #if defined(_AIX)
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/ppc/vm_version_ppc.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/ppc/vm_version_ppc.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/ppc/vm_version_ppc.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/ppc/vm_version_ppc.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -26,8 +26,8 @@
 #ifndef CPU_PPC_VM_VM_VERSION_PPC_HPP
 #define CPU_PPC_VM_VM_VERSION_PPC_HPP
 
+#include "runtime/abstract_vm_version.hpp"
 #include "runtime/globals_extension.hpp"
-#include "runtime/vm_version.hpp"
 
 class VM_Version: public Abstract_VM_Version {
 protected:
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/s390/register_s390.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/s390/register_s390.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/s390/register_s390.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/s390/register_s390.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2016, 2017 SAP SE. All rights reserved.
+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,7 +27,7 @@
 #define CPU_S390_VM_REGISTER_S390_HPP
 
 #include "asm/register.hpp"
-#include "vm_version_s390.hpp"
+#include "runtime/vm_version.hpp"
 
 class Address;
 class VMRegImpl;
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/s390/vm_version_ext_s390.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/s390/vm_version_ext_s390.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/s390/vm_version_ext_s390.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/s390/vm_version_ext_s390.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -25,8 +25,8 @@
 #ifndef CPU_S390_VM_VM_VERSION_EXT_S390_HPP
 #define CPU_S390_VM_VM_VERSION_EXT_S390_HPP
 
+#include "runtime/vm_version.hpp"
 #include "utilities/macros.hpp"
-#include "vm_version_s390.hpp"
 
 #define CPU_INFO        "cpu_info"
 #define CPU_TYPE        "fpu_type"
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/s390/vm_version_s390.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/s390/vm_version_s390.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/s390/vm_version_s390.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/s390/vm_version_s390.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -31,7 +31,7 @@
 #include "memory/resourceArea.hpp"
 #include "runtime/java.hpp"
 #include "runtime/stubCodeGenerator.hpp"
-#include "vm_version_s390.hpp"
+#include "runtime/vm_version.hpp"
 
 # include <sys/sysinfo.h>
 
@@ -44,8 +44,8 @@ unsigned long VM_Version::_msgdigest_fea
 unsigned int  VM_Version::_nfeatures                                = 0;
 unsigned int  VM_Version::_ncipher_features                         = 0;
 unsigned int  VM_Version::_nmsgdigest_features                      = 0;
-unsigned int  VM_Version::_Dcache_lineSize                          = 256;
-unsigned int  VM_Version::_Icache_lineSize                          = 256;
+unsigned int  VM_Version::_Dcache_lineSize                          = DEFAULT_CACHE_LINE_SIZE;
+unsigned int  VM_Version::_Icache_lineSize                          = DEFAULT_CACHE_LINE_SIZE;
 
 static const char* z_gen[]     = {"  ",   "G1",   "G2", "G3",    "G4",     "G5",      "G6",   "G7"   };
 static const char* z_machine[] = {"  ", "2064", "2084", "2094",  "2097",   "2817",    "  ",   "2964" };
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/s390/vm_version_s390.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/s390/vm_version_s390.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/s390/vm_version_s390.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/s390/vm_version_s390.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2016, 2018 SAP SE. All rights reserved.
+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,8 +27,8 @@
 #define CPU_S390_VM_VM_VERSION_S390_HPP
 
 
+#include "runtime/abstract_vm_version.hpp"
 #include "runtime/globals_extension.hpp"
-#include "runtime/vm_version.hpp"
 
 class VM_Version: public Abstract_VM_Version {
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/sparc/vm_version_ext_sparc.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/sparc/vm_version_ext_sparc.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/sparc/vm_version_ext_sparc.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/sparc/vm_version_ext_sparc.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -25,8 +25,8 @@
 #ifndef CPU_SPARC_VM_VM_VERSION_EXT_SPARC_HPP
 #define CPU_SPARC_VM_VM_VERSION_EXT_SPARC_HPP
 
+#include "runtime/vm_version.hpp"
 #include "utilities/macros.hpp"
-#include "vm_version_sparc.hpp"
 
 #if defined(SOLARIS)
 #include <kstat.h>
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/sparc/vm_version_sparc.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/sparc/vm_version_sparc.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/sparc/vm_version_sparc.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/sparc/vm_version_sparc.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,7 +31,7 @@
 #include "runtime/java.hpp"
 #include "runtime/os.hpp"
 #include "runtime/stubCodeGenerator.hpp"
-#include "vm_version_sparc.hpp"
+#include "runtime/vm_version.hpp"
 
 #include <sys/mman.h>
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/sparc/vm_version_sparc.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/sparc/vm_version_sparc.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/sparc/vm_version_sparc.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/sparc/vm_version_sparc.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -25,8 +25,8 @@
 #ifndef CPU_SPARC_VM_VM_VERSION_SPARC_HPP
 #define CPU_SPARC_VM_VM_VERSION_SPARC_HPP
 
+#include "runtime/abstract_vm_version.hpp"
 #include "runtime/globals_extension.hpp"
-#include "runtime/vm_version.hpp"
 
 class VM_Version: public Abstract_VM_Version {
   friend class VMStructs;
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/x86/assembler_x86.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/x86/assembler_x86.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/x86/assembler_x86.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/x86/assembler_x86.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -26,7 +26,7 @@
 #define CPU_X86_VM_ASSEMBLER_X86_HPP
 
 #include "asm/register.hpp"
-#include "vm_version_x86.hpp"
+#include "runtime/vm_version.hpp"
 
 class BiasedLockingCounters;
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -37,6 +37,7 @@
 #include "runtime/safepointMechanism.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/vframeArray.hpp"
+#include "runtime/vm_version.hpp"
 #include "utilities/align.hpp"
 #include "utilities/macros.hpp"
 #include "vmreg_x86.inline.hpp"
@@ -46,7 +47,6 @@
 #ifdef COMPILER2
 #include "opto/runtime.hpp"
 #endif
-#include "vm_version_x86.hpp"
 #if INCLUDE_SHENANDOAHGC
 #include "gc/shenandoah/shenandoahBarrierSet.hpp"
 #include "gc/shenandoah/shenandoahBarrierSetAssembler.hpp"
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -40,10 +40,10 @@
 #include "runtime/safepointMechanism.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/vframeArray.hpp"
+#include "runtime/vm_version.hpp"
 #include "utilities/align.hpp"
 #include "utilities/formatBuffer.hpp"
 #include "utilities/macros.hpp"
-#include "vm_version_x86.hpp"
 #include "vmreg_x86.inline.hpp"
 #ifdef COMPILER1
 #include "c1/c1_Runtime1.hpp"
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/x86/vm_version_ext_x86.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/x86/vm_version_ext_x86.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/x86/vm_version_ext_x86.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/x86/vm_version_ext_x86.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -25,8 +25,8 @@
 #ifndef CPU_X86_VM_VM_VERSION_EXT_X86_HPP
 #define CPU_X86_VM_VM_VERSION_EXT_X86_HPP
 
+#include "runtime/vm_version.hpp"
 #include "utilities/macros.hpp"
-#include "vm_version_x86.hpp"
 
 class VM_Version_Ext : public VM_Version {
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/x86/vm_version_x86.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/x86/vm_version_x86.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/x86/vm_version_x86.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/x86/vm_version_x86.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -32,8 +32,8 @@
 #include "runtime/java.hpp"
 #include "runtime/os.hpp"
 #include "runtime/stubCodeGenerator.hpp"
+#include "runtime/vm_version.hpp"
 #include "utilities/virtualizationSupport.hpp"
-#include "vm_version_x86.hpp"
 
 
 int VM_Version::_cpu;
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/x86/vm_version_x86.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/x86/vm_version_x86.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/x86/vm_version_x86.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/x86/vm_version_x86.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -25,8 +25,8 @@
 #ifndef CPU_X86_VM_VM_VERSION_X86_HPP
 #define CPU_X86_VM_VM_VERSION_X86_HPP
 
+#include "runtime/abstract_vm_version.hpp"
 #include "runtime/globals_extension.hpp"
-#include "runtime/vm_version.hpp"
 
 class VM_Version : public Abstract_VM_Version {
   friend class VMStructs;
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/zero/register_zero.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/zero/register_zero.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/zero/register_zero.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/zero/register_zero.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -27,7 +27,7 @@
 #define CPU_ZERO_VM_REGISTER_ZERO_HPP
 
 #include "asm/register.hpp"
-#include "vm_version_zero.hpp"
+#include "runtime/vm_version.hpp"
 
 class VMRegImpl;
 typedef VMRegImpl* VMReg;
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/zero/vm_version_ext_zero.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/zero/vm_version_ext_zero.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/zero/vm_version_ext_zero.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/zero/vm_version_ext_zero.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -25,8 +25,8 @@
 #ifndef CPU_ZERO_VM_VM_VERSION_EXT_ZERO_HPP
 #define CPU_ZERO_VM_VM_VERSION_EXT_ZERO_HPP
 
+#include "runtime/vm_version.hpp"
 #include "utilities/macros.hpp"
-#include "vm_version_zero.hpp"
 
 class VM_Version_Ext : public VM_Version {
  private:
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/zero/vm_version_zero.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/zero/vm_version_zero.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/zero/vm_version_zero.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/zero/vm_version_zero.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2009 Red Hat, Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
@@ -28,7 +28,7 @@
 #include "memory/resourceArea.hpp"
 #include "runtime/java.hpp"
 #include "runtime/stubCodeGenerator.hpp"
-#include "vm_version_zero.hpp"
+#include "runtime/vm_version.hpp"
 
 
 void VM_Version::initialize() {
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/zero/vm_version_zero.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/zero/vm_version_zero.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/cpu/zero/vm_version_zero.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/cpu/zero/vm_version_zero.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -26,8 +26,8 @@
 #ifndef CPU_ZERO_VM_VM_VERSION_ZERO_HPP
 #define CPU_ZERO_VM_VM_VERSION_ZERO_HPP
 
+#include "runtime/abstract_vm_version.hpp"
 #include "runtime/globals_extension.hpp"
-#include "runtime/vm_version.hpp"
 
 class VM_Version : public Abstract_VM_Version {
  public:
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os/aix/os_aix.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/aix/os_aix.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os/aix/os_aix.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/aix/os_aix.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -2300,7 +2300,7 @@ void os::pd_commit_memory_or_exit(char* 
   pd_commit_memory_or_exit(addr, size, exec, mesg);
 }
 
-bool os::pd_uncommit_memory(char* addr, size_t size) {
+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
   assert(is_aligned_to(addr, os::vm_page_size()),
     "addr " PTR_FORMAT " not aligned to vm_page_size (" PTR_FORMAT ")",
     p2i(addr), os::vm_page_size());
@@ -2374,7 +2374,7 @@ char *os::scan_pages(char *start, char* 
 
 // Reserves and attaches a shared memory segment.
 // Will assert if a wish address is given and could not be obtained.
-char* os::pd_reserve_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {
+char* os::pd_reserve_memory(size_t bytes, char* requested_addr, size_t alignment_hint, bool executable) {
 
   // All other Unices do a mmap(MAP_FIXED) if the addr is given,
   // thereby clobbering old mappings at that place. That is probably
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os/bsd/os_bsd.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/bsd/os_bsd.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os/bsd/os_bsd.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/bsd/os_bsd.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -229,6 +229,8 @@ static char cpu_arch[] = "i386";
 static char cpu_arch[] = "amd64";
 #elif defined(ARM)
 static char cpu_arch[] = "arm";
+#elif defined(AARCH64)
+static char cpu_arch[] = "aarch64";
 #elif defined(PPC32)
 static char cpu_arch[] = "ppc";
 #elif defined(SPARC)
@@ -2004,12 +2006,16 @@ static void warn_fail_commit_memory(char
 //       problem.
 bool os::pd_commit_memory(char* addr, size_t size, bool exec) {
   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
-#ifdef __OpenBSD__
+#if defined(__OpenBSD__)
   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
   Events::log(NULL, "Protecting memory [" INTPTR_FORMAT "," INTPTR_FORMAT "] with protection modes %x", p2i(addr), p2i(addr+size), prot);
   if (::mprotect(addr, size, prot) == 0) {
     return true;
   }
+#elif defined(__APPLE__)
+  if (::mprotect(addr, size, prot) == 0) {
+    return true;
+  }
 #else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,
                                      MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
@@ -2088,11 +2094,22 @@ char *os::scan_pages(char *start, char* 
 }
 
 
-bool os::pd_uncommit_memory(char* addr, size_t size) {
-#ifdef __OpenBSD__
+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
+#if defined(__OpenBSD__)
   // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
   Events::log(NULL, "Protecting memory [" INTPTR_FORMAT "," INTPTR_FORMAT "] with PROT_NONE", p2i(addr), p2i(addr+size));
   return ::mprotect(addr, size, PROT_NONE) == 0;
+#elif defined(__APPLE__)
+  if (exec) {
+    if (::madvise(addr, size, MADV_FREE) != 0) {
+      return false;
+    }
+    return ::mprotect(addr, size, PROT_NONE) == 0;
+  } else {
+    uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
+        MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
+    return res  != (uintptr_t) MAP_FAILED;
+  }
 #else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
@@ -2107,7 +2124,7 @@ bool os::pd_create_stack_guard_pages(cha
 // If this is a growable mapping, remove the guard pages entirely by
 // munmap()ping them.  If not, just call uncommit_memory().
 bool os::remove_stack_guard_pages(char* addr, size_t size) {
-  return os::uncommit_memory(addr, size);
+  return os::uncommit_memory(addr, size, !ExecMem);
 }
 
 // If 'fixed' is true, anon_mmap() will attempt to reserve anonymous memory
@@ -2116,11 +2133,17 @@ bool os::remove_stack_guard_pages(char* 
 // 'requested_addr' is only treated as a hint, the return value may or
 // may not start from the requested address. Unlike Bsd mmap(), this
 // function returns NULL to indicate failure.
-static char* anon_mmap(char* requested_addr, size_t bytes, bool fixed) {
+static char* anon_mmap(char* requested_addr, size_t bytes, bool fixed, bool executable) {
   char * addr;
   int flags;
 
   flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;
+#ifdef __APPLE__
+  if (executable) {
+    guarantee(!fixed, "MAP_JIT (for execute) is incompatible with MAP_FIXED");
+    flags |= MAP_JIT;
+  }
+#endif
   if (fixed) {
     assert((uintptr_t)requested_addr % os::Bsd::page_size() == 0, "unaligned address");
     flags |= MAP_FIXED;
@@ -2140,8 +2163,9 @@ static int anon_munmap(char * addr, size
 }
 
 char* os::pd_reserve_memory(size_t bytes, char* requested_addr,
-                            size_t alignment_hint) {
-  return anon_mmap(requested_addr, bytes, (requested_addr != NULL));
+                            size_t alignment_hint,
+                            bool executable) {
+  return anon_mmap(requested_addr, bytes, (requested_addr != NULL), executable);
 }
 
 bool os::pd_release_memory(char* addr, size_t size) {
@@ -2324,7 +2348,7 @@ char* os::pd_attempt_reserve_memory_at(s
 
   // Bsd mmap allows caller to pass an address as hint; give it a try first,
   // if kernel honors the hint then we can return immediately.
-  char * addr = anon_mmap(requested_addr, bytes, false);
+  char * addr = anon_mmap(requested_addr, bytes, false/*fixed*/, false/*executable*/);
   if (addr == requested_addr) {
     return requested_addr;
   }
@@ -3312,16 +3336,6 @@ void os::init(void) {
   Bsd::clock_init();
   initial_time_count = javaTimeNanos();
 
-#ifdef __APPLE__
-  // XXXDARWIN
-  // Work around the unaligned VM callbacks in hotspot's
-  // sharedRuntime. The callbacks don't use SSE2 instructions, and work on
-  // Linux, Solaris, and FreeBSD. On Mac OS X, dyld (rightly so) enforces
-  // alignment when doing symbol lookup. To work around this, we force early
-  // binding of all symbols now, thus binding when alignment is known-good.
-  _dyld_bind_fully_image_containing_address((const void *) &os::init);
-#endif
-
   os::Posix::init();
 }
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os/bsd/os_perf_bsd.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/bsd/os_perf_bsd.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os/bsd/os_perf_bsd.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/bsd/os_perf_bsd.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -27,7 +27,7 @@
 #include "runtime/os.hpp"
 #include "runtime/os_perf.hpp"
 #include "utilities/globalDefinitions.hpp"
-#include "vm_version_ext_x86.hpp"
+#include CPU_HEADER(vm_version_ext)
 
 #ifdef __APPLE__
   #import <libproc.h>
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os/linux/os_linux.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/linux/os_linux.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os/linux/os_linux.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/linux/os_linux.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -3286,7 +3286,7 @@ unsigned long* os::Linux::_numa_all_node
 struct bitmask* os::Linux::_numa_all_nodes_ptr;
 struct bitmask* os::Linux::_numa_nodes_ptr;
 
-bool os::pd_uncommit_memory(char* addr, size_t size) {
+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {
   uintptr_t res = (uintptr_t) ::mmap(addr, size, PROT_NONE,
                                      MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0);
   return res  != (uintptr_t) MAP_FAILED;
@@ -3471,7 +3471,7 @@ bool os::remove_stack_guard_pages(char* 
     return ::munmap(addr, size) == 0;
   }
 
-  return os::uncommit_memory(addr, size);
+  return os::uncommit_memory(addr, size, !ExecMem);
 }
 
 // If 'fixed' is true, anon_mmap() will attempt to reserve anonymous memory
@@ -3546,7 +3546,8 @@ static int anon_munmap(char * addr, size
 }
 
 char* os::pd_reserve_memory(size_t bytes, char* requested_addr,
-                            size_t alignment_hint) {
+                            size_t alignment_hint,
+                            bool executable) {
   return anon_mmap(requested_addr, bytes, (requested_addr != NULL));
 }
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os/solaris/os_solaris.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/solaris/os_solaris.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os/solaris/os_solaris.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/solaris/os_solaris.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -2336,7 +2336,7 @@ bool os::pd_create_stack_guard_pages(cha
 }
 
 bool os::remove_stack_guard_pages(char* addr, size_t size) {
-  return os::uncommit_memory(addr, size);
+  return os::uncommit_memory(addr, size, !ExecMem);
 }
 
 // Change the page size in a given range.
@@ -2530,7 +2530,7 @@ char *os::scan_pages(char *start, char* 
   return end;
 }
 
-bool os::pd_uncommit_memory(char* addr, size_t bytes) {
+bool os::pd_uncommit_memory(char* addr, size_t bytes, bool exec) {
   size_t size = bytes;
   // Map uncommitted pages PROT_NONE so we fail early if we touch an
   // uncommitted page. Otherwise, the read/write might succeed if we
@@ -2572,7 +2572,7 @@ char* os::Solaris::anon_mmap(char* reque
 }
 
 char* os::pd_reserve_memory(size_t bytes, char* requested_addr,
-                            size_t alignment_hint) {
+                            size_t alignment_hint, bool executable) {
   char* addr = Solaris::anon_mmap(requested_addr, bytes, alignment_hint,
                                   (requested_addr != NULL));
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os/windows/os_perf_windows.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/windows/os_perf_windows.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os/windows/os_perf_windows.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/windows/os_perf_windows.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -32,7 +32,7 @@
 #include "runtime/os.hpp"
 #include "utilities/globalDefinitions.hpp"
 #include "utilities/macros.hpp"
-#include "vm_version_ext_x86.hpp"
+#include CPU_HEADER(vm_version_ext)
 #include <math.h>
 #include <psapi.h>
 #include <TlHelp32.h>
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os/windows/os_windows.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/windows/os_windows.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os/windows/os_windows.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os/windows/os_windows.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -3105,7 +3105,7 @@ char* os::reserve_memory_aligned(size_t 
   return aligned_base;
 }
 
-char* os::pd_reserve_memory(size_t bytes, char* addr, size_t alignment_hint) {
+char* os::pd_reserve_memory(size_t bytes, char* addr, size_t alignment_hint, bool executable) {
   assert((size_t)addr % os::vm_allocation_granularity() == 0,
          "reserve alignment");
   assert(bytes % os::vm_page_size() == 0, "reserve page size");
@@ -3311,7 +3311,7 @@ void os::pd_commit_memory_or_exit(char* 
   pd_commit_memory_or_exit(addr, size, exec, mesg);
 }
 
-bool os::pd_uncommit_memory(char* addr, size_t bytes) {
+bool os::pd_uncommit_memory(char* addr, size_t bytes, bool exec) {
   if (bytes == 0) {
     // Don't bother the OS with noops.
     return true;
@@ -3330,7 +3330,7 @@ bool os::pd_create_stack_guard_pages(cha
 }
 
 bool os::remove_stack_guard_pages(char* addr, size_t size) {
-  return os::uncommit_memory(addr, size);
+  return os::uncommit_memory(addr, size, !ExecMem);
 }
 
 static bool protect_pages_individually(char* addr, size_t bytes, unsigned int p, DWORD *old_status) {
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/aix_ppc/os_aix_ppc.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -36,4 +36,10 @@
 static bool platform_print_native_stack(outputStream* st, void* context,
                                         char *buf, int buf_size);
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_AIX_PPC_VM_OS_AIX_PPC_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/atomic_bsd_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_VM_ATOMIC_BSD_AARCH64_HPP
+#define OS_CPU_BSD_AARCH64_VM_ATOMIC_BSD_AARCH64_HPP
+
+// Implementation of class atomic
+
+#define FULL_MEM_BARRIER  __sync_synchronize()
+#define READ_MEM_BARRIER  __atomic_thread_fence(__ATOMIC_ACQUIRE);
+#define WRITE_MEM_BARRIER __atomic_thread_fence(__ATOMIC_RELEASE);
+
+template<size_t byte_size>
+struct Atomic::PlatformAdd
+  : Atomic::AddAndFetch<Atomic::PlatformAdd<byte_size> >
+{
+  template<typename I, typename D>
+  D add_and_fetch(I add_value, D volatile* dest, atomic_memory_order order) const {
+    D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);
+    FULL_MEM_BARRIER;
+    return res;
+  }
+};
+
+template<size_t byte_size>
+template<typename T>
+inline T Atomic::PlatformXchg<byte_size>::operator()(T exchange_value,
+                                                     T volatile* dest,
+                                                     atomic_memory_order order) const {
+  STATIC_ASSERT(byte_size == sizeof(T));
+  T res = __sync_lock_test_and_set(dest, exchange_value);
+  FULL_MEM_BARRIER;
+  return res;
+}
+
+template<size_t byte_size>
+template<typename T>
+inline T Atomic::PlatformCmpxchg<byte_size>::operator()(T exchange_value,
+                                                        T volatile* dest,
+                                                        T compare_value,
+                                                        atomic_memory_order order) const {
+  STATIC_ASSERT(byte_size == sizeof(T));
+  if (order == memory_order_relaxed) {
+    T value = compare_value;
+    __atomic_compare_exchange(dest, &value, &exchange_value, /*weak*/false,
+                              __ATOMIC_RELAXED, __ATOMIC_RELAXED);
+    return value;
+  } else {
+    return __sync_val_compare_and_swap(dest, compare_value, exchange_value);
+  }
+}
+
+#endif // OS_CPU_LINUX_AARCH64_VM_ATOMIC_LINUX_AARCH64_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/bytes_bsd_aarch64.inline.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_VM_BYTES_BSD_AARCH64_INLINE_HPP
+#define OS_CPU_BSD_AARCH64_VM_BYTES_BSD_AARCH64_INLINE_HPP
+
+#ifdef __APPLE__
+#include <libkern/OSByteOrder.h>
+#endif
+
+#if defined(__APPLE__)
+#  define bswap_16(x) OSSwapInt16(x)
+#  define bswap_32(x) OSSwapInt32(x)
+#  define bswap_64(x) OSSwapInt64(x)
+#else
+#  error "Unimplemented"
+#endif
+
+// Efficient swapping of data bytes from Java byte
+// ordering to native byte ordering and vice versa.
+inline u2   Bytes::swap_u2(u2 x) {
+  return bswap_16(x);
+}
+
+inline u4   Bytes::swap_u4(u4 x) {
+  return bswap_32(x);
+}
+
+inline u8 Bytes::swap_u8(u8 x) {
+  return bswap_64(x);
+}
+
+#endif // OS_CPU_BSD_AARCH64_VM_BYTES_BSD_AARCH64_INLINE_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.inline.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,188 @@
+/*
+ * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_VM_COPY_BSD_AARCH64_INLINE_HPP
+#define OS_CPU_BSD_AARCH64_VM_COPY_BSD_AARCH64_INLINE_HPP
+
+#define COPY_SMALL(from, to, count)                                     \
+{                                                                       \
+        long tmp0, tmp1, tmp2, tmp3;                                    \
+        long tmp4, tmp5, tmp6, tmp7;                                    \
+  __asm volatile(                                                       \
+"       adr     %[t0], 0f;\n"                                           \
+"       add     %[t0], %[t0], %[cnt], lsl #5;\n"                        \
+"       br      %[t0];\n"                                               \
+"       .align  5;\n"                                                   \
+"0:"                                                                    \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldr     %[t0], [%[s], #0];\n"                                   \
+"       str     %[t0], [%[d], #0];\n"                                   \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldp     %[t0], %[t1], [%[s], #0];\n"                            \
+"       stp     %[t0], %[t1], [%[d], #0];\n"                            \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldp     %[t0], %[t1], [%[s], #0];\n"                            \
+"       ldr     %[t2], [%[s], #16];\n"                                  \
+"       stp     %[t0], %[t1], [%[d], #0];\n"                            \
+"       str     %[t2], [%[d], #16];\n"                                  \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldp     %[t0], %[t1], [%[s], #0];\n"                            \
+"       ldp     %[t2], %[t3], [%[s], #16];\n"                           \
+"       stp     %[t0], %[t1], [%[d], #0];\n"                            \
+"       stp     %[t2], %[t3], [%[d], #16];\n"                           \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldp     %[t0], %[t1], [%[s], #0];\n"                            \
+"       ldp     %[t2], %[t3], [%[s], #16];\n"                           \
+"       ldr     %[t4], [%[s], #32];\n"                                  \
+"       stp     %[t0], %[t1], [%[d], #0];\n"                            \
+"       stp     %[t2], %[t3], [%[d], #16];\n"                           \
+"       str     %[t4], [%[d], #32];\n"                                  \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldp     %[t0], %[t1], [%[s], #0];\n"                            \
+"       ldp     %[t2], %[t3], [%[s], #16];\n"                           \
+"       ldp     %[t4], %[t5], [%[s], #32];\n"                           \
+"2:"                                                                    \
+"       stp     %[t0], %[t1], [%[d], #0];\n"                            \
+"       stp     %[t2], %[t3], [%[d], #16];\n"                           \
+"       stp     %[t4], %[t5], [%[d], #32];\n"                           \
+"       b       1f;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldr     %[t6], [%[s], #0];\n"                                   \
+"       ldp     %[t0], %[t1], [%[s], #8];\n"                            \
+"       ldp     %[t2], %[t3], [%[s], #24];\n"                           \
+"       ldp     %[t4], %[t5], [%[s], #40];\n"                           \
+"       str     %[t6], [%[d]], #8;\n"                                   \
+"       b       2b;\n"                                                  \
+"       .align  5;\n"                                                   \
+"       ldp     %[t0], %[t1], [%[s], #0];\n"                            \
+"       ldp     %[t2], %[t3], [%[s], #16];\n"                           \
+"       ldp     %[t4], %[t5], [%[s], #32];\n"                           \
+"       ldp     %[t6], %[t7], [%[s], #48];\n"                           \
+"       stp     %[t0], %[t1], [%[d], #0];\n"                            \
+"       stp     %[t2], %[t3], [%[d], #16];\n"                           \
+"       stp     %[t4], %[t5], [%[d], #32];\n"                           \
+"       stp     %[t6], %[t7], [%[d], #48];\n"                           \
+"1:"                                                                    \
+                                                                        \
+  : [s]"+r"(from), [d]"+r"(to), [cnt]"+r"(count),                       \
+    [t0]"=&r"(tmp0), [t1]"=&r"(tmp1), [t2]"=&r"(tmp2), [t3]"=&r"(tmp3), \
+    [t4]"=&r"(tmp4), [t5]"=&r"(tmp5), [t6]"=&r"(tmp6), [t7]"=&r"(tmp7)  \
+  :                                                                     \
+  : "memory", "cc");                                                    \
+}
+
+static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {
+  __asm volatile( "prfm pldl1strm, [%[s], #0];" :: [s]"r"(from) : "memory");
+  if (__builtin_expect(count <= 8, 1)) {
+    COPY_SMALL(from, to, count);
+    return;
+  }
+  _Copy_conjoint_words(from, to, count);
+}
+
+static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {
+  if (__builtin_constant_p(count)) {
+    memcpy(to, from, count * sizeof(HeapWord));
+    return;
+  }
+  __asm volatile( "prfm pldl1strm, [%[s], #0];" :: [s]"r"(from) : "memory");
+  if (__builtin_expect(count <= 8, 1)) {
+    COPY_SMALL(from, to, count);
+    return;
+  }
+  _Copy_disjoint_words(from, to, count);
+}
+
+static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {
+  __asm volatile( "prfm pldl1strm, [%[s], #0];" :: [s]"r"(from) : "memory");
+  if (__builtin_expect(count <= 8, 1)) {
+    COPY_SMALL(from, to, count);
+    return;
+  }
+  _Copy_disjoint_words(from, to, count);
+}
+
+static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {
+  pd_conjoint_words(from, to, count);
+}
+
+static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {
+  pd_disjoint_words(from, to, count);
+}
+
+static void pd_conjoint_bytes(const void* from, void* to, size_t count) {
+  (void)memmove(to, from, count);
+}
+
+static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {
+  pd_conjoint_bytes(from, to, count);
+}
+
+static void pd_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {
+  _Copy_conjoint_jshorts_atomic(from, to, count);
+}
+
+static void pd_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {
+  _Copy_conjoint_jints_atomic(from, to, count);
+}
+
+static void pd_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {
+  _Copy_conjoint_jlongs_atomic(from, to, count);
+}
+
+static void pd_conjoint_oops_atomic(const oop* from, oop* to, size_t count) {
+  assert(BytesPerLong == BytesPerOop, "jlongs and oops must be the same size");
+  _Copy_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);
+}
+
+static void pd_arrayof_conjoint_bytes(const HeapWord* from, HeapWord* to, size_t count) {
+  _Copy_arrayof_conjoint_bytes(from, to, count);
+}
+
+static void pd_arrayof_conjoint_jshorts(const HeapWord* from, HeapWord* to, size_t count) {
+  _Copy_arrayof_conjoint_jshorts(from, to, count);
+}
+
+static void pd_arrayof_conjoint_jints(const HeapWord* from, HeapWord* to, size_t count) {
+   _Copy_arrayof_conjoint_jints(from, to, count);
+}
+
+static void pd_arrayof_conjoint_jlongs(const HeapWord* from, HeapWord* to, size_t count) {
+  _Copy_arrayof_conjoint_jlongs(from, to, count);
+}
+
+static void pd_arrayof_conjoint_oops(const HeapWord* from, HeapWord* to, size_t count) {
+  assert(!UseCompressedOops, "foo!");
+  assert(BytesPerLong == BytesPerOop, "jlongs and oops must be the same size");
+  _Copy_arrayof_conjoint_jlongs(from, to, count);
+}
+
+#endif // OS_CPU_BSD_AARCH64_VM_COPY_BSD_AARCH64_INLINE_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/copy_bsd_aarch64.s	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,239 @@
+/*
+ * Copyright (c) 2016, Linaro Ltd. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#define CFUNC(x) _##x
+
+        .global CFUNC(_Copy_conjoint_words)
+        .global CFUNC(_Copy_disjoint_words)
+
+s       .req    x0
+d       .req    x1
+count   .req    x2
+t0      .req    x3
+t1      .req    x4
+t2      .req    x5
+t3      .req    x6
+t4      .req    x7
+t5      .req    x8
+t6      .req    x9
+t7      .req    x10
+
+        .align  6
+CFUNC(_Copy_disjoint_words):
+        // Ensure 2 word aligned
+        tbz     s, #3, fwd_copy_aligned
+        ldr     t0, [s], #8
+        str     t0, [d], #8
+        sub     count, count, #1
+
+fwd_copy_aligned:
+        // Bias s & d so we only pre index on the last copy
+        sub     s, s, #16
+        sub     d, d, #16
+
+        ldp     t0, t1, [s, #16]
+        ldp     t2, t3, [s, #32]
+        ldp     t4, t5, [s, #48]
+        ldp     t6, t7, [s, #64]!
+
+        subs    count, count, #16
+        blo     fwd_copy_drain
+
+fwd_copy_again:
+        prfm    pldl1keep, [s, #256]
+        stp     t0, t1, [d, #16]
+        ldp     t0, t1, [s, #16]
+        stp     t2, t3, [d, #32]
+        ldp     t2, t3, [s, #32]
+        stp     t4, t5, [d, #48]
+        ldp     t4, t5, [s, #48]
+        stp     t6, t7, [d, #64]!
+        ldp     t6, t7, [s, #64]!
+        subs    count, count, #8
+        bhs     fwd_copy_again
+
+fwd_copy_drain:
+        stp     t0, t1, [d, #16]
+        stp     t2, t3, [d, #32]
+        stp     t4, t5, [d, #48]
+        stp     t6, t7, [d, #64]!
+
+        // count is now -8..-1 for 0..7 words to copy
+        adr     t0, 0f
+        add     t0, t0, count, lsl #5
+        br      t0
+
+        .align  5
+        ret                             // -8 == 0 words
+        .align  5
+        ldr     t0, [s, #16]            // -7 == 1 word
+        str     t0, [d, #16]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #16]        // -6 = 2 words
+        stp     t0, t1, [d, #16]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #16]        // -5 = 3 words
+        ldr     t2, [s, #32]
+        stp     t0, t1, [d, #16]
+        str     t2, [d, #32]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #16]        // -4 = 4 words
+        ldp     t2, t3, [s, #32]
+        stp     t0, t1, [d, #16]
+        stp     t2, t3, [d, #32]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #16]        // -3 = 5 words
+        ldp     t2, t3, [s, #32]
+        ldr     t4, [s, #48]
+        stp     t0, t1, [d, #16]
+        stp     t2, t3, [d, #32]
+        str     t4, [d, #48]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #16]        // -2 = 6 words
+        ldp     t2, t3, [s, #32]
+        ldp     t4, t5, [s, #48]
+        stp     t0, t1, [d, #16]
+        stp     t2, t3, [d, #32]
+        stp     t4, t5, [d, #48]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #16]        // -1 = 7 words
+        ldp     t2, t3, [s, #32]
+        ldp     t4, t5, [s, #48]
+        ldr     t6, [s, #64]
+        stp     t0, t1, [d, #16]
+        stp     t2, t3, [d, #32]
+        stp     t4, t5, [d, #48]
+        str     t6, [d, #64]
+        // Is always aligned here, code for 7 words is one instruction
+        // too large so it just falls through.
+        .align  5
+0:
+        ret
+
+        .align  6
+CFUNC(_Copy_conjoint_words):
+        sub     t0, d, s
+        cmp     t0, count, lsl #3
+        bhs     CFUNC(_Copy_disjoint_words)
+
+        add     s, s, count, lsl #3
+        add     d, d, count, lsl #3
+
+        // Ensure 2 word aligned
+        tbz     s, #3, bwd_copy_aligned
+        ldr     t0, [s, #-8]!
+        str     t0, [d, #-8]!
+        sub     count, count, #1
+
+bwd_copy_aligned:
+        ldp     t0, t1, [s, #-16]
+        ldp     t2, t3, [s, #-32]
+        ldp     t4, t5, [s, #-48]
+        ldp     t6, t7, [s, #-64]!
+
+        subs    count, count, #16
+        blo     bwd_copy_drain
+
+bwd_copy_again:
+        prfum   pldl1keep, [s, #-256]
+        stp     t0, t1, [d, #-16]
+        ldp     t0, t1, [s, #-16]
+        stp     t2, t3, [d, #-32]
+        ldp     t2, t3, [s, #-32]
+        stp     t4, t5, [d, #-48]
+        ldp     t4, t5, [s, #-48]
+        stp     t6, t7, [d, #-64]!
+        ldp     t6, t7, [s, #-64]!
+        subs    count, count, #8
+        bhs     bwd_copy_again
+
+bwd_copy_drain:
+        stp     t0, t1, [d, #-16]
+        stp     t2, t3, [d, #-32]
+        stp     t4, t5, [d, #-48]
+        stp     t6, t7, [d, #-64]!
+
+        // count is now -8..-1 for 0..7 words to copy
+        adr     t0, 0f
+        add     t0, t0, count, lsl #5
+        br      t0
+
+        .align  5
+        ret                             // -8 == 0 words
+        .align  5
+        ldr     t0, [s, #-8]            // -7 == 1 word
+        str     t0, [d, #-8]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #-16]       // -6 = 2 words
+        stp     t0, t1, [d, #-16]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #-16]       // -5 = 3 words
+        ldr     t2, [s, #-24]
+        stp     t0, t1, [d, #-16]
+        str     t2, [d, #-24]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #-16]       // -4 = 4 words
+        ldp     t2, t3, [s, #-32]
+        stp     t0, t1, [d, #-16]
+        stp     t2, t3, [d, #-32]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #-16]       // -3 = 5 words
+        ldp     t2, t3, [s, #-32]
+        ldr     t4, [s, #-40]
+        stp     t0, t1, [d, #-16]
+        stp     t2, t3, [d, #-32]
+        str     t4, [d, #-40]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #-16]       // -2 = 6 words
+        ldp     t2, t3, [s, #-32]
+        ldp     t4, t5, [s, #-48]
+        stp     t0, t1, [d, #-16]
+        stp     t2, t3, [d, #-32]
+        stp     t4, t5, [d, #-48]
+        ret
+        .align  5
+        ldp     t0, t1, [s, #-16]       // -1 = 7 words
+        ldp     t2, t3, [s, #-32]
+        ldp     t4, t5, [s, #-48]
+        ldr     t6, [s, #-56]
+        stp     t0, t1, [d, #-16]
+        stp     t2, t3, [d, #-32]
+        stp     t4, t5, [d, #-48]
+        str     t6, [d, #-56]
+        // Is always aligned here, code for 7 words is one instruction
+        // too large so it just falls through.
+        .align  5
+0:
+        ret
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/globals_bsd_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_VM_GLOBALS_BSD_AARCH64_HPP
+#define OS_CPU_BSD_AARCH64_VM_GLOBALS_BSD_AARCH64_HPP
+
+
+// Sets the default values for platform dependent flags used by the runtime system.
+// (see globals.hpp)
+
+define_pd_global(bool, DontYieldALot,            false);
+define_pd_global(intx, ThreadStackSize,          2048); // 0 => use system default
+define_pd_global(intx, VMThreadStackSize,        2048);
+
+define_pd_global(intx, CompilerThreadStackSize,  2048);
+
+define_pd_global(uintx,JVMInvokeMethodSlack,     8192);
+
+// Used on 64 bit platforms for UseCompressedOops base address
+define_pd_global(uintx,HeapBaseMinAddress,       2*G);
+
+#endif // OS_CPU_BSD_AARCH64_VM_GLOBALS_BSD_AARCH64_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/orderAccess_bsd_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_VM_ORDERACCESS_BSD_AARCH64_HPP
+#define OS_CPU_BSD_AARCH64_VM_ORDERACCESS_BSD_AARCH64_HPP
+
+// Included in orderAccess.hpp header file.
+
+// Implementation of class OrderAccess.
+
+inline void OrderAccess::loadload()   { acquire(); }
+inline void OrderAccess::storestore() { release(); }
+inline void OrderAccess::loadstore()  { acquire(); }
+inline void OrderAccess::storeload()  { fence(); }
+
+#define FULL_MEM_BARRIER  __sync_synchronize()
+#define READ_MEM_BARRIER  __atomic_thread_fence(__ATOMIC_ACQUIRE);
+#define WRITE_MEM_BARRIER __atomic_thread_fence(__ATOMIC_RELEASE);
+
+inline void OrderAccess::acquire() {
+  READ_MEM_BARRIER;
+}
+
+inline void OrderAccess::release() {
+  WRITE_MEM_BARRIER;
+}
+
+inline void OrderAccess::fence() {
+  FULL_MEM_BARRIER;
+}
+
+#endif // OS_CPU_BSD_AARCH64_VM_ORDERACCESS_BSD_AARCH64_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,804 @@
+/*
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+// no precompiled headers
+#include "jvm.h"
+#include "asm/macroAssembler.hpp"
+#include "classfile/classLoader.hpp"
+#include "classfile/systemDictionary.hpp"
+#include "classfile/vmSymbols.hpp"
+#include "code/codeCache.hpp"
+#include "code/icBuffer.hpp"
+#include "code/vtableStubs.hpp"
+#include "interpreter/interpreter.hpp"
+#include "logging/log.hpp"
+#include "memory/allocation.inline.hpp"
+#include "os_share_bsd.hpp"
+#include "prims/jniFastGetField.hpp"
+#include "prims/jvm_misc.hpp"
+#include "runtime/arguments.hpp"
+#include "runtime/frame.inline.hpp"
+#include "runtime/interfaceSupport.inline.hpp"
+#include "runtime/java.hpp"
+#include "runtime/javaCalls.hpp"
+#include "runtime/mutexLocker.hpp"
+#include "runtime/osThread.hpp"
+#include "runtime/safepointMechanism.hpp"
+#include "runtime/sharedRuntime.hpp"
+#include "runtime/stubRoutines.hpp"
+#include "runtime/thread.inline.hpp"
+#include "runtime/timer.hpp"
+#include "utilities/align.hpp"
+#include "utilities/events.hpp"
+#include "utilities/vmError.hpp"
+
+// put OS-includes here
+# include <sys/types.h>
+# include <sys/mman.h>
+# include <pthread.h>
+# include <signal.h>
+# include <errno.h>
+# include <dlfcn.h>
+# include <stdlib.h>
+# include <stdio.h>
+# include <unistd.h>
+# include <sys/resource.h>
+# include <pthread.h>
+# include <sys/stat.h>
+# include <sys/time.h>
+# include <sys/utsname.h>
+# include <sys/socket.h>
+# include <sys/wait.h>
+# include <pwd.h>
+# include <poll.h>
+#ifndef __OpenBSD__
+# include <ucontext.h>
+#endif
+
+#if !defined(__APPLE__) && !defined(__NetBSD__)
+# include <pthread_np.h>
+#endif
+
+// needed by current_stack_region() workaround for Mavericks
+#if defined(__APPLE__)
+# include <errno.h>
+# include <sys/types.h>
+# include <sys/sysctl.h>
+# define DEFAULT_MAIN_THREAD_STACK_PAGES 2048
+# define OS_X_10_9_0_KERNEL_MAJOR_VERSION 13
+#endif
+
+#define SPELL_REG_SP "sp"
+#define SPELL_REG_FP "fp"
+
+#ifdef __APPLE__
+# if __DARWIN_UNIX03 && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
+  // 10.5 UNIX03 member name prefixes
+  #define DU3_PREFIX(s, m) __ ## s.__ ## m
+# else
+  #define DU3_PREFIX(s, m) s ## . ## m
+# endif
+#endif
+
+#define context_x    uc_mcontext->DU3_PREFIX(ss,x)
+#define context_fp   uc_mcontext->DU3_PREFIX(ss,fp)
+#define context_lr   uc_mcontext->DU3_PREFIX(ss,lr)
+#define context_sp   uc_mcontext->DU3_PREFIX(ss,sp)
+#define context_pc   uc_mcontext->DU3_PREFIX(ss,pc)
+#define context_cpsr uc_mcontext->DU3_PREFIX(ss,cpsr)
+
+address os::current_stack_pointer() {
+#if defined(__clang__) || defined(__llvm__)
+  void *sp;
+  __asm__("mov %0, " SPELL_REG_SP : "=r"(sp));
+  return (address) sp;
+#else
+  register void *sp __asm__ (SPELL_REG_SP);                                                                                                                  │
+  return (address) sp;                                                                                                                                       │
+#endif
+}
+
+char* os::non_memory_address_word() {
+  // Must never look like an address returned by reserve_memory,
+  // even in its subfields (as defined by the CPU immediate fields,
+  // if the CPU splits constants across multiple instructions).
+
+  // the return value used in computation of Universe::non_oop_word(), which
+  // is loaded by cpu/aarch64 by MacroAssembler::movptr(Register, uintptr_t)
+  return (char*) 0xffffffffffff;
+}
+
+address os::Bsd::ucontext_get_pc(const ucontext_t * uc) {
+  return (address)uc->context_pc;
+}
+
+void os::Bsd::ucontext_set_pc(ucontext_t * uc, address pc) {
+  uc->context_pc = (intptr_t)pc ;
+}
+
+intptr_t* os::Bsd::ucontext_get_sp(const ucontext_t * uc) {
+  return (intptr_t*)uc->context_sp;
+}
+
+intptr_t* os::Bsd::ucontext_get_fp(const ucontext_t * uc) {
+  return (intptr_t*)uc->context_fp;
+}
+
+ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
+                    intptr_t** ret_sp, intptr_t** ret_fp) {
+
+  ExtendedPC  epc;
+  const ucontext_t* uc = (const ucontext_t*)ucVoid;
+
+  if (uc != NULL) {
+    epc = ExtendedPC(os::Bsd::ucontext_get_pc(uc));
+    if (ret_sp) *ret_sp = os::Bsd::ucontext_get_sp(uc);
+    if (ret_fp) *ret_fp = os::Bsd::ucontext_get_fp(uc);
+  } else {
+    epc = ExtendedPC(NULL);
+    if (ret_sp) *ret_sp = (intptr_t *)NULL;
+    if (ret_fp) *ret_fp = (intptr_t *)NULL;
+  }
+
+  return epc;
+}
+
+frame os::fetch_frame_from_context(const void* ucVoid) {
+  intptr_t* sp;
+  intptr_t* fp;
+  ExtendedPC epc = fetch_frame_from_context(ucVoid, &sp, &fp);
+  return frame(sp, fp, epc.pc());
+}
+
+bool os::Bsd::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
+  address pc = (address) os::Bsd::ucontext_get_pc(uc);
+  if (Interpreter::contains(pc)) {
+    // interpreter performs stack banging after the fixed frame header has
+    // been generated while the compilers perform it before. To maintain
+    // semantic consistency between interpreted and compiled frames, the
+    // method returns the Java sender of the current frame.
+    *fr = os::fetch_frame_from_context(uc);
+    if (!fr->is_first_java_frame()) {
+      assert(fr->safe_for_sender(thread), "Safety check");
+      *fr = fr->java_sender();
+    }
+  } else {
+    // more complex code with compiled code
+    assert(!Interpreter::contains(pc), "Interpreted methods should have been handled above");
+    CodeBlob* cb = CodeCache::find_blob(pc);
+    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {
+      // Not sure where the pc points to, fallback to default
+      // stack overflow handling
+      return false;
+    } else {
+      // In compiled code, the stack banging is performed before LR
+      // has been saved in the frame.  LR is live, and SP and FP
+      // belong to the caller.
+      intptr_t* fp = os::Bsd::ucontext_get_fp(uc);
+      intptr_t* sp = os::Bsd::ucontext_get_sp(uc);
+      address pc = (address)(uc->context_lr
+                         - NativeInstruction::instruction_size);
+      *fr = frame(sp, fp, pc);
+      if (!fr->is_java_frame()) {
+        assert(fr->safe_for_sender(thread), "Safety check");
+        assert(!fr->is_first_frame(), "Safety check");
+        *fr = fr->java_sender();
+      }
+    }
+  }
+  assert(fr->is_java_frame(), "Safety check");
+  return true;
+}
+
+// By default, gcc always saves frame pointer rfp on this stack. This
+// may get turned off by -fomit-frame-pointer.
+frame os::get_sender_for_C_frame(frame* fr) {
+  return frame(fr->link(), fr->link(), fr->sender_pc());
+}
+
+NOINLINE frame os::current_frame() {
+  intptr_t *fp = *(intptr_t **)__builtin_frame_address(0);
+  frame myframe((intptr_t*)os::current_stack_pointer(),
+                (intptr_t*)fp,
+                CAST_FROM_FN_PTR(address, os::current_frame));
+  if (os::is_first_C_frame(&myframe)) {
+    // stack is not walkable
+    return frame();
+  } else {
+    return os::get_sender_for_C_frame(&myframe);
+  }
+}
+
+// Utility functions
+extern "C" JNIEXPORT int
+JVM_handle_bsd_signal(int sig,
+                        siginfo_t* info,
+                        void* ucVoid,
+                        int abort_if_unrecognized) {
+  ucontext_t* uc = (ucontext_t*) ucVoid;
+
+  Thread* t = Thread::current_or_null_safe();
+
+  // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away
+  // (no destructors can be run)
+  os::ThreadCrashProtection::check_crash_protection(sig, t);
+
+  SignalHandlerMark shm(t);
+
+  // Note: it's not uncommon that JNI code uses signal/sigset to install
+  // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
+  // or have a SIGILL handler when detecting CPU type). When that happens,
+  // JVM_handle_bsd_signal() might be invoked with junk info/ucVoid. To
+  // avoid unnecessary crash when libjsig is not preloaded, try handle signals
+  // that do not require siginfo/ucontext first.
+
+  if (sig == SIGPIPE || sig == SIGXFSZ) {
+    // allow chained handler to go first
+    if (os::Bsd::chained_handler(sig, info, ucVoid)) {
+      return true;
+    } else {
+      // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
+      return true;
+    }
+  }
+
+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT
+  if ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison) {
+    if (handle_assert_poison_fault(ucVoid, info->si_addr)) {
+      return 1;
+    }
+  }
+#endif
+
+  JavaThread* thread = NULL;
+  VMThread* vmthread = NULL;
+  if (os::Bsd::signal_handlers_are_installed) {
+    if (t != NULL ){
+      if(t->is_Java_thread()) {
+        thread = (JavaThread*)t;
+      }
+      else if(t->is_VM_thread()){
+        vmthread = (VMThread *)t;
+      }
+    }
+  }
+/*
+  NOTE: does not seem to work on bsd.
+  if (info == NULL || info->si_code <= 0 || info->si_code == SI_NOINFO) {
+    // can't decode this kind of signal
+    info = NULL;
+  } else {
+    assert(sig == info->si_signo, "bad siginfo");
+  }
+*/
+  // decide if this trap can be handled by a stub
+  address stub = NULL;
+
+  address pc          = NULL;
+
+  //%note os_trap_1
+  if (info != NULL && uc != NULL && thread != NULL) {
+    pc = (address) os::Bsd::ucontext_get_pc(uc);
+
+    if (StubRoutines::is_safefetch_fault(pc)) {
+      os::Bsd::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
+      return 1;
+    }
+
+    // Handle ALL stack overflow variations here
+    if (sig == SIGSEGV || sig == SIGBUS) {
+      address addr = (address) info->si_addr;
+
+      // check if fault address is within thread stack
+      if (thread->on_local_stack(addr)) {
+        Thread::WXWriteFromExecSetter wx_write;
+        // stack overflow
+        if (thread->in_stack_yellow_reserved_zone(addr)) {
+          if (thread->thread_state() == _thread_in_Java) {
+            if (thread->in_stack_reserved_zone(addr)) {
+              frame fr;
+              if (os::Bsd::get_frame_at_stack_banging_point(thread, uc, &fr)) {
+                assert(fr.is_java_frame(), "Must be a Java frame");
+                frame activation =
+                  SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
+                if (activation.sp() != NULL) {
+                  thread->disable_stack_reserved_zone();
+                  if (activation.is_interpreted_frame()) {
+                    thread->set_reserved_stack_activation((address)(
+                      activation.fp() + frame::interpreter_frame_initial_sp_offset));
+                  } else {
+                    thread->set_reserved_stack_activation((address)activation.unextended_sp());
+                  }
+                  return 1;
+                }
+              }
+            }
+            // Throw a stack overflow exception.  Guard pages will be reenabled
+            // while unwinding the stack.
+            thread->disable_stack_yellow_reserved_zone();
+            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
+          } else {
+            // Thread was in the vm or native code.  Return and try to finish.
+            thread->disable_stack_yellow_reserved_zone();
+            return 1;
+          }
+        } else if (thread->in_stack_red_zone(addr)) {
+          // Fatal red zone violation.  Disable the guard pages and fall through
+          // to handle_unexpected_exception way down below.
+          thread->disable_stack_red_zone();
+          tty->print_raw_cr("An irrecoverable stack overflow has occurred.");
+        }
+      }
+    }
+
+    // We test if stub is already set (by the stack overflow code
+    // above) so it is not overwritten by the code that follows. This
+    // check is not required on other platforms, because on other
+    // platforms we check for SIGSEGV only or SIGBUS only, where here
+    // we have to check for both SIGSEGV and SIGBUS.
+    if (thread->thread_state() == _thread_in_Java && stub == NULL) {
+      // Java thread running in Java code => find exception handler if any
+      // a fault inside compiled code, the interpreter, or a stub
+      Thread::WXWriteFromExecSetter wx_write;
+
+      // Handle signal from NativeJump::patch_verified_entry().
+      if ((sig == SIGILL)
+          && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {
+        if (TraceTraps) {
+          tty->print_cr("trap: zombie_not_entrant");
+        }
+        stub = SharedRuntime::get_handle_wrong_method_stub();
+      } else if ((sig == SIGSEGV || sig == SIGBUS) && os::is_poll_address((address)info->si_addr)) {
+        stub = SharedRuntime::get_poll_stub(pc);
+#if defined(__APPLE__)
+      // 32-bit Darwin reports a SIGBUS for nearly all memory access exceptions.
+      // 64-bit Darwin may also use a SIGBUS (seen with compressed oops).
+      // Catching SIGBUS here prevents the implicit SIGBUS NULL check below from
+      // being called, so only do so if the implicit NULL check is not necessary.
+      } else if (sig == SIGBUS && MacroAssembler::needs_explicit_null_check((intptr_t)info->si_addr)) {
+#else
+      } else if (sig == SIGBUS /* && info->si_code == BUS_OBJERR */) {
+#endif
+        // BugId 4454115: A read from a MappedByteBuffer can fault
+        // here if the underlying file has been truncated.
+        // Do not crash the VM in such a case.
+        CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
+        CompiledMethod* nm = (cb != NULL) ? cb->as_compiled_method_or_null() : NULL;
+        if ((nm != NULL && nm->has_unsafe_access())) {
+          address next_pc = pc + NativeCall::instruction_size;
+          stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
+        }
+      }
+      else
+
+      if (sig == SIGFPE  &&
+          (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV)) {
+        stub =
+          SharedRuntime::
+          continuation_for_implicit_exception(thread,
+                                              pc,
+                                              SharedRuntime::
+                                              IMPLICIT_DIVIDE_BY_ZERO);
+#ifdef __APPLE__
+      } else if (sig == SIGFPE && info->si_code == FPE_NOOP) {
+        Unimplemented();
+#endif /* __APPLE__ */
+
+      } else if ((sig == SIGSEGV || sig == SIGBUS) &&
+                 !MacroAssembler::needs_explicit_null_check((intptr_t)info->si_addr)) {
+          // Determination of interpreter/vtable stub/compiled code null exception
+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
+      }
+    } else if ((thread->thread_state() == _thread_in_vm ||
+                 thread->thread_state() == _thread_in_native) &&
+               sig == SIGBUS && /* info->si_code == BUS_OBJERR && */
+               thread->doing_unsafe_access()) {
+      address next_pc = pc + NativeCall::instruction_size;
+      stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
+    }
+
+    // jni_fast_Get<Primitive>Field can trap at certain pc's if a GC kicks in
+    // and the heap gets shrunk before the field access.
+    if ((sig == SIGSEGV) || (sig == SIGBUS)) {
+      address addr = JNI_FastGetField::find_slowcase_pc(pc);
+      if (addr != (address)-1) {
+        stub = addr;
+      }
+    }
+
+    // Check to see if we caught the safepoint code in the
+    // process of write protecting the memory serialization page.
+    // It write enables the page immediately after protecting it
+    // so we can just return to retry the write.
+    if ((sig == SIGSEGV) &&
+        os::is_memory_serialize_page(thread, (address) info->si_addr)) {
+      // Block current thread until the memory serialize page permission restored.
+      os::block_on_serialize_page_trap();
+      return true;
+    }
+  }
+
+  if (stub != NULL) {
+    // save all thread context in case we need to restore it
+    if (thread != NULL) thread->set_saved_exception_pc(pc);
+
+    os::Bsd::ucontext_set_pc(uc, stub);
+    return true;
+  }
+
+  // signal-chaining
+  if (os::Bsd::chained_handler(sig, info, ucVoid)) {
+     return true;
+  }
+
+  if (!abort_if_unrecognized) {
+    // caller wants another chance, so give it to him
+    return false;
+  }
+
+  if (pc == NULL && uc != NULL) {
+    pc = os::Bsd::ucontext_get_pc(uc);
+  }
+
+  // unmask current signal
+  sigset_t newset;
+  sigemptyset(&newset);
+  sigaddset(&newset, sig);
+  sigprocmask(SIG_UNBLOCK, &newset, NULL);
+
+  VMError::report_and_die(t, sig, pc, info, ucVoid);
+
+  ShouldNotReachHere();
+  return true; // Mute compiler
+}
+
+void os::Bsd::init_thread_fpu_state(void) {
+}
+
+bool os::is_allocatable(size_t bytes) {
+  return true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// thread stack
+
+// Minimum usable stack sizes required to get to user code. Space for
+// HotSpot guard pages is added later.
+size_t os::Posix::_compiler_thread_min_stack_allowed = 72 * K;
+size_t os::Posix::_java_thread_min_stack_allowed = 72 * K;
+size_t os::Posix::_vm_internal_thread_min_stack_allowed = 72 * K;
+
+// return default stack size for thr_type
+size_t os::Posix::default_stack_size(os::ThreadType thr_type) {
+  // default stack size (compiler thread needs larger stack)
+  size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);
+  return s;
+}
+
+
+// Java thread:
+//
+//   Low memory addresses
+//    +------------------------+
+//    |                        |\  Java thread created by VM does not have glibc
+//    |    glibc guard page    | - guard, attached Java thread usually has
+//    |                        |/  1 glibc guard page.
+// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
+//    |                        |\
+//    |  HotSpot Guard Pages   | - red, yellow and reserved pages
+//    |                        |/
+//    +------------------------+ JavaThread::stack_reserved_zone_base()
+//    |                        |\
+//    |      Normal Stack      | -
+//    |                        |/
+// P2 +------------------------+ Thread::stack_base()
+//
+// Non-Java thread:
+//
+//   Low memory addresses
+//    +------------------------+
+//    |                        |\
+//    |  glibc guard page      | - usually 1 page
+//    |                        |/
+// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
+//    |                        |\
+//    |      Normal Stack      | -
+//    |                        |/
+// P2 +------------------------+ Thread::stack_base()
+//
+// ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from
+//    pthread_attr_getstack()
+
+static void current_stack_region(address * bottom, size_t * size) {
+#ifdef __APPLE__
+  pthread_t self = pthread_self();
+  void *stacktop = pthread_get_stackaddr_np(self);
+  *size = pthread_get_stacksize_np(self);
+  // workaround for OS X 10.9.0 (Mavericks)
+  // pthread_get_stacksize_np returns 128 pages even though the actual size is 2048 pages
+  if (pthread_main_np() == 1) {
+    // At least on Mac OS 10.12 we have observed stack sizes not aligned
+    // to pages boundaries. This can be provoked by e.g. setrlimit() (ulimit -s xxxx in the
+    // shell). Apparently Mac OS actually rounds upwards to next multiple of page size,
+    // however, we round downwards here to be on the safe side.
+    *size = align_down(*size, getpagesize());
+
+    if ((*size) < (DEFAULT_MAIN_THREAD_STACK_PAGES * (size_t)getpagesize())) {
+      char kern_osrelease[256];
+      size_t kern_osrelease_size = sizeof(kern_osrelease);
+      int ret = sysctlbyname("kern.osrelease", kern_osrelease, &kern_osrelease_size, NULL, 0);
+      if (ret == 0) {
+        // get the major number, atoi will ignore the minor amd micro portions of the version string
+        if (atoi(kern_osrelease) >= OS_X_10_9_0_KERNEL_MAJOR_VERSION) {
+          *size = (DEFAULT_MAIN_THREAD_STACK_PAGES*getpagesize());
+        }
+      }
+    }
+  }
+  *bottom = (address) stacktop - *size;
+#elif defined(__OpenBSD__)
+  stack_t ss;
+  int rslt = pthread_stackseg_np(pthread_self(), &ss);
+
+  if (rslt != 0)
+    fatal("pthread_stackseg_np failed with error = %d", rslt);
+
+  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);
+  *size   = ss.ss_size;
+#else
+  pthread_attr_t attr;
+
+  int rslt = pthread_attr_init(&attr);
+
+  // JVM needs to know exact stack location, abort if it fails
+  if (rslt != 0)
+    fatal("pthread_attr_init failed with error = %d", rslt);
+
+  rslt = pthread_attr_get_np(pthread_self(), &attr);
+
+  if (rslt != 0)
+    fatal("pthread_attr_get_np failed with error = %d", rslt);
+
+  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||
+    pthread_attr_getstacksize(&attr, size) != 0) {
+    fatal("Can not locate current stack attributes!");
+  }
+
+  pthread_attr_destroy(&attr);
+#endif
+  assert(os::current_stack_pointer() >= *bottom &&
+         os::current_stack_pointer() < *bottom + *size, "just checking");
+}
+
+address os::current_stack_base() {
+  address bottom;
+  size_t size;
+  current_stack_region(&bottom, &size);
+  return (bottom + size);
+}
+
+size_t os::current_stack_size() {
+  // stack size includes normal stack and HotSpot guard pages
+  address bottom;
+  size_t size;
+  current_stack_region(&bottom, &size);
+  return size;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// helper functions for fatal error handler
+
+void os::print_context(outputStream *st, const void *context) {
+  if (context == NULL) return;
+
+  const ucontext_t *uc = (const ucontext_t*)context;
+  st->print_cr("Registers:");
+  st->print( " x0=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 0]);
+  st->print("  x1=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 1]);
+  st->print("  x2=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 2]);
+  st->print("  x3=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 3]);
+  st->cr();
+  st->print( " x4=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 4]);
+  st->print("  x5=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 5]);
+  st->print("  x6=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 6]);
+  st->print("  x7=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 7]);
+  st->cr();
+  st->print( " x8=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 8]);
+  st->print("  x9=" INTPTR_FORMAT, (intptr_t)uc->context_x[ 9]);
+  st->print(" x10=" INTPTR_FORMAT, (intptr_t)uc->context_x[10]);
+  st->print(" x11=" INTPTR_FORMAT, (intptr_t)uc->context_x[11]);
+  st->cr();
+  st->print( "x12=" INTPTR_FORMAT, (intptr_t)uc->context_x[12]);
+  st->print(" x13=" INTPTR_FORMAT, (intptr_t)uc->context_x[13]);
+  st->print(" x14=" INTPTR_FORMAT, (intptr_t)uc->context_x[14]);
+  st->print(" x15=" INTPTR_FORMAT, (intptr_t)uc->context_x[15]);
+  st->cr();
+  st->print( "x16=" INTPTR_FORMAT, (intptr_t)uc->context_x[16]);
+  st->print(" x17=" INTPTR_FORMAT, (intptr_t)uc->context_x[17]);
+  st->print(" x18=" INTPTR_FORMAT, (intptr_t)uc->context_x[18]);
+  st->print(" x19=" INTPTR_FORMAT, (intptr_t)uc->context_x[19]);
+  st->cr();
+  st->print( "x20=" INTPTR_FORMAT, (intptr_t)uc->context_x[20]);
+  st->print(" x21=" INTPTR_FORMAT, (intptr_t)uc->context_x[21]);
+  st->print(" x22=" INTPTR_FORMAT, (intptr_t)uc->context_x[22]);
+  st->print(" x23=" INTPTR_FORMAT, (intptr_t)uc->context_x[23]);
+  st->cr();
+  st->print( "x24=" INTPTR_FORMAT, (intptr_t)uc->context_x[24]);
+  st->print(" x25=" INTPTR_FORMAT, (intptr_t)uc->context_x[25]);
+  st->print(" x26=" INTPTR_FORMAT, (intptr_t)uc->context_x[26]);
+  st->print(" x27=" INTPTR_FORMAT, (intptr_t)uc->context_x[27]);
+  st->cr();
+  st->print( "x28=" INTPTR_FORMAT, (intptr_t)uc->context_x[28]);
+  st->print("  fp=" INTPTR_FORMAT, (intptr_t)uc->context_fp);
+  st->print("  lr=" INTPTR_FORMAT, (intptr_t)uc->context_lr);
+  st->print("  sp=" INTPTR_FORMAT, (intptr_t)uc->context_sp);
+  st->cr();
+  st->print(  "pc=" INTPTR_FORMAT,  (intptr_t)uc->context_pc);
+  st->print(" cpsr=" INTPTR_FORMAT, (intptr_t)uc->context_cpsr);
+  st->cr();
+
+  intptr_t *sp = (intptr_t *)os::Bsd::ucontext_get_sp(uc);
+  st->print_cr("Top of Stack: (sp=" INTPTR_FORMAT ")", (intptr_t)sp);
+  print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));
+  st->cr();
+
+  // Note: it may be unsafe to inspect memory near pc. For example, pc may
+  // point to garbage if entry point in an nmethod is corrupted. Leave
+  // this at the end, and hope for the best.
+  address pc = os::Bsd::ucontext_get_pc(uc);
+  print_instructions(st, pc, 4/*native instruction size*/);
+  st->cr();
+}
+
+void os::print_register_info(outputStream *st, const void *context) {
+  if (context == NULL) return;
+
+  const ucontext_t *uc = (const ucontext_t*)context;
+
+  st->print_cr("Register to memory mapping:");
+  st->cr();
+
+  // this is horrendously verbose but the layout of the registers in the
+  // context does not match how we defined our abstract Register set, so
+  // we can't just iterate through the gregs area
+
+  // this is only for the "general purpose" registers
+
+  st->print(" x0="); print_location(st, uc->context_x[ 0]);
+  st->print(" x1="); print_location(st, uc->context_x[ 1]);
+  st->print(" x2="); print_location(st, uc->context_x[ 2]);
+  st->print(" x3="); print_location(st, uc->context_x[ 3]);
+  st->print(" x4="); print_location(st, uc->context_x[ 4]);
+  st->print(" x5="); print_location(st, uc->context_x[ 5]);
+  st->print(" x6="); print_location(st, uc->context_x[ 6]);
+  st->print(" x7="); print_location(st, uc->context_x[ 7]);
+  st->print(" x8="); print_location(st, uc->context_x[ 8]);
+  st->print(" x9="); print_location(st, uc->context_x[ 9]);
+  st->print("x10="); print_location(st, uc->context_x[10]);
+  st->print("x11="); print_location(st, uc->context_x[11]);
+  st->print("x12="); print_location(st, uc->context_x[12]);
+  st->print("x13="); print_location(st, uc->context_x[13]);
+  st->print("x14="); print_location(st, uc->context_x[14]);
+  st->print("x15="); print_location(st, uc->context_x[15]);
+  st->print("x16="); print_location(st, uc->context_x[16]);
+  st->print("x17="); print_location(st, uc->context_x[17]);
+  st->print("x18="); print_location(st, uc->context_x[18]);
+  st->print("x19="); print_location(st, uc->context_x[19]);
+  st->print("x20="); print_location(st, uc->context_x[20]);
+  st->print("x21="); print_location(st, uc->context_x[21]);
+  st->print("x22="); print_location(st, uc->context_x[22]);
+  st->print("x23="); print_location(st, uc->context_x[23]);
+  st->print("x24="); print_location(st, uc->context_x[24]);
+  st->print("x25="); print_location(st, uc->context_x[25]);
+  st->print("x26="); print_location(st, uc->context_x[26]);
+  st->print("x27="); print_location(st, uc->context_x[27]);
+  st->print("x28="); print_location(st, uc->context_x[28]);
+
+  st->cr();
+}
+
+void os::setup_fpu() {
+}
+
+#ifndef PRODUCT
+void os::verify_stack_alignment() {
+  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, "incorrect stack alignment");
+}
+#endif
+
+int os::extra_bang_size_in_bytes() {
+  // AArch64 does not require the additional stack bang.
+  return 0;
+}
+
+extern "C" {
+  int SpinPause() {
+    return 0;
+  }
+
+  void _Copy_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {
+    if (from > to) {
+      const jshort *end = from + count;
+      while (from < end)
+        *(to++) = *(from++);
+    }
+    else if (from < to) {
+      const jshort *end = from;
+      from += count - 1;
+      to   += count - 1;
+      while (from >= end)
+        *(to--) = *(from--);
+    }
+  }
+  void _Copy_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {
+    if (from > to) {
+      const jint *end = from + count;
+      while (from < end)
+        *(to++) = *(from++);
+    }
+    else if (from < to) {
+      const jint *end = from;
+      from += count - 1;
+      to   += count - 1;
+      while (from >= end)
+        *(to--) = *(from--);
+    }
+  }
+  void _Copy_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {
+    if (from > to) {
+      const jlong *end = from + count;
+      while (from < end)
+        os::atomic_copy64(from++, to++);
+    }
+    else if (from < to) {
+      const jlong *end = from;
+      from += count - 1;
+      to   += count - 1;
+      while (from >= end)
+        os::atomic_copy64(from--, to--);
+    }
+  }
+
+  void _Copy_arrayof_conjoint_bytes(const HeapWord* from,
+                                    HeapWord* to,
+                                    size_t    count) {
+    memmove(to, from, count);
+  }
+  void _Copy_arrayof_conjoint_jshorts(const HeapWord* from,
+                                      HeapWord* to,
+                                      size_t    count) {
+    memmove(to, from, count * 2);
+  }
+  void _Copy_arrayof_conjoint_jints(const HeapWord* from,
+                                    HeapWord* to,
+                                    size_t    count) {
+    memmove(to, from, count * 4);
+  }
+  void _Copy_arrayof_conjoint_jlongs(const HeapWord* from,
+                                     HeapWord* to,
+                                     size_t    count) {
+    memmove(to, from, count * 8);
+  }
+};
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_VM_OS_BSD_AARCH64_HPP
+#define OS_CPU_BSD_AARCH64_VM_OS_BSD_AARCH64_HPP
+
+  static void setup_fpu();
+
+  static bool is_allocatable(size_t bytes);
+
+  // Used to register dynamic code cache area with the OS
+  // Note: Currently only used in 64 bit Windows implementations
+  static bool register_code_area(char *low, char *high) { return true; }
+
+  // Atomically copy 64 bits of data
+  static void atomic_copy64(const volatile void *src, volatile void *dst) {
+    *(jlong *) dst = *(const jlong *) src;
+  }
+
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunguarded-availability-new"
+    pthread_jit_write_protect_np(mode == WXExec ? true : false);
+#pragma clang diagnostic pop
+  }
+
+public:
+
+#endif // OS_CPU_BSD_AARCH64_VM_OS_BSD_AARCH64_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.inline.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.inline.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.inline.hpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/os_bsd_aarch64.inline.hpp	2021-01-16 16:01:37.000000000 +0100
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_LINUX_AARCH64_VM_OS_LINUX_AARCH64_INLINE_HPP
+#define OS_CPU_LINUX_AARCH64_VM_OS_LINUX_AARCH64_INLINE_HPP
+
+#include "runtime/os.hpp"
+
+// See http://www.technovelty.org/code/c/reading-rdtsc.htl for details
+inline jlong os::rdtsc() {
+  uint64_t res;
+  uint32_t ts1, ts2;
+  __asm__ __volatile__ ("rdtsc" : "=a" (ts1), "=d" (ts2));
+  res = ((uint64_t)ts1 | (uint64_t)ts2 << 32);
+  return (jlong)res;
+}
+
+#endif // OS_CPU_LINUX_AARCH64_VM_OS_LINUX_AARCH64_INLINE_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/prefetch_bsd_aarch64.inline.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_VM_PREFETCH_BSD_AARCH64_INLINE_HPP
+#define OS_CPU_BSD_AARCH64_VM_PREFETCH_BSD_AARCH64_INLINE_HPP
+
+#include "runtime/prefetch.hpp"
+
+
+inline void Prefetch::read (void *loc, intx interval) {
+  if (interval >= 0)
+    asm("prfm PLDL1KEEP, [%0, %1]" : : "r"(loc), "r"(interval));
+}
+
+inline void Prefetch::write(void *loc, intx interval) {
+  if (interval >= 0)
+    asm("prfm PSTL1KEEP, [%0, %1]" : : "r"(loc), "r"(interval));
+}
+
+#endif // OS_CPU_BSD_AARCH64_VM_PREFETCH_BSD_AARCH64_INLINE_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "memory/metaspaceShared.hpp"
+#include "runtime/frame.inline.hpp"
+#include "runtime/thread.inline.hpp"
+
+frame JavaThread::pd_last_frame() {
+  assert(has_last_Java_frame(), "must have last_Java_sp() when suspended");
+  vmassert(_anchor.last_Java_pc() != NULL, "not walkable");
+  return frame(_anchor.last_Java_sp(), _anchor.last_Java_fp(), _anchor.last_Java_pc());
+}
+
+// For Forte Analyzer AsyncGetCallTrace profiling support - thread is
+// currently interrupted by SIGPROF
+bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr,
+  void* ucontext, bool isInJava) {
+
+  assert(Thread::current() == this, "caller must be current thread");
+  return pd_get_top_frame(fr_addr, ucontext, isInJava);
+}
+
+bool JavaThread::pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava) {
+  return pd_get_top_frame(fr_addr, ucontext, isInJava);
+}
+
+bool JavaThread::pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava) {
+  assert(this->is_Java_thread(), "must be JavaThread");
+  JavaThread* jt = (JavaThread *)this;
+
+  // If we have a last_Java_frame, then we should use it even if
+  // isInJava == true.  It should be more reliable than ucontext info.
+  if (jt->has_last_Java_frame() && jt->frame_anchor()->walkable()) {
+    *fr_addr = jt->pd_last_frame();
+    return true;
+  }
+
+  // At this point, we don't have a last_Java_frame, so
+  // we try to glean some information out of the ucontext
+  // if we were running Java code when SIGPROF came in.
+  if (isInJava) {
+    ucontext_t* uc = (ucontext_t*) ucontext;
+
+    intptr_t* ret_fp;
+    intptr_t* ret_sp;
+    ExtendedPC addr = os::fetch_frame_from_context(uc, &ret_sp, &ret_fp);
+    if (addr.pc() == NULL || ret_sp == NULL ) {
+      // ucontext wasn't useful
+      return false;
+    }
+
+    if (MetaspaceShared::is_in_trampoline_frame(addr.pc())) {
+      // In the middle of a trampoline call. Bail out for safety.
+      // This happens rarely so shouldn't affect profiling.
+      return false;
+    }
+
+    frame ret_frame(ret_sp, ret_fp, addr.pc());
+    if (!ret_frame.safe_for_sender(jt)) {
+#ifdef COMPILER2
+      frame ret_frame2(ret_sp, NULL, addr.pc());
+      if (!ret_frame2.safe_for_sender(jt)) {
+        // nothing else to try if the frame isn't good
+        return false;
+      }
+      ret_frame = ret_frame2;
+#else
+      // nothing else to try if the frame isn't good
+      return false;
+#endif /* COMPILER2 */
+    }
+    *fr_addr = ret_frame;
+    return true;
+  }
+
+  // nothing else to try
+  return false;
+}
+
+void JavaThread::cache_global_variables() { }
+
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/thread_bsd_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_VM_THREAD_BSD_AARCH64_HPP
+#define OS_CPU_BSD_AARCH64_VM_THREAD_BSD_AARCH64_HPP
+
+ private:
+  void pd_initialize() {
+    _anchor.clear();
+  }
+
+  frame pd_last_frame();
+
+ public:
+  // Mutators are highly dangerous....
+  intptr_t* last_Java_fp()                       { return _anchor.last_Java_fp(); }
+  void  set_last_Java_fp(intptr_t* fp)           { _anchor.set_last_Java_fp(fp);   }
+
+  void set_base_of_stack_pointer(intptr_t* base_sp) {
+  }
+
+  static ByteSize last_Java_fp_offset()          {
+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_fp_offset();
+  }
+
+  intptr_t* base_of_stack_pointer() {
+    return NULL;
+  }
+  void record_base_of_stack_pointer() {
+  }
+
+  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,
+    bool isInJava);
+
+  bool pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava);
+private:
+  bool pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava);
+public:
+
+  static Thread *aarch64_get_thread_helper() {
+    return Thread::current();
+  }
+
+  // These routines are only used on cpu architectures that
+  // have separate register stacks (Itanium).
+  static bool register_stack_overflow() { return false; }
+  static void enable_register_stack_guard() {}
+  static void disable_register_stack_guard() {}
+
+#endif // OS_CPU_BSD_AARCH64_VM_THREAD_BSD_AARCH64_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/vmStructs_bsd_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef OS_CPU_BSD_AARCH64_VM_VMSTRUCTS_BSD_AARCH64_HPP
+#define OS_CPU_BSD_AARCH64_VM_VMSTRUCTS_BSD_AARCH64_HPP
+
+// These are the OS and CPU-specific fields, types and integer
+// constants required by the Serviceability Agent. This file is
+// referenced by vmStructs.cpp.
+
+#define VM_STRUCTS_OS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field) \
+                                                                                                                                     \
+  /******************************/                                                                                                   \
+  /* Threads (NOTE: incomplete) */                                                                                                   \
+  /******************************/                                                                                                   \
+  nonstatic_field(OSThread,                      _thread_id,                                      OSThread::thread_id_t)             \
+  nonstatic_field(OSThread,                      _unique_thread_id,                               uint64_t)
+
+
+#define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type) \
+                                                                          \
+  /**********************/                                                \
+  /* Thread IDs         */                                                \
+  /**********************/                                                \
+                                                                          \
+  declare_unsigned_integer_type(OSThread::thread_id_t)
+
+#define VM_INT_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)
+
+#define VM_LONG_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)
+
+#endif // OS_CPU_BSD_AARCH64_VM_VMSTRUCTS_BSD_AARCH64_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_aarch64/vm_version_bsd_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "runtime/java.hpp"
+#include "runtime/os.hpp"
+#include "runtime/vm_version.hpp"
+
+#include <sys/sysctl.h>
+
+int VM_Version::get_current_sve_vector_length() {
+  ShouldNotCallThis();
+  return 0;
+}
+
+int VM_Version::set_and_get_current_sve_vector_lenght(int length) {
+  ShouldNotCallThis();
+  return 0;
+}
+
+static bool cpu_has(const char* optional) {
+  uint32_t val;
+  size_t len = sizeof(val);
+  if (sysctlbyname(optional, &val, &len, NULL, 0)) {
+    return false;
+  }
+  return val;
+}
+
+void VM_Version::get_os_cpu_info() {
+  size_t sysctllen;
+
+  // hw.optional.floatingpoint always returns 1.
+  // ID_AA64PFR0_EL1 describes AdvSIMD always equals to FP field.
+  _features = CPU_FP | CPU_ASIMD;
+
+  // Only few features are available via sysctl, see line 614
+  // https://opensource.apple.com/source/xnu/xnu-6153.141.1/bsd/kern/kern_mib.c.auto.html
+  if (cpu_has("hw.optional.armv8_crc32"))     _features |= CPU_CRC32;
+  if (cpu_has("hw.optional.armv8_1_atomics")) _features |= CPU_LSE;
+
+  int cache_line_size;
+  int hw_conf_cache_line[] = { CTL_HW, HW_CACHELINE };
+  sysctllen = sizeof(cache_line_size);
+  if (sysctl(hw_conf_cache_line, 2, &cache_line_size, &sysctllen, NULL, 0)) {
+    cache_line_size = 16;
+  }
+  _icache_line_size = 16; // minimal line lenght CCSIDR_EL1 can hold
+  _dcache_line_size = cache_line_size;
+
+  uint64_t dczid_el0;
+  __asm__ (
+    "mrs %0, DCZID_EL0\n"
+    : "=r"(dczid_el0)
+  );
+  if (!(dczid_el0 & 0x10)) {
+    _zva_length = 4 << (dczid_el0 & 0xf);
+  }
+
+  int family;
+  sysctllen = sizeof(family);
+  if (sysctlbyname("hw.cpufamily", &family, &sysctllen, NULL, 0)) {
+    family = 0;
+  }
+  _model = family;
+  _cpu = CPU_APPLE;
+}
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_x86/os_bsd_x86.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -36,4 +36,10 @@
   // Note: Currently only used in 64 bit Windows implementations
   static bool register_code_area(char *low, char *high) { return true; }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_BSD_X86_VM_OS_BSD_X86_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_x86/vm_version_bsd_x86.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_x86/vm_version_bsd_x86.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_x86/vm_version_bsd_x86.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_x86/vm_version_bsd_x86.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,4 +24,4 @@
 
 #include "precompiled.hpp"
 #include "runtime/os.hpp"
-#include "vm_version_x86.hpp"
+#include "runtime/vm_version.hpp"
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_zero/os_bsd_zero.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -53,4 +53,10 @@
 #endif
   }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_BSD_ZERO_VM_OS_BSD_ZERO_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_zero/vm_version_bsd_zero.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_zero/vm_version_bsd_zero.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/bsd_zero/vm_version_bsd_zero.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/bsd_zero/vm_version_bsd_zero.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2009 Red Hat, Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
@@ -25,6 +25,6 @@
 
 #include "precompiled.hpp"
 #include "runtime/os.hpp"
-#include "vm_version_zero.hpp"
+#include "runtime/vm_version.hpp"
 
 // This file is intentionally empty
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_aarch64/atomic_linux_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_aarch64/atomic_linux_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_aarch64/atomic_linux_aarch64.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_aarch64/atomic_linux_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,7 +26,7 @@
 #ifndef OS_CPU_LINUX_AARCH64_VM_ATOMIC_LINUX_AARCH64_HPP
 #define OS_CPU_LINUX_AARCH64_VM_ATOMIC_LINUX_AARCH64_HPP
 
-#include "vm_version_aarch64.hpp"
+#include "runtime/vm_version.hpp"
 
 // Implementation of class atomic
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_aarch64/orderAccess_linux_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_aarch64/orderAccess_linux_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_aarch64/orderAccess_linux_aarch64.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_aarch64/orderAccess_linux_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,7 +28,7 @@
 
 // Included in orderAccess.hpp header file.
 
-#include "vm_version_aarch64.hpp"
+#include "runtime/vm_version.hpp"
 
 // Implementation of class OrderAccess.
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_aarch64/os_linux_aarch64.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -42,4 +42,10 @@
     *(jlong *) dst = *(const jlong *) src;
   }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_LINUX_AARCH64_VM_OS_LINUX_AARCH64_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_aarch64/vm_version_linux_aarch64.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_aarch64/vm_version_linux_aarch64.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_aarch64/vm_version_linux_aarch64.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_aarch64/vm_version_linux_aarch64.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2014, Red Hat Inc. All rights reserved.
+ * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,5 +25,120 @@
 
 #include "precompiled.hpp"
 #include "runtime/os.hpp"
-#include "vm_version_aarch64.hpp"
+#include "runtime/vm_version.hpp"
 
+#include <asm/hwcap.h>
+#include <sys/auxv.h>
+#include <sys/prctl.h>
+
+#ifndef HWCAP_AES
+#define HWCAP_AES   (1<<3)
+#endif
+
+#ifndef HWCAP_PMULL
+#define HWCAP_PMULL (1<<4)
+#endif
+
+#ifndef HWCAP_SHA1
+#define HWCAP_SHA1  (1<<5)
+#endif
+
+#ifndef HWCAP_SHA2
+#define HWCAP_SHA2  (1<<6)
+#endif
+
+#ifndef HWCAP_CRC32
+#define HWCAP_CRC32 (1<<7)
+#endif
+
+#ifndef HWCAP_ATOMICS
+#define HWCAP_ATOMICS (1<<8)
+#endif
+
+int VM_Version::get_current_sve_vector_length() {
+  assert(_features & CPU_SVE, "should not call this");
+  return prctl(PR_SVE_GET_VL);
+}
+
+int VM_Version::set_and_get_current_sve_vector_lenght(int length) {
+  assert(_features & CPU_SVE, "should not call this");
+  int new_length = prctl(PR_SVE_SET_VL, length);
+  return new_length;
+}
+
+void VM_Version::get_os_cpu_info() {
+
+  uint64_t auxv = getauxval(AT_HWCAP);
+  uint64_t auxv2 = getauxval(AT_HWCAP2);
+
+  static_assert(CPU_FP      == HWCAP_FP);
+  static_assert(CPU_ASIMD   == HWCAP_ASIMD);
+  static_assert(CPU_EVTSTRM == HWCAP_EVTSTRM);
+  static_assert(CPU_AES     == HWCAP_AES);
+  static_assert(CPU_PMULL   == HWCAP_PMULL);
+  static_assert(CPU_SHA1    == HWCAP_SHA1);
+  static_assert(CPU_SHA2    == HWCAP_SHA2);
+  static_assert(CPU_CRC32   == HWCAP_CRC32);
+  static_assert(CPU_LSE     == HWCAP_ATOMICS);
+  static_assert(CPU_DCPOP   == HWCAP_DCPOP);
+  static_assert(CPU_SHA512  == HWCAP_SHA512);
+  static_assert(CPU_SVE     == HWCAP_SVE);
+  _features = auxv & (
+      HWCAP_FP      |
+      HWCAP_ASIMD   |
+      HWCAP_EVTSTRM |
+      HWCAP_AES     |
+      HWCAP_PMULL   |
+      HWCAP_SHA1    |
+      HWCAP_SHA2    |
+      HWCAP_CRC32   |
+      HWCAP_ATOMICS |
+      HWCAP_DCPOP   |
+      HWCAP_SHA512  |
+      HWCAP_SVE);
+
+  if (auxv2 & HWCAP2_SVE2) _features |= CPU_SVE2;
+
+  uint64_t ctr_el0;
+  uint64_t dczid_el0;
+  __asm__ (
+    "mrs %0, CTR_EL0\n"
+    "mrs %1, DCZID_EL0\n"
+    : "=r"(ctr_el0), "=r"(dczid_el0)
+  );
+
+  _icache_line_size = (1 << (ctr_el0 & 0x0f)) * 4;
+  _dcache_line_size = (1 << ((ctr_el0 >> 16) & 0x0f)) * 4;
+
+  if (!(dczid_el0 & 0x10)) {
+    _zva_length = 4 << (dczid_el0 & 0xf);
+  }
+
+  int cpu_lines = 0;
+  if (FILE *f = fopen("/proc/cpuinfo", "r")) {
+    // need a large buffer as the flags line may include lots of text
+    char buf[1024], *p;
+    while (fgets(buf, sizeof (buf), f) != NULL) {
+      if ((p = strchr(buf, ':')) != NULL) {
+        long v = strtol(p+1, NULL, 0);
+        if (strncmp(buf, "CPU implementer", sizeof "CPU implementer" - 1) == 0) {
+          _cpu = v;
+          cpu_lines++;
+        } else if (strncmp(buf, "CPU variant", sizeof "CPU variant" - 1) == 0) {
+          _variant = v;
+        } else if (strncmp(buf, "CPU part", sizeof "CPU part" - 1) == 0) {
+          if (_model != v)  _model2 = _model;
+          _model = v;
+        } else if (strncmp(buf, "CPU revision", sizeof "CPU revision" - 1) == 0) {
+          _revision = v;
+        } else if (strncmp(buf, "flags", sizeof("flags") - 1) == 0) {
+          if (strstr(p+1, "dcpop")) {
+            guarantee(_features & CPU_DCPOP, "dcpop availability should be consistent");
+          }
+        }
+      }
+    }
+    fclose(f);
+  }
+  guarantee(cpu_lines == os::processor_count(), "core count should be consistent");
+}
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_arm/atomic_linux_arm.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_arm/atomic_linux_arm.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_arm/atomic_linux_arm.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_arm/atomic_linux_arm.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -26,7 +26,7 @@
 #define OS_CPU_LINUX_ARM_VM_ATOMIC_LINUX_ARM_HPP
 
 #include "runtime/os.hpp"
-#include "vm_version_arm.hpp"
+#include "runtime/vm_version.hpp"
 
 // Implementation of class atomic
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_arm/orderAccess_linux_arm.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_arm/orderAccess_linux_arm.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_arm/orderAccess_linux_arm.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_arm/orderAccess_linux_arm.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -28,7 +28,7 @@
 // Included in orderAccess.hpp header file.
 
 #include "runtime/os.hpp"
-#include "vm_version_arm.hpp"
+#include "runtime/vm_version.hpp"
 
 // Implementation of class OrderAccess.
 // - we define the high level barriers below and use the general
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_arm/os_linux_arm.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -76,4 +76,10 @@
                                            volatile int32_t *dest);
 #endif // !AARCH64
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_LINUX_ARM_VM_OS_LINUX_ARM_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_arm/vm_version_linux_arm_32.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_arm/vm_version_linux_arm_32.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_arm/vm_version_linux_arm_32.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_arm/vm_version_linux_arm_32.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,7 +24,7 @@
 
 #include "precompiled.hpp"
 #include "runtime/os.hpp"
-#include "vm_version_arm.hpp"
+#include "runtime/vm_version.hpp"
 
 # include <sys/utsname.h>
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_ppc/os_linux_ppc.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -32,4 +32,10 @@
   // Note: Currently only used in 64 bit Windows implementations
   static bool register_code_area(char *low, char *high) { return true; }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_LINUX_PPC_VM_OS_LINUX_PPC_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_s390/atomic_linux_s390.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_s390/atomic_linux_s390.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_s390/atomic_linux_s390.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_s390/atomic_linux_s390.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2016, 2018 SAP SE. All rights reserved.
+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,7 +28,7 @@
 
 #include "runtime/atomic.hpp"
 #include "runtime/os.hpp"
-#include "vm_version_s390.hpp"
+#include "runtime/vm_version.hpp"
 
 // Note that the compare-and-swap instructions on System z perform
 // a serialization function before the storage operand is fetched
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_s390/orderAccess_linux_s390.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_s390/orderAccess_linux_s390.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_s390/orderAccess_linux_s390.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_s390/orderAccess_linux_s390.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2016 SAP SE. All rights reserved.
+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,7 +28,7 @@
 
 // Included in orderAccess.hpp header file.
 
-#include "vm_version_s390.hpp"
+#include "runtime/vm_version.hpp"
 
 // Implementation of class OrderAccess.
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_s390/os_linux_s390.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_s390/os_linux_s390.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_s390/os_linux_s390.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_s390/os_linux_s390.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -31,5 +31,11 @@
   // Used to register dynamic code cache area with the OS.
   static bool register_code_area(char *low, char *high) { return true; }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_LINUX_S390_VM_OS_LINUX_S390_HPP
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_sparc/vm_version_linux_sparc.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_sparc/vm_version_linux_sparc.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_sparc/vm_version_linux_sparc.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_sparc/vm_version_linux_sparc.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,7 +25,7 @@
 #include "logging/log.hpp"
 #include "precompiled.hpp"
 #include "runtime/os.hpp"
-#include "vm_version_sparc.hpp"
+#include "runtime/vm_version.hpp"
 
 
 #define CPUINFO_LINE_SIZE 1024
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_x86/os_linux_x86.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -49,4 +49,10 @@
    */
   static void workaround_expand_exec_shield_cs_limit();
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_LINUX_X86_VM_OS_LINUX_X86_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_x86/vm_version_linux_x86.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_x86/vm_version_linux_x86.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_x86/vm_version_linux_x86.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_x86/vm_version_linux_x86.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,5 +24,5 @@
 
 #include "precompiled.hpp"
 #include "runtime/os.hpp"
-#include "vm_version_x86.hpp"
+#include "runtime/vm_version.hpp"
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_zero/os_linux_zero.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_zero/os_linux_zero.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_zero/os_linux_zero.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_zero/os_linux_zero.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -69,4 +69,10 @@
 #endif
   }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+private:
+
 #endif // OS_CPU_LINUX_ZERO_VM_OS_LINUX_ZERO_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_zero/vm_version_linux_zero.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_zero/vm_version_linux_zero.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/linux_zero/vm_version_linux_zero.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/linux_zero/vm_version_linux_zero.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * Copyright 2009 Red Hat, Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
@@ -25,6 +25,6 @@
 
 #include "precompiled.hpp"
 #include "runtime/os.hpp"
-#include "vm_version_zero.hpp"
+#include "runtime/vm_version.hpp"
 
 // This file is intentionally empty
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/solaris_sparc/os_solaris_sparc.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/solaris_sparc/os_solaris_sparc.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/solaris_sparc/os_solaris_sparc.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/solaris_sparc/os_solaris_sparc.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -46,4 +46,10 @@
   // Note: Currently only used in 64 bit Windows implementations
   static bool register_code_area(char *low, char *high) { return true; }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_SOLARIS_SPARC_VM_OS_SOLARIS_SPARC_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/solaris_sparc/vm_version_solaris_sparc.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/solaris_sparc/vm_version_solaris_sparc.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/solaris_sparc/vm_version_solaris_sparc.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/solaris_sparc/vm_version_solaris_sparc.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,7 +27,7 @@
 #include "memory/allocation.hpp"
 #include "memory/allocation.inline.hpp"
 #include "runtime/os.hpp"
-#include "vm_version_sparc.hpp"
+#include "runtime/vm_version.hpp"
 
 #include <sys/auxv.h>
 #include <sys/systeminfo.h>
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/solaris_x86/os_solaris_x86.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/solaris_x86/os_solaris_x86.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/solaris_x86/os_solaris_x86.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/solaris_x86/os_solaris_x86.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -54,4 +54,10 @@
   // Note: Currently only used in 64 bit Windows implementations
   static bool register_code_area(char *low, char *high) { return true; }
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_SOLARIS_X86_VM_OS_SOLARIS_X86_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/solaris_x86/vm_version_solaris_x86.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/solaris_x86/vm_version_solaris_x86.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/solaris_x86/vm_version_solaris_x86.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/solaris_x86/vm_version_solaris_x86.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,5 +24,5 @@
 
 #include "precompiled.hpp"
 #include "runtime/os.hpp"
-#include "vm_version_x86.hpp"
+#include "runtime/vm_version.hpp"
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/windows_x86/os_windows_x86.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -70,4 +70,10 @@ static bool platform_print_native_stack(
                                         char *buf, int buf_size);
 #endif
 
+private:
+
+  static void current_thread_enable_wx_impl(WXMode mode) { }
+
+public:
+
 #endif // OS_CPU_WINDOWS_X86_VM_OS_WINDOWS_X86_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/windows_x86/vm_version_windows_x86.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/windows_x86/vm_version_windows_x86.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/os_cpu/windows_x86/vm_version_windows_x86.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/os_cpu/windows_x86/vm_version_windows_x86.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,5 +24,5 @@
 
 #include "precompiled.hpp"
 #include "runtime/os.hpp"
-#include "vm_version_x86.hpp"
+#include "runtime/vm_version.hpp"
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/ci/ciUtilities.inline.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/ci/ciUtilities.inline.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/ci/ciUtilities.inline.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/ci/ciUtilities.inline.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -34,6 +34,7 @@
 #define VM_ENTRY_MARK                       \
   CompilerThread* thread=CompilerThread::current(); \
   ThreadInVMfromNative __tiv(thread);       \
+  Thread::WXWriteVerifier __wx_write;       \
   ResetNoHandleMark rnhm;                   \
   HandleMarkCleaner __hm(thread);           \
   Thread* THREAD = thread;                  \
@@ -45,6 +46,7 @@
 #define VM_QUICK_ENTRY_MARK                 \
   CompilerThread* thread=CompilerThread::current(); \
   ThreadInVMfromNative __tiv(thread);       \
+  Thread::WXWriteVerifier __wx_write;       \
 /*                                          \
  * [TODO] The NoHandleMark line does nothing but declare a function prototype \
  * The NoHandkeMark constructor is NOT executed. If the ()'s are   \
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/classfile/classLoader.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/classfile/classLoader.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/classfile/classLoader.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/classfile/classLoader.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -313,6 +313,7 @@ u1* ClassPathZipEntry::open_entry(const 
     // enable call to C land
   JavaThread* thread = JavaThread::current();
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   // check whether zip archive contains name
   jint name_len;
   jzentry* entry = (*FindEntry)(_zip, name, filesize, &name_len);
@@ -443,6 +444,7 @@ void ClassPathZipEntry::contents_do(void
   JavaThread* thread = JavaThread::current();
   HandleMark  handle_mark(thread);
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   for (int n = 0; ; n++) {
     jzentry * ze = ((*GetNextEntry)(_zip, n));
     if (ze == NULL) break;
@@ -942,6 +944,7 @@ ClassPathEntry* ClassLoader::create_clas
       {
         // enable call to C land
         ThreadToNativeFromVM ttn(thread);
+        Thread::WXExecFromWriteSetter wx_exec;
         HandleMark hm(thread);
         zip = (*ZipOpen)(canonical_path, &error_msg);
       }
@@ -991,6 +994,7 @@ ClassPathZipEntry* ClassLoader::create_c
           // enable call to C land
           JavaThread* thread = JavaThread::current();
           ThreadToNativeFromVM ttn(thread);
+          Thread::WXExecFromWriteSetter wx_exec;
           HandleMark hm(thread);
           zip = (*ZipOpen)(canonical_path, &error_msg);
         }
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/classfile/javaClasses.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/classfile/javaClasses.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/classfile/javaClasses.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/classfile/javaClasses.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -401,6 +401,7 @@ Handle java_lang_String::create_from_pla
     assert(thread->is_Java_thread(), "must be java thread");
     HandleMark hm(thread);
     ThreadToNativeFromVM ttn(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     js = (_to_java_string_fn)(thread->jni_environment(), str);
   }
   return Handle(THREAD, JNIHandles::resolve(js));
@@ -428,6 +429,7 @@ char* java_lang_String::as_platform_depe
     bool is_copy;
     HandleMark hm(thread);
     ThreadToNativeFromVM ttn(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     native_platform_string = (_to_platform_string_fn)(env, js, &is_copy);
     assert(is_copy == JNI_TRUE, "is_copy value changed");
     JNIHandles::destroy_local(js);
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/classfile/verifier.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/classfile/verifier.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/classfile/verifier.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/classfile/verifier.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -285,6 +285,7 @@ Symbol* Verifier::inference_verify(
   {
     HandleMark hm(thread);
     ThreadToNativeFromVM ttn(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     // ThreadToNativeFromVM takes care of changing thread_state, so safepoint
     // code knows that we have left the VM
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/compiler/compileBroker.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/compiler/compileBroker.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/compiler/compileBroker.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/compiler/compileBroker.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1673,6 +1673,7 @@ bool CompileBroker::init_compiler_runtim
   {
     // Must switch to native to allocate ci_env
     ThreadToNativeFromVM ttn(thread);
+    Thread::WXWriteVerifier wx_write;
     ciEnv ci_env(NULL, system_dictionary_modification_counter);
     // Cache Jvmti state
     ci_env.cache_jvmti_state();
@@ -1975,6 +1976,7 @@ void CompileBroker::maybe_block() {
       tty->print_cr("compiler thread " INTPTR_FORMAT " poll detects block request", p2i(Thread::current()));
 #endif
     ThreadInVMfromNative tivfn(JavaThread::current());
+    Thread::WXWriteVerifier wx_write;
   }
 }
 
@@ -2157,6 +2159,7 @@ void CompileBroker::invoke_compiler_on_m
   {
     NoHandleMark  nhm;
     ThreadToNativeFromVM ttn(thread);
+    Thread::WXWriteVerifier wx_write;
 
     ciEnv ci_env(task, system_dictionary_modification_counter);
     if (should_break) {
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/g1/g1PageBasedVirtualSpace.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -209,7 +209,7 @@ void G1PageBasedVirtualSpace::uncommit_i
             "Given start page " SIZE_FORMAT " is larger or equal to end page " SIZE_FORMAT, start_page, end_page);
 
   char* start_addr = page_start(start_page);
-  os::uncommit_memory(start_addr, pointer_delta(bounded_end_addr(end_page), start_addr, sizeof(char)));
+  os::uncommit_memory(start_addr, pointer_delta(bounded_end_addr(end_page), start_addr, sizeof(char)), !ExecMem);
 }
 
 void G1PageBasedVirtualSpace::uncommit(size_t start_page, size_t size_in_pages) {
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/parallel/psCardTable.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/parallel/psCardTable.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/parallel/psCardTable.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/parallel/psCardTable.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -557,7 +557,8 @@ bool PSCardTable::resize_commit_uncommit
       MemRegion(cur_committed.start(), new_start_aligned));
     if (!uncommit_region.is_empty()) {
       if (!os::uncommit_memory((char*)uncommit_region.start(),
-                               uncommit_region.byte_size())) {
+                               uncommit_region.byte_size(),
+                               !ExecMem)) {
         // If the uncommit fails, ignore it.  Let the
         // committed table resizing go even though the committed
         // table will over state the committed space.
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/parallel/psVirtualspace.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/parallel/psVirtualspace.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/parallel/psVirtualspace.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/parallel/psVirtualspace.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -107,7 +107,7 @@ bool PSVirtualSpace::shrink_by(size_t by
   }
 
   char* const base_addr = committed_high_addr() - bytes;
-  bool result = special() || os::uncommit_memory(base_addr, bytes);
+  bool result = special() || os::uncommit_memory(base_addr, bytes, !ExecMem);
   if (result) {
     _committed_high_addr -= bytes;
   }
@@ -262,7 +262,7 @@ bool PSVirtualSpaceHighToLow::shrink_by(
   }
 
   char* const base_addr = committed_low_addr();
-  bool result = special() || os::uncommit_memory(base_addr, bytes);
+  bool result = special() || os::uncommit_memory(base_addr, bytes, !ExecMem);
   if (result) {
     _committed_low_addr += bytes;
   }
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/shared/cardTable.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/shared/cardTable.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/shared/cardTable.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/shared/cardTable.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -273,7 +273,8 @@ void CardTable::resize_covered_region(Me
         // owned by generation A but being used by generation B.
         if (!UseAdaptiveGCBoundary) {
           if (!os::uncommit_memory((char*)uncommit_region.start(),
-                                   uncommit_region.byte_size())) {
+                                   uncommit_region.byte_size(),
+                                   !ExecMem)) {
             assert(false, "Card table contraction failed");
             // The call failed so don't change the end of the
             // committed region.  This is better than taking the
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/shared/oopStorage.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/shared/oopStorage.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/shared/oopStorage.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/shared/oopStorage.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -35,7 +35,7 @@
 #include "runtime/mutexLocker.hpp"
 #include "runtime/orderAccess.hpp"
 #include "runtime/safepoint.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.hpp"
 #include "utilities/align.hpp"
 #include "utilities/count_trailing_zeros.hpp"
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1299,7 +1299,7 @@ void ShenandoahHeap::object_iterate(Obje
 
   assert(oop_stack.is_empty(), "should be empty");
 
-  if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
+  if (!_aux_bitmap_region_special && !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), !ExecMem)) {
     log_warning(gc)("Could not uncommit native memory for auxiliary marking bitmap for heap iteration");
   }
 }
@@ -2369,7 +2369,7 @@ bool ShenandoahHeap::uncommit_bitmap_sli
   size_t slice = r->index() / _bitmap_regions_per_slice;
   size_t off = _bitmap_bytes_per_slice * slice;
   size_t len = _bitmap_bytes_per_slice;
-  if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len)) {
+  if (!os::uncommit_memory((char*)_bitmap_region.start() + off, len, !ExecMem)) {
     return false;
   }
   return true;
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -632,7 +632,7 @@ void ShenandoahHeapRegion::do_commit() {
 
 void ShenandoahHeapRegion::do_uncommit() {
   ShenandoahHeap* heap = ShenandoahHeap::heap();
-  if (!heap->is_heap_region_special() && !os::uncommit_memory((char *) bottom(), RegionSizeBytes)) {
+  if (!heap->is_heap_region_special() && !os::uncommit_memory((char *) bottom(), RegionSizeBytes, !ExecMem)) {
     report_java_out_of_memory("Unable to uncommit region");
   }
   if (!heap->uncommit_bitmap_slice(this)) {
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/interpreter/oopMapCache.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/interpreter/oopMapCache.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/interpreter/oopMapCache.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/interpreter/oopMapCache.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -241,6 +241,8 @@ class MaskFillerForNative: public Native
   }
 
  public:
+  void pass_byte()                               { /* ignore */ }
+  void pass_short()                              { /* ignore */ }
   void pass_int()                                { /* ignore */ }
   void pass_long()                               { /* ignore */ }
   void pass_float()                              { /* ignore */ }
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/jfr/instrumentation/jfrJvmtiAgent.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -90,6 +90,7 @@ extern "C" void JNICALL jfr_on_class_fil
   }
   JavaThread* jt = JavaThread::thread_from_jni_environment(jni_env);
   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));;
+  Thread::WXWriteFromExecSetter wx_write;
   ThreadInVMfromNative tvmfn(jt);
   JfrUpcalls::on_retransform(JfrTraceId::get(class_being_redefined),
                              class_being_redefined,
@@ -237,6 +238,7 @@ JfrJvmtiAgent::~JfrJvmtiAgent() {
   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
   if (jfr_jvmti_env != NULL) {
     ThreadToNativeFromVM transition(jt);
+    Thread::WXExecFromWriteSetter wx_exec;
     update_class_file_load_hook_event(JVMTI_DISABLE);
     unregister_callbacks(jt);
     jfr_jvmti_env->DisposeEnvironment();
@@ -248,6 +250,7 @@ static bool initialize(JavaThread* jt) {
   assert(jt != NULL, "invariant");
   DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));
   ThreadToNativeFromVM transition(jt);
+  Thread::WXExecFromWriteSetter wx_exec;
   if (create_jvmti_env(jt) != JNI_OK) {
     assert(jfr_jvmti_env == NULL, "invariant");
     return false;
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -917,6 +917,7 @@ JVMCIEnv::CodeInstallResult CodeInstalle
     if (SafepointMechanism::poll(thread)) {
       // this is a hacky way to force a safepoint check but nothing else was jumping out at me.
       ThreadToNativeFromVM ttnfv(thread);
+      Thread::WXWriteVerifier wx_write;
     }
   }
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/jvmci/jvmciEnv.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/jvmci/jvmciEnv.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/jvmci/jvmciEnv.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/jvmci/jvmciEnv.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -38,6 +38,7 @@ class CompileTask;
 #define JVMCI_VM_ENTRY_MARK                       \
   JavaThread* thread = JavaThread::current(); \
   ThreadInVMfromNative __tiv(thread);       \
+  Thread::WXWriteFromExecSetter __wx_write; \
   ResetNoHandleMark rnhm;                   \
   HandleMarkCleaner __hm(thread);           \
   Thread* THREAD = thread;                  \
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/jvmci/jvmciRuntime.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/jvmci/jvmciRuntime.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/jvmci/jvmciRuntime.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/jvmci/jvmciRuntime.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -809,6 +809,7 @@ JVM_ENTRY(void, JVM_RegisterJVMCINatives
 
   {
     ThreadToNativeFromVM trans(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     env->RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count());
   }
 JVM_END
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/memory/virtualspace.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/memory/virtualspace.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/memory/virtualspace.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/memory/virtualspace.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -196,7 +196,7 @@ void ReservedSpace::initialize(size_t si
         base = NULL;
       }
     } else {
-      base = os::reserve_memory(size, NULL, alignment, _fd_for_heap);
+      base = os::reserve_memory(size, NULL, alignment, _fd_for_heap, _executable);
     }
 
     if (base == NULL) return;
@@ -990,7 +990,7 @@ void VirtualSpace::shrink_by(size_t size
     assert(middle_high_boundary() <= aligned_upper_new_high &&
            aligned_upper_new_high + upper_needs <= upper_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_upper_new_high, upper_needs)) {
+    if (!os::uncommit_memory(aligned_upper_new_high, upper_needs, _executable)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
@@ -1001,7 +1001,7 @@ void VirtualSpace::shrink_by(size_t size
     assert(lower_high_boundary() <= aligned_middle_new_high &&
            aligned_middle_new_high + middle_needs <= middle_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_middle_new_high, middle_needs)) {
+    if (!os::uncommit_memory(aligned_middle_new_high, middle_needs, _executable)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
@@ -1012,7 +1012,7 @@ void VirtualSpace::shrink_by(size_t size
     assert(low_boundary() <= aligned_lower_new_high &&
            aligned_lower_new_high + lower_needs <= lower_high_boundary(),
            "must not shrink beyond region");
-    if (!os::uncommit_memory(aligned_lower_new_high, lower_needs)) {
+    if (!os::uncommit_memory(aligned_lower_new_high, lower_needs, _executable)) {
       debug_only(warning("os::uncommit_memory failed"));
       return;
     } else {
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/opto/runtime.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/opto/runtime.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/opto/runtime.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/opto/runtime.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1455,6 +1455,8 @@ address OptoRuntime::rethrow_C(oopDesc* 
   }
 #endif
 
+  Thread::WXWriteFromExecSetter wx_write;
+
   thread->set_vm_result(exception);
   // Frame not compiled (handles deoptimization blob)
   return SharedRuntime::raw_exception_handler_for_return_address(thread, ret_pc);
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jni.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jni.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jni.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jni.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -4007,6 +4007,7 @@ static jint JNI_CreateJavaVM_inner(JavaV
 #endif
 
     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
+    Thread::enable_wx_from_write(WXExec);
     ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
   } else {
     // If create_vm exits because of a pending exception, exit with that
@@ -4103,6 +4104,7 @@ static jint JNICALL jni_DestroyJavaVM_in
   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
   JavaThread* thread = JavaThread::current();
   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
+  Thread::enable_wx_from_exec(WXWrite);
   if (Threads::destroy_vm()) {
     // Should not change thread state, VM is gone
     vm_created = 0;
@@ -4163,6 +4165,7 @@ static jint attach_current_thread(JavaVM
   thread->record_stack_base_and_size();
   thread->register_thread_stack_with_NMT();
   thread->initialize_thread_current();
+  thread->init_wx();
 
   if (!os::create_attached_thread(thread)) {
     thread->smr_delete();
@@ -4237,6 +4240,7 @@ static jint attach_current_thread(JavaVM
   // needed.
 
   ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native);
+  Thread::enable_wx_from_write(WXExec);
 
   // Perform any platform dependent FPU setup
   os::setup_fpu();
@@ -4294,6 +4298,7 @@ jint JNICALL jni_DetachCurrentThread(Jav
   // Safepoint support. Have to do call-back to safepoint code, if in the
   // middle of a safepoint operation
   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
+  Thread::enable_wx_from_exec(WXWrite);
 
   // XXX: Note that JavaThread::exit() call below removes the guards on the
   // stack pages set up via enable_stack_{red,yellow}_zone() calls
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jniCheck.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jniCheck.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jniCheck.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jniCheck.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -61,6 +61,7 @@
 
 #define IN_VM(source_code)   {                                         \
     {                                                                  \
+      Thread::WXWriteFromExecSetter __wx_write;                        \
       ThreadInVMfromNative __tiv(thr);                                 \
       source_code                                                      \
     }                                                                  \
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jvm.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jvm.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jvm.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jvm.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -3439,6 +3439,7 @@ JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(
   void *load_result;
   {
     ThreadToNativeFromVM ttnfvm(thread);
+    Thread::WXWriteVerifier wx_write;
     load_result = os::dll_load(name, ebuf, sizeof ebuf);
   }
   if (load_result == NULL) {
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jvmtiEnter.xsl jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jvmtiEnter.xsl
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jvmtiEnter.xsl	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jvmtiEnter.xsl	2021-01-16 15:56:28.000000000 +0100
@@ -432,6 +432,8 @@ struct jvmtiInterface_1_ jvmti</xsl:text
   <xsl:if test="count(@impl)=0 or not(contains(@impl,'innative'))">
     <xsl:text>JavaThread* current_thread = (JavaThread*)this_thread;</xsl:text>   
     <xsl:value-of select="$space"/>
+    <xsl:text>Thread::WXWriteFromExecSetter __wx_write;</xsl:text>
+    <xsl:value-of select="$space"/>
     <xsl:text>ThreadInVMfromNative __tiv(current_thread);</xsl:text>
     <xsl:value-of select="$space"/>
     <xsl:text>VM_ENTRY_BASE(jvmtiError, </xsl:text>
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jvmtiEnv.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jvmtiEnv.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jvmtiEnv.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jvmtiEnv.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -173,6 +173,7 @@ JvmtiEnv::GetThreadLocalStorage(jthread 
     // from native so as to resolve the jthread.
 
     ThreadInVMfromNative __tiv(current_thread);
+    Thread::WXExecVerifier __wx_exec;
     VM_ENTRY_BASE(jvmtiError, JvmtiEnv::GetThreadLocalStorage , current_thread)
     debug_only(VMNativeEntryWrapper __vew;)
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jvmtiExport.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jvmtiExport.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jvmtiExport.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jvmtiExport.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -81,12 +81,14 @@ class JvmtiJavaThreadEventTransition : S
 private:
   ResourceMark _rm;
   ThreadToNativeFromVM _transition;
+  Thread::WXExecFromWriteSetter _wx_exec;
   HandleMark _hm;
 
 public:
   JvmtiJavaThreadEventTransition(JavaThread *thread) :
     _rm(),
     _transition(thread),
+    _wx_exec(),
     _hm(thread)  {};
 };
 
@@ -96,11 +98,12 @@ class JvmtiThreadEventTransition : Stack
 private:
   ResourceMark _rm;
   HandleMark _hm;
+  Thread::WXExecFromWriteSetter _wx_exec;
   JavaThreadState _saved_state;
   JavaThread *_jthread;
 
 public:
-  JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm() {
+  JvmtiThreadEventTransition(Thread *thread) : _rm(), _hm(), _wx_exec() {
     if (thread->is_Java_thread()) {
        _jthread = (JavaThread *)thread;
        _saved_state = _jthread->thread_state();
@@ -387,6 +390,7 @@ JvmtiExport::get_jvmti_interface(JavaVM 
     JavaThread* current_thread = JavaThread::current();
     // transition code: native to VM
     ThreadInVMfromNative __tiv(current_thread);
+    Thread::WXExecVerifier __wx_exec;
     VM_ENTRY_BASE(jvmtiEnv*, JvmtiExport::get_jvmti_interface, current_thread)
     debug_only(VMNativeEntryWrapper __vew;)
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jvmtiExtensions.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jvmtiExtensions.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jvmtiExtensions.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jvmtiExtensions.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -34,7 +34,14 @@ GrowableArray<jvmtiExtensionEventInfo*>*
 
 
 // extension function
-static jvmtiError JNICALL IsClassUnloadingEnabled(const jvmtiEnv* env, jboolean* enabled, ...) {
+static jvmtiError JNICALL IsClassUnloadingEnabled(const jvmtiEnv* env, ...) {
+  jboolean* enabled = NULL;
+  va_list ap;
+
+  va_start(ap, env);
+  enabled = va_arg(ap, jboolean *);
+  va_end(ap);
+
   if (enabled == NULL) {
     return JVMTI_ERROR_NULL_POINTER;
   }
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jvmtiImpl.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jvmtiImpl.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/jvmtiImpl.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/jvmtiImpl.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -82,6 +82,7 @@ JvmtiAgentThread::start_function_wrapper
 void
 JvmtiAgentThread::call_start_function() {
     ThreadToNativeFromVM transition(this);
+    Thread::WXExecFromWriteSetter wx_exec;
     _start_fn(_env->jvmti_external(), jni_environment(), (void*)_start_arg);
 }
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/methodHandles.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/methodHandles.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/methodHandles.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/methodHandles.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1591,6 +1591,7 @@ JVM_ENTRY(void, JVM_RegisterMethodHandle
 
   {
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
 
     int status = env->RegisterNatives(MHN_class, MHN_methods, sizeof(MHN_methods)/sizeof(JNINativeMethod));
     guarantee(status == JNI_OK && !env->ExceptionOccurred(),
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/nativeLookup.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/nativeLookup.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/nativeLookup.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/nativeLookup.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -397,6 +397,7 @@ address NativeLookup::lookup_critical_en
 
   // dll handling requires I/O. Don't do that while in _thread_in_vm (safepoint may get requested).
   ThreadToNativeFromVM thread_in_native(JavaThread::current());
+  Thread::WXWriteVerifier wx_write;
 
   void* dll = dll_load(method);
   address entry = NULL;
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/perf.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/perf.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/perf.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/perf.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -54,6 +54,8 @@ static char* jstr_to_utf(JNIEnv *env, js
     //throw_new(env,"NullPointerException");
   }
 
+  Thread::WXExecFromWriteSetter wx_exec;
+
   int len = env->GetStringUTFLength(str);
   int unicode_len = env->GetStringLength(str);
 
@@ -91,6 +93,7 @@ PERF_ENTRY(jobject, Perf_Attach(JNIEnv *
 
   {
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return env->NewDirectByteBuffer(address, (jlong)capacity);
   }
 
@@ -111,6 +114,7 @@ PERF_ENTRY(void, Perf_Detach(JNIEnv *env
   // get buffer address and capacity
   {
    ThreadToNativeFromVM ttnfv(thread);
+   Thread::WXExecFromWriteSetter wx_exec;
    address = env->GetDirectBufferAddress(buffer);
    capacity = env->GetDirectBufferCapacity(buffer);
   }
@@ -175,6 +179,7 @@ PERF_ENTRY(jobject, Perf_CreateLong(JNIE
 
   {
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return env->NewDirectByteBuffer(lp, sizeof(jlong));
   }
 
@@ -217,6 +222,8 @@ PERF_ENTRY(jobject, Perf_CreateByteArray
 
     name_utf = jstr_to_utf(env, name, CHECK_NULL);
 
+    Thread::WXExecFromWriteSetter wx_exec;
+
     value_length = env->GetArrayLength(value);
 
     value_local = NEW_RESOURCE_ARRAY(jbyte, value_length + 1);
@@ -258,6 +265,7 @@ PERF_ENTRY(jobject, Perf_CreateByteArray
 
   {
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return env->NewDirectByteBuffer(cp, maxlength+1);
   }
 
@@ -320,6 +328,7 @@ JVM_ENTRY(void, JVM_RegisterPerfMethods(
   PerfWrapper("JVM_RegisterPerfMethods");
   {
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     int ok = env->RegisterNatives(perfclass, perfmethods, sizeof(perfmethods)/sizeof(JNINativeMethod));
     guarantee(ok == 0, "register perf natives");
   }
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/unsafe.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/unsafe.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/unsafe.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/unsafe.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -364,6 +364,7 @@ UNSAFE_LEAF(void, Unsafe_FullFence(JNIEn
 
 UNSAFE_ENTRY(jobject, Unsafe_AllocateInstance(JNIEnv *env, jobject unsafe, jclass cls)) {
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   return env->AllocObject(cls);
 } UNSAFE_END
 
@@ -679,6 +680,7 @@ static jclass Unsafe_DefineClass_impl(JN
 
 UNSAFE_ENTRY(jclass, Unsafe_DefineClass0(JNIEnv *env, jobject unsafe, jstring name, jbyteArray data, int offset, int length, jobject loader, jobject pd)) {
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
 
   return Unsafe_DefineClass_impl(env, name, data, offset, length, loader, pd);
 } UNSAFE_END
@@ -859,6 +861,7 @@ UNSAFE_ENTRY(jclass, Unsafe_DefineAnonym
 
 UNSAFE_ENTRY(void, Unsafe_ThrowException(JNIEnv *env, jobject unsafe, jthrowable thr)) {
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   env->Throw(thr);
 } UNSAFE_END
 
@@ -1127,6 +1130,7 @@ static JNINativeMethod jdk_internal_misc
 
 JVM_ENTRY(void, JVM_RegisterJDKInternalMiscUnsafeMethods(JNIEnv *env, jclass unsafeclass)) {
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
 
   int ok = env->RegisterNatives(unsafeclass, jdk_internal_misc_Unsafe_methods, sizeof(jdk_internal_misc_Unsafe_methods)/sizeof(JNINativeMethod));
   guarantee(ok == 0, "register jdk.internal.misc.Unsafe natives");
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/whitebox.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/whitebox.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/prims/whitebox.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/prims/whitebox.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -640,7 +640,7 @@ WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv
 WB_END
 
 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
-  os::uncommit_memory((char *)(uintptr_t)addr, size);
+  os::uncommit_memory((char *)(uintptr_t)addr, size, !ExecMem);
 WB_END
 
 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
@@ -703,6 +703,7 @@ WB_END
 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
   assert(method != NULL, "method should not be null");
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   return env->FromReflectedMethod(method);
 }
 
@@ -1062,6 +1063,7 @@ static bool GetVMFlag(JavaThread* thread
     return false;
   }
   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* flag_name = env->GetStringUTFChars(name, NULL);
   CHECK_JNI_EXCEPTION_(env, false);
   JVMFlag::Error result = (*TAt)(flag_name, value, true, true);
@@ -1075,6 +1077,7 @@ static bool SetVMFlag(JavaThread* thread
     return false;
   }
   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* flag_name = env->GetStringUTFChars(name, NULL);
   CHECK_JNI_EXCEPTION_(env, false);
   JVMFlag::Error result = (*TAtPut)(flag_name, value, JVMFlag::INTERNAL);
@@ -1114,6 +1117,7 @@ static jobject doubleBox(JavaThread* thr
 
 static JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {
   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* flag_name = env->GetStringUTFChars(name, NULL);
   CHECK_JNI_EXCEPTION_(env, NULL);
   JVMFlag* result = JVMFlag::find_flag(flag_name, strlen(flag_name), true, true);
@@ -1135,6 +1139,7 @@ WB_ENTRY(jobject, WB_GetBooleanVMFlag(JN
   bool result;
   if (GetVMFlag <bool> (thread, env, name, &result, &JVMFlag::boolAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return booleanBox(thread, env, result);
   }
   return NULL;
@@ -1144,6 +1149,7 @@ WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv
   int result;
   if (GetVMFlag <int> (thread, env, name, &result, &JVMFlag::intAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1153,6 +1159,7 @@ WB_ENTRY(jobject, WB_GetUintVMFlag(JNIEn
   uint result;
   if (GetVMFlag <uint> (thread, env, name, &result, &JVMFlag::uintAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1162,6 +1169,7 @@ WB_ENTRY(jobject, WB_GetIntxVMFlag(JNIEn
   intx result;
   if (GetVMFlag <intx> (thread, env, name, &result, &JVMFlag::intxAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1171,6 +1179,7 @@ WB_ENTRY(jobject, WB_GetUintxVMFlag(JNIE
   uintx result;
   if (GetVMFlag <uintx> (thread, env, name, &result, &JVMFlag::uintxAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1180,6 +1189,7 @@ WB_ENTRY(jobject, WB_GetUint64VMFlag(JNI
   uint64_t result;
   if (GetVMFlag <uint64_t> (thread, env, name, &result, &JVMFlag::uint64_tAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1189,6 +1199,7 @@ WB_ENTRY(jobject, WB_GetSizeTVMFlag(JNIE
   size_t result;
   if (GetVMFlag <size_t> (thread, env, name, &result, &JVMFlag::size_tAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1198,6 +1209,7 @@ WB_ENTRY(jobject, WB_GetDoubleVMFlag(JNI
   double result;
   if (GetVMFlag <double> (thread, env, name, &result, &JVMFlag::doubleAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     return doubleBox(thread, env, result);
   }
   return NULL;
@@ -1207,6 +1219,7 @@ WB_ENTRY(jstring, WB_GetStringVMFlag(JNI
   ccstr ccstrResult;
   if (GetVMFlag <ccstr> (thread, env, name, &ccstrResult, &JVMFlag::ccstrAt)) {
     ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+    Thread::WXExecFromWriteSetter wx_exec;
     jstring result = env->NewStringUTF(ccstrResult);
     CHECK_JNI_EXCEPTION_(env, NULL);
     return result;
@@ -1256,6 +1269,7 @@ WB_END
 
 WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring value))
   ThreadToNativeFromVM ttnfv(thread);   // can't be in VM when we call JNI
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* ccstrValue;
   if (value == NULL) {
     ccstrValue = NULL;
@@ -1332,6 +1346,7 @@ WB_END
 WB_ENTRY(jstring, WB_GetCPUFeatures(JNIEnv* env, jobject o))
   const char* features = VM_Version::features_string();
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   jstring features_string = env->NewStringUTF(features);
 
   CHECK_JNI_EXCEPTION_(env, NULL);
@@ -1404,6 +1419,7 @@ WB_ENTRY(jobjectArray, WB_GetNMethod(JNI
   int insts_size = comp_level == CompLevel_aot ? code->code_end() - code->code_begin() : code->insts_size();
 
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   jclass clazz = env->FindClass(vmSymbols::java_lang_Object()->as_C_string());
   CHECK_JNI_EXCEPTION_(env, NULL);
   result = env->NewObjectArray(5, clazz, NULL);
@@ -1487,6 +1503,7 @@ WB_ENTRY(jobjectArray, WB_GetCodeHeapEnt
     }
   }
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   jobjectArray result = NULL;
   jclass clazz = env->FindClass(vmSymbols::java_lang_Object()->as_C_string());
   CHECK_JNI_EXCEPTION_(env, NULL);
@@ -1517,6 +1534,7 @@ WB_ENTRY(jobjectArray, WB_GetCodeBlob(JN
       "WB_GetCodeBlob: addr is null");
   }
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   CodeBlobStub stub((CodeBlob*) addr);
   return codeBlob2objectArray(thread, env, &stub);
 WB_END
@@ -1727,6 +1745,7 @@ static bool GetMethodOption(JavaThread* 
   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
   // can't be in VM when we call JNI
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* flag_name = env->GetStringUTFChars(name, NULL);
   CHECK_JNI_EXCEPTION_(env, false);
   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
@@ -1739,6 +1758,7 @@ WB_ENTRY(jobject, WB_GetMethodBooleaneOp
   if (GetMethodOption<bool> (thread, env, method, name, &result)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return booleanBox(thread, env, result);
   }
   return NULL;
@@ -1749,6 +1769,7 @@ WB_ENTRY(jobject, WB_GetMethodIntxOption
   if (GetMethodOption <intx> (thread, env, method, name, &result)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1759,6 +1780,7 @@ WB_ENTRY(jobject, WB_GetMethodUintxOptio
   if (GetMethodOption <uintx> (thread, env, method, name, &result)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return longBox(thread, env, result);
   }
   return NULL;
@@ -1769,6 +1791,7 @@ WB_ENTRY(jobject, WB_GetMethodDoubleOpti
   if (GetMethodOption <double> (thread, env, method, name, &result)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     return doubleBox(thread, env, result);
   }
   return NULL;
@@ -1779,6 +1802,7 @@ WB_ENTRY(jobject, WB_GetMethodStringOpti
   if (GetMethodOption <ccstr> (thread, env, method, name, &ccstrResult)) {
     // can't be in VM when we call JNI
     ThreadToNativeFromVM ttnfv(thread);
+    Thread::WXExecFromWriteSetter wx_exec;
     jstring result = env->NewStringUTF(ccstrResult);
     CHECK_JNI_EXCEPTION_(env, NULL);
     return result;
@@ -1940,6 +1964,7 @@ bool WhiteBox::lookup_bool(const char* f
 void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread, JNINativeMethod* method_array, int method_count) {
   ResourceMark rm;
   ThreadToNativeFromVM ttnfv(thread); // can't be in VM when we call JNI
+  Thread::WXExecFromWriteSetter wx_exec;
 
   //  one by one registration natives for exception catching
   jclass no_such_method_error_klass = env->FindClass(vmSymbols::java_lang_NoSuchMethodError()->as_C_string());
@@ -1971,11 +1996,13 @@ void WhiteBox::register_methods(JNIEnv* 
 WB_ENTRY(jint, WB_AddCompilerDirective(JNIEnv* env, jobject o, jstring compDirect))
   // can't be in VM when we call JNI
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* dir = env->GetStringUTFChars(compDirect, NULL);
   CHECK_JNI_EXCEPTION_(env, 0);
   int ret;
   {
     ThreadInVMfromNative ttvfn(thread); // back to VM
+    Thread::WXExecVerifier wx_exec;
     ret = DirectivesParser::parse_string(dir, tty);
   }
   env->ReleaseStringUTFChars(compDirect, dir);
@@ -1996,6 +2023,7 @@ WB_ENTRY(jboolean, WB_CheckLibSpecifiesN
 #ifdef LINUX
   // Can't be in VM when we call JNI.
   ThreadToNativeFromVM ttnfv(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   const char* lf = env->GetStringUTFChars(libfile, NULL);
   CHECK_JNI_EXCEPTION_(env, 0);
   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/abstract_vm_version.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/abstract_vm_version.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/abstract_vm_version.cpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/abstract_vm_version.cpp	2021-01-16 16:04:21.000000000 +0100
@@ -0,0 +1,394 @@
+/*
+ * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/*
+ * This file has been modified by Azul Systems, Inc. in 2018. These
+ * modifications are Copyright (c) 2018 Azul Systems, Inc., and are made
+ * available on the same license terms set forth above.
+ */
+
+#include "precompiled.hpp"
+#include "compiler/compilerDefinitions.hpp"
+#include "runtime/arguments.hpp"
+#include "runtime/vm_version.hpp"
+#include "utilities/globalDefinitions.hpp"
+
+const char* Abstract_VM_Version::_s_vm_release = Abstract_VM_Version::vm_release();
+const char* Abstract_VM_Version::_s_internal_vm_info_string = Abstract_VM_Version::internal_vm_info_string();
+
+uint64_t Abstract_VM_Version::_features = 0;
+const char* Abstract_VM_Version::_features_string = "";
+
+bool Abstract_VM_Version::_supports_cx8 = false;
+bool Abstract_VM_Version::_supports_atomic_getset4 = false;
+bool Abstract_VM_Version::_supports_atomic_getset8 = false;
+bool Abstract_VM_Version::_supports_atomic_getadd4 = false;
+bool Abstract_VM_Version::_supports_atomic_getadd8 = false;
+unsigned int Abstract_VM_Version::_logical_processors_per_package = 1U;
+unsigned int Abstract_VM_Version::_L1_data_cache_line_size = 0;
+
+VirtualizationType Abstract_VM_Version::_detected_virtualization = NoDetectedVirtualization;
+
+#ifndef HOTSPOT_VERSION_STRING
+  #error HOTSPOT_VERSION_STRING must be defined
+#endif
+
+#ifndef VERSION_FEATURE
+  #error VERSION_FEATURE must be defined
+#endif
+#ifndef VERSION_INTERIM
+  #error VERSION_INTERIM must be defined
+#endif
+#ifndef VERSION_UPDATE
+  #error VERSION_UPDATE must be defined
+#endif
+#ifndef VERSION_PATCH
+  #error VERSION_PATCH must be defined
+#endif
+#ifndef VERSION_BUILD
+  #error VERSION_BUILD must be defined
+#endif
+
+#ifndef VERSION_STRING
+  #error VERSION_STRING must be defined
+#endif
+
+#ifndef DEBUG_LEVEL
+  #error DEBUG_LEVEL must be defined
+#endif
+
+#define VM_RELEASE HOTSPOT_VERSION_STRING
+
+// HOTSPOT_VERSION_STRING equals the JDK VERSION_STRING (unless overridden
+// in a standalone build).
+int Abstract_VM_Version::_vm_major_version = VERSION_FEATURE;
+int Abstract_VM_Version::_vm_minor_version = VERSION_INTERIM;
+int Abstract_VM_Version::_vm_security_version = VERSION_UPDATE;
+int Abstract_VM_Version::_vm_patch_version = VERSION_PATCH;
+int Abstract_VM_Version::_vm_build_number = VERSION_BUILD;
+unsigned int Abstract_VM_Version::_parallel_worker_threads = 0;
+bool Abstract_VM_Version::_parallel_worker_threads_initialized = false;
+
+#if defined(_LP64)
+  #define VMLP "64-Bit "
+#else
+  #define VMLP ""
+#endif
+
+#ifndef VMTYPE
+  #ifdef TIERED
+    #define VMTYPE "Server"
+  #else // TIERED
+  #ifdef ZERO
+    #define VMTYPE "Zero"
+  #else // ZERO
+     #define VMTYPE COMPILER1_PRESENT("Client")   \
+                    COMPILER2_PRESENT("Server")
+  #endif // ZERO
+  #endif // TIERED
+#endif
+
+#ifndef HOTSPOT_VM_DISTRO
+  #error HOTSPOT_VM_DISTRO must be defined
+#endif
+#define VMNAME HOTSPOT_VM_DISTRO " " VMLP VMTYPE " VM"
+
+const char* Abstract_VM_Version::vm_name() {
+  return VMNAME;
+}
+
+
+const char* Abstract_VM_Version::vm_vendor() {
+#ifdef VENDOR
+  return VENDOR;
+#else
+  return "JetBrains s.r.o";
+#endif
+}
+
+
+const char* Abstract_VM_Version::vm_info_string() {
+  switch (Arguments::mode()) {
+    case Arguments::_int:
+      return UseSharedSpaces ? "interpreted mode, sharing" : "interpreted mode";
+    case Arguments::_mixed:
+      if (UseSharedSpaces) {
+        if (UseAOT) {
+          return "mixed mode, aot, sharing";
+#ifdef TIERED
+        } else if(is_client_compilation_mode_vm()) {
+          return "mixed mode, emulated-client, sharing";
+#endif
+        } else {
+          return "mixed mode, sharing";
+         }
+      } else {
+        if (UseAOT) {
+          return "mixed mode, aot";
+#ifdef TIERED
+        } else if(is_client_compilation_mode_vm()) {
+          return "mixed mode, emulated-client";
+#endif
+        } else {
+          return "mixed mode";
+        }
+      }
+    case Arguments::_comp:
+#ifdef TIERED
+      if (is_client_compilation_mode_vm()) {
+         return UseSharedSpaces ? "compiled mode, emulated-client, sharing" : "compiled mode, emulated-client";
+      }
+#endif
+      return UseSharedSpaces ? "compiled mode, sharing"    : "compiled mode";
+  };
+  ShouldNotReachHere();
+  return "";
+}
+
+// NOTE: do *not* use stringStream. this function is called by
+//       fatal error handler. if the crash is in native thread,
+//       stringStream cannot get resource allocated and will SEGV.
+const char* Abstract_VM_Version::vm_release() {
+  return VM_RELEASE;
+}
+
+// NOTE: do *not* use stringStream. this function is called by
+//       fatal error handlers. if the crash is in native thread,
+//       stringStream cannot get resource allocated and will SEGV.
+const char* Abstract_VM_Version::jre_release_version() {
+  return VERSION_STRING;
+}
+
+#define OS       LINUX_ONLY("linux")             \
+                 WINDOWS_ONLY("windows")         \
+                 SOLARIS_ONLY("solaris")         \
+                 AIX_ONLY("aix")                 \
+                 BSD_ONLY("bsd")
+
+#ifndef CPU
+#ifdef ZERO
+#define CPU      ZERO_LIBARCH
+#elif defined(PPC64)
+#if defined(VM_LITTLE_ENDIAN)
+#define CPU      "ppc64le"
+#else
+#define CPU      "ppc64"
+#endif // PPC64
+#else
+#define CPU      AARCH64_ONLY("aarch64")         \
+                 AMD64_ONLY("amd64")             \
+                 IA32_ONLY("x86")                \
+                 IA64_ONLY("ia64")               \
+                 S390_ONLY("s390")               \
+                 SPARC_ONLY("sparc")
+#endif // !ZERO
+#endif // !CPU
+
+const char *Abstract_VM_Version::vm_platform_string() {
+  return OS "-" CPU;
+}
+
+const char* Abstract_VM_Version::internal_vm_info_string() {
+  #ifndef HOTSPOT_BUILD_USER
+    #define HOTSPOT_BUILD_USER unknown
+  #endif
+
+  #ifndef HOTSPOT_BUILD_COMPILER
+    #ifdef _MSC_VER
+      #if _MSC_VER == 1600
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 10.0 (VS2010)"
+      #elif _MSC_VER == 1700
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 11.0 (VS2012)"
+      #elif _MSC_VER == 1800
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 12.0 (VS2013)"
+      #elif _MSC_VER == 1900
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 14.0 (VS2015)"
+      #elif _MSC_VER == 1911
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 15.3 (VS2017)"
+      #elif _MSC_VER == 1912
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 15.5 (VS2017)"
+      #elif _MSC_VER == 1913
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 15.6 (VS2017)"
+      #elif _MSC_VER == 1914
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 15.7 (VS2017)"
+      #elif _MSC_VER == 1915
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 15.8 (VS2017)"
+      #elif _MSC_VER == 1916
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 15.9 (VS2017)"
+      #elif _MSC_VER == 1920
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 16.0 (VS2019)"
+      #elif _MSC_VER == 1921
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 16.1 (VS2019)"
+      #elif _MSC_VER == 1922
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 16.2 (VS2019)"
+      #elif _MSC_VER == 1923
+        #define HOTSPOT_BUILD_COMPILER "MS VC++ 16.3 (VS2019)"
+      #else
+        #define HOTSPOT_BUILD_COMPILER "unknown MS VC++:" XSTR(_MSC_VER)
+      #endif
+    #elif defined(__SUNPRO_CC)
+      #if   __SUNPRO_CC == 0x420
+        #define HOTSPOT_BUILD_COMPILER "Workshop 4.2"
+      #elif __SUNPRO_CC == 0x500
+        #define HOTSPOT_BUILD_COMPILER "Workshop 5.0 compat=" XSTR(__SUNPRO_CC_COMPAT)
+      #elif __SUNPRO_CC == 0x520
+        #define HOTSPOT_BUILD_COMPILER "Workshop 5.2 compat=" XSTR(__SUNPRO_CC_COMPAT)
+      #elif __SUNPRO_CC == 0x580
+        #define HOTSPOT_BUILD_COMPILER "Workshop 5.8"
+      #elif __SUNPRO_CC == 0x590
+        #define HOTSPOT_BUILD_COMPILER "Workshop 5.9"
+      #elif __SUNPRO_CC == 0x5100
+        #define HOTSPOT_BUILD_COMPILER "Sun Studio 12u1"
+      #elif __SUNPRO_CC == 0x5120
+        #define HOTSPOT_BUILD_COMPILER "Sun Studio 12u3"
+      #elif __SUNPRO_CC == 0x5130
+        #define HOTSPOT_BUILD_COMPILER "Sun Studio 12u4"
+      #else
+        #define HOTSPOT_BUILD_COMPILER "unknown Workshop:" XSTR(__SUNPRO_CC)
+      #endif
+    #elif defined(__GNUC__)
+        #define HOTSPOT_BUILD_COMPILER "gcc " __VERSION__
+    #elif defined(__IBMCPP__)
+        #define HOTSPOT_BUILD_COMPILER "xlC " XSTR(__IBMCPP__)
+
+    #else
+      #define HOTSPOT_BUILD_COMPILER "unknown compiler"
+    #endif
+  #endif
+
+  #ifndef FLOAT_ARCH
+    #if defined(__SOFTFP__)
+      #define FLOAT_ARCH_STR "-sflt"
+    #else
+      #define FLOAT_ARCH_STR ""
+    #endif
+  #else
+    #define FLOAT_ARCH_STR XSTR(FLOAT_ARCH)
+  #endif
+
+  #define INTERNAL_VERSION_SUFFIX VM_RELEASE ")" \
+         " for " OS "-" CPU FLOAT_ARCH_STR \
+         " JRE (" VERSION_STRING "), built on " __DATE__ " " __TIME__ \
+         " by " XSTR(HOTSPOT_BUILD_USER) " with " HOTSPOT_BUILD_COMPILER
+
+  return strcmp(DEBUG_LEVEL, "release") == 0
+      ? VMNAME " (" INTERNAL_VERSION_SUFFIX
+      : VMNAME " (" DEBUG_LEVEL " " INTERNAL_VERSION_SUFFIX;
+}
+
+const char *Abstract_VM_Version::vm_build_user() {
+  return HOTSPOT_BUILD_USER;
+}
+
+const char *Abstract_VM_Version::jdk_debug_level() {
+  return DEBUG_LEVEL;
+}
+
+const char *Abstract_VM_Version::printable_jdk_debug_level() {
+  // Debug level is not printed for "release" builds
+  return strcmp(DEBUG_LEVEL, "release") == 0 ? "" : DEBUG_LEVEL " ";
+}
+
+unsigned int Abstract_VM_Version::jvm_version() {
+  return ((Abstract_VM_Version::vm_major_version() & 0xFF) << 24) |
+         ((Abstract_VM_Version::vm_minor_version() & 0xFF) << 16) |
+         ((Abstract_VM_Version::vm_security_version() & 0xFF) << 8) |
+         (Abstract_VM_Version::vm_build_number() & 0xFF);
+}
+
+bool Abstract_VM_Version::print_matching_lines_from_file(const char* filename, outputStream* st, const char* keywords_to_match[]) {
+  char line[500];
+  FILE* fp = fopen(filename, "r");
+  if (fp == NULL) {
+    return false;
+  }
+
+  st->print_cr("Virtualization information:");
+  while (fgets(line, sizeof(line), fp) != NULL) {
+    int i = 0;
+    while (keywords_to_match[i] != NULL) {
+      if (strncmp(line, keywords_to_match[i], strlen(keywords_to_match[i])) == 0) {
+        st->print("%s", line);
+        break;
+      }
+      i++;
+    }
+  }
+  fclose(fp);
+  return true;
+}
+
+
+
+unsigned int Abstract_VM_Version::nof_parallel_worker_threads(
+                                                      unsigned int num,
+                                                      unsigned int den,
+                                                      unsigned int switch_pt) {
+  if (FLAG_IS_DEFAULT(ParallelGCThreads)) {
+    assert(ParallelGCThreads == 0, "Default ParallelGCThreads is not 0");
+    unsigned int threads;
+    // For very large machines, there are diminishing returns
+    // for large numbers of worker threads.  Instead of
+    // hogging the whole system, use a fraction of the workers for every
+    // processor after the first 8.  For example, on a 72 cpu machine
+    // and a chosen fraction of 5/8
+    // use 8 + (72 - 8) * (5/8) == 48 worker threads.
+    unsigned int ncpus = (unsigned int) os::initial_active_processor_count();
+    threads = (ncpus <= switch_pt) ?
+             ncpus :
+             (switch_pt + ((ncpus - switch_pt) * num) / den);
+#ifndef _LP64
+    // On 32-bit binaries the virtual address space available to the JVM
+    // is usually limited to 2-3 GB (depends on the platform).
+    // Do not use up address space with too many threads (stacks and per-thread
+    // data). Note that x86 apps running on Win64 have 2 stacks per thread.
+    // GC may more generally scale down threads by max heap size (etc), but the
+    // consequences of over-provisioning threads are higher on 32-bit JVMS,
+    // so add hard limit here:
+    threads = MIN2(threads, (2*switch_pt));
+#endif
+    return threads;
+  } else {
+    return ParallelGCThreads;
+  }
+}
+
+unsigned int Abstract_VM_Version::calc_parallel_worker_threads() {
+  return nof_parallel_worker_threads(5, 8, 8);
+}
+
+
+// Does not set the _initialized flag since it is
+// a global flag.
+unsigned int Abstract_VM_Version::parallel_worker_threads() {
+  if (!_parallel_worker_threads_initialized) {
+    if (FLAG_IS_DEFAULT(ParallelGCThreads)) {
+      _parallel_worker_threads = VM_Version::calc_parallel_worker_threads();
+    } else {
+      _parallel_worker_threads = ParallelGCThreads;
+    }
+    _parallel_worker_threads_initialized = true;
+  }
+  return _parallel_worker_threads;
+}
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/abstract_vm_version.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/abstract_vm_version.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/abstract_vm_version.hpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/abstract_vm_version.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,189 @@
+/*
+ * Copyright (c) 1997, 2000, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_RUNTIME_ABSTRACT_VM_VERSION_HPP
+#define SHARE_RUNTIME_ABSTRACT_VM_VERSION_HPP
+
+#include "memory/allocation.hpp"  // For declaration of class AllStatic
+#include "utilities/globalDefinitions.hpp"
+
+typedef enum {
+  NoDetectedVirtualization,
+  XenHVM,
+  KVM,
+  VMWare,
+  HyperV,
+  HyperVRole,
+  PowerVM, // on AIX or Linux ppc64(le)
+  PowerFullPartitionMode, // on Linux ppc64(le)
+  PowerKVM
+} VirtualizationType;
+
+// Abstract_VM_Version provides information about the VM.
+
+class Abstract_VM_Version: AllStatic {
+  friend class VMStructs;
+  friend class JVMCIVMStructs;
+
+ protected:
+  static const char*  _s_vm_release;
+  static const char*  _s_internal_vm_info_string;
+
+  // CPU feature flags.
+  static uint64_t _features;
+  static const char* _features_string;
+
+  // These are set by machine-dependent initializations
+  static bool         _supports_cx8;
+  static bool         _supports_atomic_getset4;
+  static bool         _supports_atomic_getset8;
+  static bool         _supports_atomic_getadd4;
+  static bool         _supports_atomic_getadd8;
+  static unsigned int _logical_processors_per_package;
+  static unsigned int _L1_data_cache_line_size;
+  static int          _vm_major_version;
+  static int          _vm_minor_version;
+  static int          _vm_security_version;
+  static int          _vm_patch_version;
+  static int          _vm_build_number;
+
+  static VirtualizationType _detected_virtualization;
+
+  static unsigned int _parallel_worker_threads;
+  static bool         _parallel_worker_threads_initialized;
+
+  static unsigned int nof_parallel_worker_threads(unsigned int num,
+                                                  unsigned int dem,
+                                                  unsigned int switch_pt);
+
+public:
+  // Called as part of the runtime services initialization which is
+  // called from the management module initialization (via init_globals())
+  // after argument parsing and attaching of the main thread has
+  // occurred.  Examines a variety of the hardware capabilities of
+  // the platform to determine which features can be used to execute the
+  // program.
+  static void initialize();
+
+  // This allows for early initialization of VM_Version information
+  // that may be needed later in the initialization sequence but before
+  // full VM_Version initialization is possible. It can not depend on any
+  // other part of the VM being initialized when called. Platforms that
+  // need to specialize this define VM_Version::early_initialize().
+  static void early_initialize() { }
+
+  // Called to initialize VM variables needing initialization
+  // after command line parsing. Platforms that need to specialize
+  // this should define VM_Version::init_before_ergo().
+  static void init_before_ergo() {}
+
+  // Name
+  static const char* vm_name();
+  // Vendor
+  static const char* vm_vendor();
+  // VM version information string printed by launcher (java -version)
+  static const char* vm_info_string();
+  static const char* vm_release();
+  static const char* vm_platform_string();
+  static const char* vm_build_user();
+
+  static int vm_major_version()               { return _vm_major_version; }
+  static int vm_minor_version()               { return _vm_minor_version; }
+  static int vm_security_version()            { return _vm_security_version; }
+  static int vm_patch_version()               { return _vm_patch_version; }
+  static int vm_build_number()                { return _vm_build_number; }
+
+  // Gets the jvm_version_info.jvm_version defined in jvm.h
+  static unsigned int jvm_version();
+
+  // Internal version providing additional build information
+  static const char* internal_vm_info_string();
+  static const char* jre_release_version();
+  static const char* jdk_debug_level();
+  static const char* printable_jdk_debug_level();
+
+  static uint64_t features() {
+    return _features;
+  }
+
+  static const char* features_string() {
+    return _features_string;
+  }
+
+  static VirtualizationType get_detected_virtualization() {
+    return _detected_virtualization;
+  }
+
+  // platforms that need to specialize this
+  // define VM_Version::print_platform_virtualization_info()
+  static void print_platform_virtualization_info(outputStream*) { }
+
+  // does HW support an 8-byte compare-exchange operation?
+  static bool supports_cx8()  {
+#ifdef SUPPORTS_NATIVE_CX8
+    return true;
+#else
+    return _supports_cx8;
+#endif
+  }
+  // does HW support atomic get-and-set or atomic get-and-add?  Used
+  // to guide intrinsification decisions for Unsafe atomic ops
+  static bool supports_atomic_getset4()  {return _supports_atomic_getset4;}
+  static bool supports_atomic_getset8()  {return _supports_atomic_getset8;}
+  static bool supports_atomic_getadd4()  {return _supports_atomic_getadd4;}
+  static bool supports_atomic_getadd8()  {return _supports_atomic_getadd8;}
+
+  static unsigned int logical_processors_per_package() {
+    return _logical_processors_per_package;
+  }
+
+  static unsigned int L1_data_cache_line_size() {
+    return _L1_data_cache_line_size;
+  }
+
+  // ARCH specific policy for the BiasedLocking
+  static bool use_biased_locking()  { return true; }
+
+  // Number of page sizes efficiently supported by the hardware.  Most chips now
+  // support two sizes, thus this default implementation.  Processor-specific
+  // subclasses should define new versions to hide this one as needed.  Note
+  // that the O/S may support more sizes, but at most this many are used.
+  static uint page_size_count() { return 2; }
+
+  // Returns the number of parallel threads to be used for VM
+  // work.  If that number has not been calculated, do so and
+  // save it.  Returns ParallelGCThreads if it is set on the
+  // command line.
+  static unsigned int parallel_worker_threads();
+  // Calculates and returns the number of parallel threads.  May
+  // be VM version specific.
+  static unsigned int calc_parallel_worker_threads();
+
+  // Does this CPU support spin wait instruction?
+  static bool supports_on_spin_wait() { return false; }
+
+  static bool print_matching_lines_from_file(const char* filename, outputStream* st, const char* keywords_to_match[]);
+};
+
+#endif // SHARE_RUNTIME_ABSTRACT_VM_VERSION_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/deoptimization.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/deoptimization.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/deoptimization.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/deoptimization.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -2066,6 +2066,7 @@ Deoptimization::UnrollBlock* Deoptimizat
     // This enters VM and may safepoint
     uncommon_trap_inner(thread, trap_request);
   }
+  Thread::WXWriteFromExecSetter wx_write;
   return fetch_unroll_info_helper(thread, exec_mode);
 }
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/interfaceSupport.inline.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/interfaceSupport.inline.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/interfaceSupport.inline.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/interfaceSupport.inline.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -311,8 +311,9 @@ class ThreadBlockInVM : public ThreadSta
 // from being installed on vm exit in situations where we can't tolerate them.
 // See bugs: 4324348, 4854693, 4998314, 5040492, 5050705.
 class ThreadInVMfromJavaNoAsyncException : public ThreadStateTransition {
+  Thread::WXWriteVerifier _wx_write;
  public:
-  ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread) {
+  ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread), _wx_write() {
     trans_from_java(_thread_in_vm);
   }
   ~ThreadInVMfromJavaNoAsyncException()  {
@@ -440,6 +441,7 @@ class RuntimeHistogramElement : public H
 
 #define IRT_ENTRY(result_type, header)                               \
   result_type header {                                               \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromJava __tiv(thread);                                \
     VM_ENTRY_BASE(result_type, header, thread)                       \
     debug_only(VMEntryWrapper __vew;)
@@ -453,6 +455,7 @@ class RuntimeHistogramElement : public H
 
 #define IRT_ENTRY_NO_ASYNC(result_type, header)                      \
   result_type header {                                               \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
     VM_ENTRY_BASE(result_type, header, thread)                       \
     debug_only(VMEntryWrapper __vew;)
@@ -461,6 +464,7 @@ class RuntimeHistogramElement : public H
 
 #define JRT_ENTRY(result_type, header)                               \
   result_type header {                                               \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromJava __tiv(thread);                                \
     VM_ENTRY_BASE(result_type, header, thread)                       \
     debug_only(VMEntryWrapper __vew;)
@@ -474,6 +478,7 @@ class RuntimeHistogramElement : public H
 
 #define JRT_ENTRY_NO_ASYNC(result_type, header)                      \
   result_type header {                                               \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromJavaNoAsyncException __tiv(thread);                \
     VM_ENTRY_BASE(result_type, header, thread)                       \
     debug_only(VMEntryWrapper __vew;)
@@ -483,6 +488,7 @@ class RuntimeHistogramElement : public H
 #define JRT_BLOCK_ENTRY(result_type, header)                         \
   result_type header {                                               \
     TRACE_CALL(result_type, header)                                  \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     HandleMarkCleaner __hm(thread);
 
 #define JRT_BLOCK                                                    \
@@ -512,6 +518,7 @@ extern "C" {                            
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
     assert( !VerifyJNIEnvThread || (thread == Thread::current()), "JNIEnv is only valid in same thread"); \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
@@ -524,6 +531,7 @@ extern "C" {                            
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
     assert( !VerifyJNIEnvThread || (thread == Thread::current()), "JNIEnv is only valid in same thread"); \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_QUICK_ENTRY_BASE(result_type, header, thread)
@@ -534,6 +542,7 @@ extern "C" {                            
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
     assert( !VerifyJNIEnvThread || (thread == Thread::current()), "JNIEnv is only valid in same thread"); \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     VM_LEAF_BASE(result_type, header)
 
 
@@ -548,6 +557,7 @@ extern "C" {                            
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
@@ -557,6 +567,7 @@ extern "C" {                            
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread = JavaThread::current();                      \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_ENTRY_BASE(result_type, header, thread)
@@ -566,6 +577,7 @@ extern "C" {                            
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     JavaThread* thread=JavaThread::thread_from_jni_environment(env); \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     ThreadInVMfromNative __tiv(thread);                              \
     debug_only(VMNativeEntryWrapper __vew;)                          \
     VM_QUICK_ENTRY_BASE(result_type, header, thread)
@@ -575,6 +587,7 @@ extern "C" {                            
 extern "C" {                                                         \
   result_type JNICALL header {                                       \
     VM_Exit::block_if_vm_exited();                                   \
+    Thread::WXWriteFromExecSetter __wx_write;                        \
     VM_LEAF_BASE(result_type, header)
 
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/javaCalls.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/javaCalls.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/javaCalls.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/javaCalls.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -79,7 +79,6 @@ JavaCallWrapper::JavaCallWrapper(const m
     }
   }
 
-
   // Make sure to set the oop's after the thread transition - since we can block there. No one is GC'ing
   // the JavaCallWrapper before the entry frame is on the stack.
   _callee_method = callee_method();
@@ -113,12 +112,16 @@ JavaCallWrapper::JavaCallWrapper(const m
   if (_anchor.last_Java_sp() == NULL) {
     _thread->record_base_of_stack_pointer();
   }
+
+  Thread::enable_wx_from_write(WXExec);
 }
 
 
 JavaCallWrapper::~JavaCallWrapper() {
   assert(_thread == JavaThread::current(), "must still be the same thread");
 
+  Thread::enable_wx_from_exec(WXWrite);
+
   // restore previous handle block & Java frame linkage
   JNIHandleBlock *_old_handles = _thread->active_handles();
   _thread->set_active_handles(_handles);
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/objectMonitor.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/objectMonitor.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/objectMonitor.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/objectMonitor.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -40,7 +40,7 @@
 #include "runtime/osThread.hpp"
 #include "runtime/safepointMechanism.inline.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "services/threadService.hpp"
 #include "utilities/dtrace.hpp"
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/os.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/os.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/os.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/os.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -54,7 +54,7 @@
 #include "runtime/mutexLocker.hpp"
 #include "runtime/os.inline.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
 #include "runtime/vm_version.hpp"
@@ -1712,7 +1712,7 @@ bool os::create_stack_guard_pages(char* 
   return os::pd_create_stack_guard_pages(addr, bytes);
 }
 
-char* os::reserve_memory(size_t bytes, char* addr, size_t alignment_hint, int file_desc) {
+char* os::reserve_memory(size_t bytes, char* addr, size_t alignment_hint, int file_desc, bool executable) {
   char* result = NULL;
 
   if (file_desc != -1) {
@@ -1723,7 +1723,7 @@ char* os::reserve_memory(size_t bytes, c
       MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC);
     }
   } else {
-    result = pd_reserve_memory(bytes, addr, alignment_hint);
+    result = pd_reserve_memory(bytes, addr, alignment_hint, executable);
     if (result != NULL) {
       MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC);
     }
@@ -1793,16 +1793,16 @@ void os::commit_memory_or_exit(char* add
   MemTracker::record_virtual_memory_commit((address)addr, size, CALLER_PC);
 }
 
-bool os::uncommit_memory(char* addr, size_t bytes) {
+bool os::uncommit_memory(char* addr, size_t bytes, bool exec) {
   bool res;
   if (MemTracker::tracking_level() > NMT_minimal) {
     Tracker tkr(Tracker::uncommit);
-    res = pd_uncommit_memory(addr, bytes);
+    res = pd_uncommit_memory(addr, bytes, exec);
     if (res) {
       tkr.record((address)addr, bytes);
     }
   } else {
-    res = pd_uncommit_memory(addr, bytes);
+    res = pd_uncommit_memory(addr, bytes, exec);
   }
   return res;
 }
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/os.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/os.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/os.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/os.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -81,6 +81,11 @@ enum ThreadPriority {        // JLS 20.2
   CriticalPriority = 11      // Critical thread priority
 };
 
+enum WXMode {
+  WXWrite,
+  WXExec
+};
+
 // Executable parameter flag for os::commit_memory() and
 // os::commit_memory_or_exit().
 const bool ExecMem = true;
@@ -112,7 +117,8 @@ class os: AllStatic {
   }
 
   static char*  pd_reserve_memory(size_t bytes, char* addr = 0,
-                                  size_t alignment_hint = 0);
+                                  size_t alignment_hint = 0,
+                                  bool executable = false);
   static char*  pd_attempt_reserve_memory_at(size_t bytes, char* addr);
   static char*  pd_attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc);
   static void   pd_split_reserved_memory(char *base, size_t size,
@@ -127,7 +133,7 @@ class os: AllStatic {
   static void   pd_commit_memory_or_exit(char* addr, size_t size,
                                          size_t alignment_hint,
                                          bool executable, const char* mesg);
-  static bool   pd_uncommit_memory(char* addr, size_t bytes);
+  static bool   pd_uncommit_memory(char* addr, size_t bytes, bool exec);
   static bool   pd_release_memory(char* addr, size_t bytes);
 
   static char*  pd_map_memory(int fd, const char* file_name, size_t file_offset,
@@ -326,7 +332,8 @@ class os: AllStatic {
 
   static int    vm_allocation_granularity();
   static char*  reserve_memory(size_t bytes, char* addr = 0,
-                               size_t alignment_hint = 0, int file_desc = -1);
+                               size_t alignment_hint = 0, int file_desc = -1,
+                               bool executable = false);
   static char*  reserve_memory(size_t bytes, char* addr,
                                size_t alignment_hint, MEMFLAGS flags);
   static char*  reserve_memory_aligned(size_t size, size_t alignment, int file_desc = -1);
@@ -343,7 +350,7 @@ class os: AllStatic {
   static void   commit_memory_or_exit(char* addr, size_t size,
                                       size_t alignment_hint,
                                       bool executable, const char* mesg);
-  static bool   uncommit_memory(char* addr, size_t bytes);
+  static bool   uncommit_memory(char* addr, size_t bytes, bool exec);
   static bool   release_memory(char* addr, size_t bytes);
 
   // Touch memory pages that cover the memory range from start to end (exclusive)
@@ -953,6 +960,12 @@ class os: AllStatic {
     bool _done;
   };
 
+  // If the JVM is running in W^X mode, enable write or execute access to
+  // writeable and executable pages. No-op otherwise.
+  static inline void current_thread_enable_wx(WXMode mode) {
+    current_thread_enable_wx_impl(mode);
+  }
+
 #ifndef _WINDOWS
   // Suspend/resume support
   // Protocol:
@@ -1026,7 +1039,6 @@ class os: AllStatic {
   };
 #endif // !WINDOWS
 
-
  protected:
   static volatile unsigned int _rand_seed;    // seed for random number generator
   static int _processor_count;                // number of processors
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/safepoint.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/safepoint.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/safepoint.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/safepoint.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -954,6 +954,8 @@ void SafepointSynchronize::handle_pollin
     assert(SafepointSynchronize::is_synchronizing(), "polling encountered outside safepoint synchronization");
   }
 
+  Thread::WXWriteFromExecSetter wx_write;
+
   if (PrintSafepointStatistics) {
     inc_page_trap_count();
   }
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/sharedRuntime.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/sharedRuntime.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/sharedRuntime.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/sharedRuntime.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -517,6 +517,7 @@ address SharedRuntime::raw_exception_han
 
 
 JRT_LEAF(address, SharedRuntime::exception_handler_for_return_address(JavaThread* thread, address return_address))
+  Thread::WXWriteFromExecSetter wx_write;
   return raw_exception_handler_for_return_address(thread, return_address);
 JRT_END
 
@@ -1849,6 +1850,8 @@ bool SharedRuntime::should_fixup_call_de
 IRT_LEAF(void, SharedRuntime::fixup_callers_callsite(Method* method, address caller_pc))
   Method* moop(method);
 
+  Thread::WXWriteFromExecSetter wx_write;
+
   address entry_point = moop->from_compiled_entry_no_trampoline();
 
   // It's possible that deoptimization can occur at a call site which hasn't
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/signature.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/signature.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/signature.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/signature.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -282,16 +282,16 @@ class NativeSignatureIterator: public Si
   int          _prepended;             // number of prepended JNI parameters (1 JNIEnv, plus 1 mirror if static)
   int          _jni_offset;            // the current parameter offset, starting with 0
 
-  void do_bool  ()                     { pass_int();    _jni_offset++; _offset++;       }
-  void do_char  ()                     { pass_int();    _jni_offset++; _offset++;       }
+  void do_bool  ()                     { pass_byte();   _jni_offset++; _offset++;       }
+  void do_char  ()                     { pass_short();   _jni_offset++; _offset++;       }
   void do_float ()                     { pass_float();  _jni_offset++; _offset++;       }
 #ifdef _LP64
   void do_double()                     { pass_double(); _jni_offset++; _offset += 2;    }
 #else
   void do_double()                     { pass_double(); _jni_offset += 2; _offset += 2; }
 #endif
-  void do_byte  ()                     { pass_int();    _jni_offset++; _offset++;       }
-  void do_short ()                     { pass_int();    _jni_offset++; _offset++;       }
+  void do_byte  ()                     { pass_byte();   _jni_offset++; _offset++;       }
+  void do_short ()                     { pass_short();  _jni_offset++; _offset++;       }
   void do_int   ()                     { pass_int();    _jni_offset++; _offset++;       }
 #ifdef _LP64
   void do_long  ()                     { pass_long();   _jni_offset++; _offset += 2;    }
@@ -308,6 +308,8 @@ class NativeSignatureIterator: public Si
   int      jni_offset() const          { return _jni_offset + _prepended; }
 //  int     java_offset() const          { return method()->size_of_parameters() - _offset - 1; }
   bool      is_static() const          { return method()->is_static(); }
+  virtual void pass_byte()             { pass_int(); }
+  virtual void pass_short()            { pass_int(); }
   virtual void pass_int()              = 0;
   virtual void pass_long()             = 0;
   virtual void pass_object()           = 0;
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/stubRoutines.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/stubRoutines.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/stubRoutines.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/stubRoutines.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -30,7 +30,7 @@
 #include "runtime/interfaceSupport.inline.hpp"
 #include "runtime/timerTrace.hpp"
 #include "runtime/sharedRuntime.hpp"
-#include "runtime/stubRoutines.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "utilities/align.hpp"
 #include "utilities/copy.hpp"
 #include "utilities/vmError.hpp"
@@ -289,6 +289,8 @@ void StubRoutines::initialize2() {
 
 #ifdef ASSERT
 
+  os::current_thread_enable_wx(WXExec);
+
 #define TEST_ARRAYCOPY(type)                                                    \
   test_arraycopy_func(          type##_arraycopy(),          sizeof(type));     \
   test_arraycopy_func(          type##_disjoint_arraycopy(), sizeof(type));     \
@@ -369,6 +371,8 @@ void StubRoutines::initialize2() {
   test_safefetchN();
 #endif
 
+  os::current_thread_enable_wx(WXWrite);
+
 #endif
 }
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/stubRoutines.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/stubRoutines.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/stubRoutines.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/stubRoutines.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -458,24 +458,4 @@ class StubRoutines: AllStatic {
   static void arrayof_oop_copy_uninit(HeapWord* src, HeapWord* dest, size_t count);
 };
 
-// Safefetch allows to load a value from a location that's not known
-// to be valid. If the load causes a fault, the error value is returned.
-inline int SafeFetch32(int* adr, int errValue) {
-  assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
-  return StubRoutines::SafeFetch32_stub()(adr, errValue);
-}
-inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
-  assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
-  return StubRoutines::SafeFetchN_stub()(adr, errValue);
-}
-
-
-// returns true if SafeFetch32 and SafeFetchN can be used safely (stubroutines are already generated)
-inline bool CanUseSafeFetch32() {
-  return StubRoutines::SafeFetch32_stub() ? true : false;
-}
-
-inline bool CanUseSafeFetchN() {
-  return StubRoutines::SafeFetchN_stub() ? true : false;
-}
 #endif // SHARE_VM_RUNTIME_STUBROUTINES_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/stubRoutines.inline.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/stubRoutines.inline.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/stubRoutines.inline.hpp	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/stubRoutines.inline.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
+#define SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
+
+#include <runtime/thread.hpp>
+#include <runtime/stubRoutines.hpp>
+
+// Safefetch allows to load a value from a location that's not known
+// to be valid. If the load causes a fault, the error value is returned.
+inline int SafeFetch32(int* adr, int errValue) {
+  assert(StubRoutines::SafeFetch32_stub(), "stub not yet generated");
+  Thread::WXExecFromWriteSetter wx_exec;
+  return StubRoutines::SafeFetch32_stub()(adr, errValue);
+}
+inline intptr_t SafeFetchN(intptr_t* adr, intptr_t errValue) {
+  assert(StubRoutines::SafeFetchN_stub(), "stub not yet generated");
+  Thread::WXExecFromWriteSetter wx_exec;
+  return StubRoutines::SafeFetchN_stub()(adr, errValue);
+}
+
+
+// returns true if SafeFetch32 and SafeFetchN can be used safely (stubroutines are already generated)
+inline bool CanUseSafeFetch32() {
+  return StubRoutines::SafeFetch32_stub() ? true : false;
+}
+
+inline bool CanUseSafeFetchN() {
+  return StubRoutines::SafeFetchN_stub() ? true : false;
+}
+
+#endif // SHARE_RUNTIME_STUBROUTINES_INLINE_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/thread.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/thread.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/thread.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/thread.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -315,6 +315,8 @@ Thread::Thread() {
   if (barrier_set != NULL) {
     barrier_set->on_thread_create(this);
   }
+
+  DEBUG_ONLY(_wx_init = false);
 }
 
 void Thread::initialize_thread_current() {
@@ -368,6 +370,8 @@ void Thread::call_run() {
 
   register_thread_stack_with_NMT();
 
+  this->init_wx();
+
   JFR_ONLY(Jfr::on_thread_start(this);)
 
   log_debug(os, thread)("Thread " UINTX_FORMAT " stack dimensions: "
@@ -2528,6 +2532,8 @@ void JavaThread::check_safepoint_and_sus
 // Note only the native==>VM/Java barriers can call this function and when
 // thread state is _thread_in_native_trans.
 void JavaThread::check_special_condition_for_native_trans(JavaThread *thread) {
+  Thread::WXWriteFromExecSetter wx_write;
+
   check_safepoint_and_suspend_for_native_trans(thread);
 
   if (thread->has_async_exception()) {
@@ -2547,6 +2553,8 @@ void JavaThread::check_special_condition
 void JavaThread::check_special_condition_for_native_trans_and_transition(JavaThread *thread) {
   check_special_condition_for_native_trans(thread);
 
+  Thread::WXWriteFromExecSetter wx_write;
+
   // Finish the transition
   thread->set_thread_state(_thread_in_Java);
 
@@ -2612,7 +2620,7 @@ void JavaThread::create_stack_guard_page
   } else {
     log_warning(os, thread)("Attempt to protect stack guard pages failed ("
       PTR_FORMAT "-" PTR_FORMAT ").", p2i(low_addr), p2i(low_addr + len));
-    if (os::uncommit_memory((char *) low_addr, len)) {
+    if (os::uncommit_memory((char *) low_addr, len, !ExecMem)) {
       log_warning(os, thread)("Attempt to deallocate stack guard pages failed.");
     }
     return;
@@ -3665,6 +3673,8 @@ jint Threads::create_vm(JavaVMInitArgs* 
   // Initialize the os module
   os::init();
 
+  os::current_thread_enable_wx(WXWrite);
+
   // Record VM creation timing statistics
   TraceVmCreationTime create_vm_timer;
   create_vm_timer.start();
@@ -3768,6 +3778,7 @@ jint Threads::create_vm(JavaVMInitArgs* 
   main_thread->record_stack_base_and_size();
   main_thread->register_thread_stack_with_NMT();
   main_thread->set_active_handles(JNIHandleBlock::allocate_block());
+  main_thread->init_wx();
 
   if (!main_thread->set_as_starting_thread()) {
     vm_shutdown_during_initialization(
@@ -4187,6 +4198,7 @@ void Threads::shutdown_vm_agents() {
     if (unload_entry != NULL) {
       JavaThread* thread = JavaThread::current();
       ThreadToNativeFromVM ttn(thread);
+      Thread::WXExecFromWriteSetter wx_exec;
       HandleMark hm(thread);
       (*unload_entry)(&main_vm);
     }
@@ -4206,6 +4218,7 @@ void Threads::create_vm_init_libraries()
       // Invoke the JVM_OnLoad function
       JavaThread* thread = JavaThread::current();
       ThreadToNativeFromVM ttn(thread);
+      Thread::WXExecFromWriteSetter wx_exec;
       HandleMark hm(thread);
       jint err = (*on_load_entry)(&main_vm, agent->options(), NULL);
       if (err != JNI_OK) {
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/thread.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/thread.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/thread.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/thread.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -751,6 +751,81 @@ protected:
   static void muxAcquire(volatile intptr_t * Lock, const char * Name);
   static void muxAcquireW(volatile intptr_t * Lock, ParkEvent * ev);
   static void muxRelease(volatile intptr_t * Lock);
+
+private:
+#ifdef ASSERT
+  bool _wx_init;
+  WXMode _wx_state;
+  static inline void verify_wx_init(WXMode state) {
+    Thread* current = Thread::current();
+    assert(!current->_wx_init, "second init");
+    current->_wx_init = true;
+    current->_wx_state = state;
+  }
+  static inline void verify_wx_transition(WXMode from, WXMode to) {
+    Thread* current = Thread::current();
+    assert(current->_wx_init, "no init");
+    assert(current->_wx_state == from, "wrong state");
+    current->_wx_init = true;
+    current->_wx_state = to;
+  }
+  static inline void verify_wx_state(WXMode now) {
+    Thread* current = Thread::current();
+    assert(current->_wx_init, "no init");
+    assert(current->_wx_state == now, "wrong state");
+  }
+#else
+  static inline void verify_wx_init(WXMode state) { }
+  static inline void verify_wx_transition(WXMode from, WXMode to) { }
+  static inline void verify_wx_state(WXMode now) { }
+#endif // ASSERT
+public:
+  void init_wx() {
+    WXMode init_mode = WXWrite;
+    verify_wx_init(init_mode);
+    os::current_thread_enable_wx(init_mode);
+  }
+  static inline void enable_wx_from_write(WXMode to) {
+    verify_wx_transition(WXWrite, to);
+    os::current_thread_enable_wx(to);
+  }
+  static inline void enable_wx_from_exec(WXMode to) {
+    verify_wx_transition(WXExec, to);
+    os::current_thread_enable_wx(to);
+  }
+
+  class WXWriteFromExecSetter {
+  public:
+    WXWriteFromExecSetter() {
+      enable_wx_from_exec(WXWrite);
+    }
+    ~WXWriteFromExecSetter() {
+      enable_wx_from_write(WXExec);
+    }
+  };
+
+  class WXExecFromWriteSetter {
+  public:
+    WXExecFromWriteSetter() {
+      enable_wx_from_write(WXExec);
+    }
+    ~WXExecFromWriteSetter() {
+      enable_wx_from_exec(WXWrite);
+    }
+  };
+
+  class WXWriteVerifier {
+  public:
+    WXWriteVerifier() {
+      verify_wx_state(WXWrite);
+    }
+  };
+  class WXExecVerifier {
+  public:
+    WXExecVerifier() {
+      verify_wx_state(WXExec);
+    }
+  };
 };
 
 // Inline implementation of Thread::current()
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/vm_version.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/vm_version.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/vm_version.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/vm_version.cpp	2021-01-16 16:08:21.000000000 +0100
@@ -25,294 +25,8 @@
 #include "precompiled.hpp"
 #include "logging/log.hpp"
 #include "logging/logStream.hpp"
-#include "memory/universe.hpp"
-#include "oops/oop.inline.hpp"
-#include "runtime/arguments.hpp"
 #include "runtime/vm_version.hpp"
 
-const char* Abstract_VM_Version::_s_vm_release = Abstract_VM_Version::vm_release();
-const char* Abstract_VM_Version::_s_internal_vm_info_string = Abstract_VM_Version::internal_vm_info_string();
-
-uint64_t Abstract_VM_Version::_features = 0;
-const char* Abstract_VM_Version::_features_string = "";
-
-bool Abstract_VM_Version::_supports_cx8 = false;
-bool Abstract_VM_Version::_supports_atomic_getset4 = false;
-bool Abstract_VM_Version::_supports_atomic_getset8 = false;
-bool Abstract_VM_Version::_supports_atomic_getadd4 = false;
-bool Abstract_VM_Version::_supports_atomic_getadd8 = false;
-unsigned int Abstract_VM_Version::_logical_processors_per_package = 1U;
-unsigned int Abstract_VM_Version::_L1_data_cache_line_size = 0;
-
-VirtualizationType Abstract_VM_Version::_detected_virtualization = NoDetectedVirtualization;
-
-#ifndef HOTSPOT_VERSION_STRING
-  #error HOTSPOT_VERSION_STRING must be defined
-#endif
-
-#ifndef VERSION_FEATURE
-  #error VERSION_FEATURE must be defined
-#endif
-#ifndef VERSION_INTERIM
-  #error VERSION_INTERIM must be defined
-#endif
-#ifndef VERSION_UPDATE
-  #error VERSION_UPDATE must be defined
-#endif
-#ifndef VERSION_PATCH
-  #error VERSION_PATCH must be defined
-#endif
-#ifndef VERSION_BUILD
-  #error VERSION_BUILD must be defined
-#endif
-
-#ifndef VERSION_STRING
-  #error VERSION_STRING must be defined
-#endif
-
-#ifndef DEBUG_LEVEL
-  #error DEBUG_LEVEL must be defined
-#endif
-
-#define VM_RELEASE HOTSPOT_VERSION_STRING
-
-// HOTSPOT_VERSION_STRING equals the JDK VERSION_STRING (unless overridden
-// in a standalone build).
-int Abstract_VM_Version::_vm_major_version = VERSION_FEATURE;
-int Abstract_VM_Version::_vm_minor_version = VERSION_INTERIM;
-int Abstract_VM_Version::_vm_security_version = VERSION_UPDATE;
-int Abstract_VM_Version::_vm_patch_version = VERSION_PATCH;
-int Abstract_VM_Version::_vm_build_number = VERSION_BUILD;
-unsigned int Abstract_VM_Version::_parallel_worker_threads = 0;
-bool Abstract_VM_Version::_parallel_worker_threads_initialized = false;
-
-#if defined(_LP64)
-  #define VMLP "64-Bit "
-#else
-  #define VMLP ""
-#endif
-
-#ifndef VMTYPE
-  #ifdef TIERED
-    #define VMTYPE "Server"
-  #else // TIERED
-  #ifdef ZERO
-    #define VMTYPE "Zero"
-  #else // ZERO
-     #define VMTYPE COMPILER1_PRESENT("Client")   \
-                    COMPILER2_PRESENT("Server")
-  #endif // ZERO
-  #endif // TIERED
-#endif
-
-#ifndef HOTSPOT_VM_DISTRO
-  #error HOTSPOT_VM_DISTRO must be defined
-#endif
-#define VMNAME HOTSPOT_VM_DISTRO " " VMLP VMTYPE " VM"
-
-const char* Abstract_VM_Version::vm_name() {
-  return VMNAME;
-}
-
-
-const char* Abstract_VM_Version::vm_vendor() {
-#ifdef VENDOR
-  return VENDOR;
-#else
-  return "Oracle Corporation";
-#endif
-}
-
-
-const char* Abstract_VM_Version::vm_info_string() {
-  switch (Arguments::mode()) {
-    case Arguments::_int:
-      return UseSharedSpaces ? "interpreted mode, sharing" : "interpreted mode";
-    case Arguments::_mixed:
-      if (UseSharedSpaces) {
-        if (UseAOT) {
-          return "mixed mode, aot, sharing";
-#ifdef TIERED
-        } else if(is_client_compilation_mode_vm()) {
-          return "mixed mode, emulated-client, sharing";
-#endif
-        } else {
-          return "mixed mode, sharing";
-         }
-      } else {
-        if (UseAOT) {
-          return "mixed mode, aot";
-#ifdef TIERED
-        } else if(is_client_compilation_mode_vm()) {
-          return "mixed mode, emulated-client";
-#endif
-        } else {
-          return "mixed mode";
-        }
-      }
-    case Arguments::_comp:
-#ifdef TIERED
-      if (is_client_compilation_mode_vm()) {
-         return UseSharedSpaces ? "compiled mode, emulated-client, sharing" : "compiled mode, emulated-client";
-      }
-#endif
-      return UseSharedSpaces ? "compiled mode, sharing"    : "compiled mode";
-  };
-  ShouldNotReachHere();
-  return "";
-}
-
-// NOTE: do *not* use stringStream. this function is called by
-//       fatal error handler. if the crash is in native thread,
-//       stringStream cannot get resource allocated and will SEGV.
-const char* Abstract_VM_Version::vm_release() {
-  return VM_RELEASE;
-}
-
-// NOTE: do *not* use stringStream. this function is called by
-//       fatal error handlers. if the crash is in native thread,
-//       stringStream cannot get resource allocated and will SEGV.
-const char* Abstract_VM_Version::jre_release_version() {
-  return VERSION_STRING;
-}
-
-#define OS       LINUX_ONLY("linux")             \
-                 WINDOWS_ONLY("windows")         \
-                 SOLARIS_ONLY("solaris")         \
-                 AIX_ONLY("aix")                 \
-                 BSD_ONLY("bsd")
-
-#ifndef CPU
-#ifdef ZERO
-#define CPU      ZERO_LIBARCH
-#elif defined(PPC64)
-#if defined(VM_LITTLE_ENDIAN)
-#define CPU      "ppc64le"
-#else
-#define CPU      "ppc64"
-#endif // PPC64
-#else
-#define CPU      AARCH64_ONLY("aarch64")         \
-                 AMD64_ONLY("amd64")             \
-                 IA32_ONLY("x86")                \
-                 IA64_ONLY("ia64")               \
-                 S390_ONLY("s390")               \
-                 SPARC_ONLY("sparc")
-#endif // !ZERO
-#endif // !CPU
-
-const char *Abstract_VM_Version::vm_platform_string() {
-  return OS "-" CPU;
-}
-
-const char* Abstract_VM_Version::internal_vm_info_string() {
-  #ifndef HOTSPOT_BUILD_USER
-    #define HOTSPOT_BUILD_USER unknown
-  #endif
-
-  #ifndef HOTSPOT_BUILD_COMPILER
-    #ifdef _MSC_VER
-      #if _MSC_VER == 1600
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 10.0 (VS2010)"
-      #elif _MSC_VER == 1700
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 11.0 (VS2012)"
-      #elif _MSC_VER == 1800
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 12.0 (VS2013)"
-      #elif _MSC_VER == 1900
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 14.0 (VS2015)"
-      #elif _MSC_VER == 1911
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 15.3 (VS2017)"
-      #elif _MSC_VER == 1912
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 15.5 (VS2017)"
-      #elif _MSC_VER == 1913
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 15.6 (VS2017)"
-      #elif _MSC_VER == 1914
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 15.7 (VS2017)"
-      #elif _MSC_VER == 1915
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 15.8 (VS2017)"
-      #elif _MSC_VER == 1916
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 15.9 (VS2017)"
-      #elif _MSC_VER == 1920
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 16.0 (VS2019)"
-      #elif _MSC_VER == 1921
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 16.1 (VS2019)"
-      #elif _MSC_VER == 1922
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 16.2 (VS2019)"
-      #elif _MSC_VER == 1923
-        #define HOTSPOT_BUILD_COMPILER "MS VC++ 16.3 (VS2019)"
-      #else
-        #define HOTSPOT_BUILD_COMPILER "unknown MS VC++:" XSTR(_MSC_VER)
-      #endif
-    #elif defined(__SUNPRO_CC)
-      #if   __SUNPRO_CC == 0x420
-        #define HOTSPOT_BUILD_COMPILER "Workshop 4.2"
-      #elif __SUNPRO_CC == 0x500
-        #define HOTSPOT_BUILD_COMPILER "Workshop 5.0 compat=" XSTR(__SUNPRO_CC_COMPAT)
-      #elif __SUNPRO_CC == 0x520
-        #define HOTSPOT_BUILD_COMPILER "Workshop 5.2 compat=" XSTR(__SUNPRO_CC_COMPAT)
-      #elif __SUNPRO_CC == 0x580
-        #define HOTSPOT_BUILD_COMPILER "Workshop 5.8"
-      #elif __SUNPRO_CC == 0x590
-        #define HOTSPOT_BUILD_COMPILER "Workshop 5.9"
-      #elif __SUNPRO_CC == 0x5100
-        #define HOTSPOT_BUILD_COMPILER "Sun Studio 12u1"
-      #elif __SUNPRO_CC == 0x5120
-        #define HOTSPOT_BUILD_COMPILER "Sun Studio 12u3"
-      #elif __SUNPRO_CC == 0x5130
-        #define HOTSPOT_BUILD_COMPILER "Sun Studio 12u4"
-      #else
-        #define HOTSPOT_BUILD_COMPILER "unknown Workshop:" XSTR(__SUNPRO_CC)
-      #endif
-    #elif defined(__GNUC__)
-        #define HOTSPOT_BUILD_COMPILER "gcc " __VERSION__
-    #elif defined(__IBMCPP__)
-        #define HOTSPOT_BUILD_COMPILER "xlC " XSTR(__IBMCPP__)
-
-    #else
-      #define HOTSPOT_BUILD_COMPILER "unknown compiler"
-    #endif
-  #endif
-
-  #ifndef FLOAT_ARCH
-    #if defined(__SOFTFP__)
-      #define FLOAT_ARCH_STR "-sflt"
-    #else
-      #define FLOAT_ARCH_STR ""
-    #endif
-  #else
-    #define FLOAT_ARCH_STR XSTR(FLOAT_ARCH)
-  #endif
-
-  #define INTERNAL_VERSION_SUFFIX VM_RELEASE ")" \
-         " for " OS "-" CPU FLOAT_ARCH_STR \
-         " JRE (" VERSION_STRING "), built on " __DATE__ " " __TIME__ \
-         " by " XSTR(HOTSPOT_BUILD_USER) " with " HOTSPOT_BUILD_COMPILER
-
-  return strcmp(DEBUG_LEVEL, "release") == 0
-      ? VMNAME " (" INTERNAL_VERSION_SUFFIX
-      : VMNAME " (" DEBUG_LEVEL " " INTERNAL_VERSION_SUFFIX;
-}
-
-const char *Abstract_VM_Version::vm_build_user() {
-  return HOTSPOT_BUILD_USER;
-}
-
-const char *Abstract_VM_Version::jdk_debug_level() {
-  return DEBUG_LEVEL;
-}
-
-const char *Abstract_VM_Version::printable_jdk_debug_level() {
-  // Debug level is not printed for "release" builds
-  return strcmp(DEBUG_LEVEL, "release") == 0 ? "" : DEBUG_LEVEL " ";
-}
-
-unsigned int Abstract_VM_Version::jvm_version() {
-  return ((Abstract_VM_Version::vm_major_version() & 0xFF) << 24) |
-         ((Abstract_VM_Version::vm_minor_version() & 0xFF) << 16) |
-         ((Abstract_VM_Version::vm_security_version() & 0xFF) << 8) |
-         (Abstract_VM_Version::vm_build_number() & 0xFF);
-}
-
 void VM_Version_init() {
   VM_Version::initialize();
 
@@ -323,79 +37,3 @@ void VM_Version_init() {
     os::print_cpu_info(&ls, buf, sizeof(buf));
   }
 }
-
-bool Abstract_VM_Version::print_matching_lines_from_file(const char* filename, outputStream* st, const char* keywords_to_match[]) {
-  char line[500];
-  FILE* fp = fopen(filename, "r");
-  if (fp == NULL) {
-    return false;
-  }
-
-  st->print_cr("Virtualization information:");
-  while (fgets(line, sizeof(line), fp) != NULL) {
-    int i = 0;
-    while (keywords_to_match[i] != NULL) {
-      if (strncmp(line, keywords_to_match[i], strlen(keywords_to_match[i])) == 0) {
-        st->print("%s", line);
-        break;
-      }
-      i++;
-    }
-  }
-  fclose(fp);
-  return true;
-}
-
-
-
-unsigned int Abstract_VM_Version::nof_parallel_worker_threads(
-                                                      unsigned int num,
-                                                      unsigned int den,
-                                                      unsigned int switch_pt) {
-  if (FLAG_IS_DEFAULT(ParallelGCThreads)) {
-    assert(ParallelGCThreads == 0, "Default ParallelGCThreads is not 0");
-    unsigned int threads;
-    // For very large machines, there are diminishing returns
-    // for large numbers of worker threads.  Instead of
-    // hogging the whole system, use a fraction of the workers for every
-    // processor after the first 8.  For example, on a 72 cpu machine
-    // and a chosen fraction of 5/8
-    // use 8 + (72 - 8) * (5/8) == 48 worker threads.
-    unsigned int ncpus = (unsigned int) os::initial_active_processor_count();
-    threads = (ncpus <= switch_pt) ?
-             ncpus :
-             (switch_pt + ((ncpus - switch_pt) * num) / den);
-#ifndef _LP64
-    // On 32-bit binaries the virtual address space available to the JVM
-    // is usually limited to 2-3 GB (depends on the platform).
-    // Do not use up address space with too many threads (stacks and per-thread
-    // data). Note that x86 apps running on Win64 have 2 stacks per thread.
-    // GC may more generally scale down threads by max heap size (etc), but the
-    // consequences of over-provisioning threads are higher on 32-bit JVMS,
-    // so add hard limit here:
-    threads = MIN2(threads, (2*switch_pt));
-#endif
-    return threads;
-  } else {
-    return ParallelGCThreads;
-  }
-}
-
-unsigned int Abstract_VM_Version::calc_parallel_worker_threads() {
-  return nof_parallel_worker_threads(5, 8, 8);
-}
-
-
-// Does not set the _initialized flag since it is
-// a global flag.
-unsigned int Abstract_VM_Version::parallel_worker_threads() {
-  if (!_parallel_worker_threads_initialized) {
-    if (FLAG_IS_DEFAULT(ParallelGCThreads)) {
-      _parallel_worker_threads = VM_Version::calc_parallel_worker_threads();
-    } else {
-      _parallel_worker_threads = ParallelGCThreads;
-    }
-    _parallel_worker_threads_initialized = true;
-  }
-  return _parallel_worker_threads;
-}
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/vm_version.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/vm_version.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/runtime/vm_version.hpp      2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/runtime/vm_version.hpp      2021-01-16 15:56:28.000000000 +0100
@@ -22,170 +22,10 @@
  *
  */
 
-#ifndef SHARE_VM_RUNTIME_VM_VERSION_HPP
-#define SHARE_VM_RUNTIME_VM_VERSION_HPP
-
-#include "memory/allocation.hpp"
-#include "utilities/ostream.hpp"
-#include "utilities/macros.hpp"
-
-typedef enum {
-  NoDetectedVirtualization,
-  XenHVM,
-  KVM,
-  VMWare,
-  HyperV,
-  HyperVRole,
-  PowerVM, // on AIX or Linux ppc64(le)
-  PowerFullPartitionMode, // on Linux ppc64(le)
-  PowerKVM
-} VirtualizationType;
-
-// VM_Version provides information about the VM.
-
-class Abstract_VM_Version: AllStatic {
-  friend class VMStructs;
-  friend class JVMCIVMStructs;
-
- protected:
-  static const char*  _s_vm_release;
-  static const char*  _s_internal_vm_info_string;
-
-  // CPU feature flags.
-  static uint64_t _features;
-  static const char* _features_string;
-
-  // These are set by machine-dependent initializations
-  static bool         _supports_cx8;
-  static bool         _supports_atomic_getset4;
-  static bool         _supports_atomic_getset8;
-  static bool         _supports_atomic_getadd4;
-  static bool         _supports_atomic_getadd8;
-  static unsigned int _logical_processors_per_package;
-  static unsigned int _L1_data_cache_line_size;
-  static int          _vm_major_version;
-  static int          _vm_minor_version;
-  static int          _vm_security_version;
-  static int          _vm_patch_version;
-  static int          _vm_build_number;
-
-  static VirtualizationType _detected_virtualization;
-
-  static unsigned int _parallel_worker_threads;
-  static bool         _parallel_worker_threads_initialized;
-
-  static unsigned int nof_parallel_worker_threads(unsigned int num,
-                                                  unsigned int dem,
-                                                  unsigned int switch_pt);
- public:
-  // Called as part of the runtime services initialization which is
-  // called from the management module initialization (via init_globals())
-  // after argument parsing and attaching of the main thread has
-  // occurred.  Examines a variety of the hardware capabilities of
-  // the platform to determine which features can be used to execute the
-  // program.
-  static void initialize();
-
-  // This allows for early initialization of VM_Version information
-  // that may be needed later in the initialization sequence but before
-  // full VM_Version initialization is possible. It can not depend on any
-  // other part of the VM being initialized when called. Platforms that
-  // need to specialize this define VM_Version::early_initialize().
-  static void early_initialize() { }
-
-  // Called to initialize VM variables needing initialization
-  // after command line parsing. Platforms that need to specialize
-  // this should define VM_Version::init_before_ergo().
-  static void init_before_ergo() {}
-
-  // Name
-  static const char* vm_name();
-  // Vendor
-  static const char* vm_vendor();
-  // VM version information string printed by launcher (java -version)
-  static const char* vm_info_string();
-  static const char* vm_release();
-  static const char* vm_platform_string();
-  static const char* vm_build_user();
-
-  static int vm_major_version()               { return _vm_major_version; }
-  static int vm_minor_version()               { return _vm_minor_version; }
-  static int vm_security_version()            { return _vm_security_version; }
-  static int vm_patch_version()               { return _vm_patch_version; }
-  static int vm_build_number()                { return _vm_build_number; }
-
-  // Gets the jvm_version_info.jvm_version defined in jvm.h
-  static unsigned int jvm_version();
-
-  // Internal version providing additional build information
-  static const char* internal_vm_info_string();
-  static const char* jre_release_version();
-  static const char* jdk_debug_level();
-  static const char* printable_jdk_debug_level();
-
-  static uint64_t features() {
-    return _features;
-  }
-
-  static const char* features_string() {
-    return _features_string;
-  }
-
-  static VirtualizationType get_detected_virtualization() {
-    return _detected_virtualization;
-  }
-
-  // platforms that need to specialize this
-  // define VM_Version::print_platform_virtualization_info()
-  static void print_platform_virtualization_info(outputStream*) { }
-
-  // does HW support an 8-byte compare-exchange operation?
-  static bool supports_cx8()  {
-#ifdef SUPPORTS_NATIVE_CX8
-    return true;
-#else
-    return _supports_cx8;
-#endif
-  }
-  // does HW support atomic get-and-set or atomic get-and-add?  Used
-  // to guide intrinsification decisions for Unsafe atomic ops
-  static bool supports_atomic_getset4()  {return _supports_atomic_getset4;}
-  static bool supports_atomic_getset8()  {return _supports_atomic_getset8;}
-  static bool supports_atomic_getadd4()  {return _supports_atomic_getadd4;}
-  static bool supports_atomic_getadd8()  {return _supports_atomic_getadd8;}
-
-  static unsigned int logical_processors_per_package() {
-    return _logical_processors_per_package;
-  }
-
-  static unsigned int L1_data_cache_line_size() {
-    return _L1_data_cache_line_size;
-  }
-
-  // ARCH specific policy for the BiasedLocking
-  static bool use_biased_locking()  { return true; }
-
-  // Number of page sizes efficiently supported by the hardware.  Most chips now
-  // support two sizes, thus this default implementation.  Processor-specific
-  // subclasses should define new versions to hide this one as needed.  Note
-  // that the O/S may support more sizes, but at most this many are used.
-  static uint page_size_count() { return 2; }
-
-  // Returns the number of parallel threads to be used for VM
-  // work.  If that number has not been calculated, do so and
-  // save it.  Returns ParallelGCThreads if it is set on the
-  // command line.
-  static unsigned int parallel_worker_threads();
-  // Calculates and returns the number of parallel threads.  May
-  // be VM version specific.
-  static unsigned int calc_parallel_worker_threads();
-
-  // Does this CPU support spin wait instruction?
-  static bool supports_on_spin_wait() { return false; }
-
-  static bool print_matching_lines_from_file(const char* filename, outputStream* st, const char* keywords_to_match[]);
-};
-
+#ifndef SHARE_RUNTIME_VM_VERSION_HPP
+#define SHARE_RUNTIME_VM_VERSION_HPP
+
+#include "utilities/macros.hpp"  // for CPU_HEADER() macro.
 #include CPU_HEADER(vm_version)
 
-#endif // SHARE_VM_RUNTIME_VM_VERSION_HPP
+#endif // SHARE_RUNTIME_VM_VERSION_HPP
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/services/diagnosticCommand.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/services/diagnosticCommand.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/services/diagnosticCommand.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/services/diagnosticCommand.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -1084,6 +1084,7 @@ void DebugOnCmdStartDCmd::execute(DCmdSo
   JavaThread* thread = (JavaThread*) THREAD;
   jthread jt = JNIHandles::make_local(thread->threadObj());
   ThreadToNativeFromVM ttn(thread);
+  Thread::WXExecFromWriteSetter wx_exec;
   const char *error = "Could not find jdwp agent.";
 
   if (!dvc_start_ptr) {
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/utilities/globalDefinitions_gcc.hpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/utilities/globalDefinitions_gcc.hpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/utilities/globalDefinitions_gcc.hpp	2021-01-16 15:56:28.000000000 +0100
@@ -218,8 +218,8 @@ inline int g_isnan(double f) { return is
 
 // Checking for finiteness
 
-inline int g_isfinite(jfloat  f)                 { return finite(f); }
-inline int g_isfinite(jdouble f)                 { return finite(f); }
+inline int g_isfinite(jfloat  f)                 { return isfinite(f); }
+inline int g_isfinite(jdouble f)                 { return isfinite(f); }
 
 
 // Wide characters
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/utilities/nativeCallStack.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/utilities/nativeCallStack.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/utilities/nativeCallStack.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/utilities/nativeCallStack.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -36,9 +36,9 @@ NativeCallStack::NativeCallStack(int toS
   if (fillStack) {
     // We need to skip the NativeCallStack::NativeCallStack frame if a tail call is NOT used
     // to call os::get_native_stack. A tail call is used if _NMT_NOINLINE_ is not defined
-    // (which means this is not a slowdebug build), and we are on 64-bit (except Windows).
-    // This is not necessarily a rule, but what has been obvserved to date.
-#if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64))
+    // (which means this is not a slowdebug build), and we are on 64-bit (except Windows
+    // and MacOS-aarch64). This is not necessarily a rule, but what has been obvserved to date.
+#if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64) || (defined(BSD) && defined (__aarch64__)))
     // Not a tail call.
     toSkip++;
 #if (defined(_NMT_NOINLINE_) && defined(BSD) && defined(_LP64))
diff -Npur jdk11u-jdk-11.0.9-ga/src/hotspot/share/utilities/vmError.cpp jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/utilities/vmError.cpp
--- jdk11u-jdk-11.0.9-ga/src/hotspot/share/utilities/vmError.cpp	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/hotspot/share/utilities/vmError.cpp	2021-01-16 15:56:28.000000000 +0100
@@ -37,6 +37,8 @@
 #include "runtime/frame.inline.hpp"
 #include "runtime/init.hpp"
 #include "runtime/os.hpp"
+#include "runtime/safepointMechanism.hpp"
+#include "runtime/stubRoutines.inline.hpp"
 #include "runtime/thread.inline.hpp"
 #include "runtime/threadSMR.hpp"
 #include "runtime/vmThread.hpp"
diff -Npur jdk11u-jdk-11.0.9-ga/src/java.base/macosx/native/libjava/java_props_macosx.c jdk11u-jdk-11.0.9-ga-patched/src/java.base/macosx/native/libjava/java_props_macosx.c
--- jdk11u-jdk-11.0.9-ga/src/java.base/macosx/native/libjava/java_props_macosx.c	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/java.base/macosx/native/libjava/java_props_macosx.c	2021-01-16 15:56:28.000000000 +0100
@@ -256,11 +256,16 @@ void setOSNameAndVersion(java_props_t *s
 
     char* osVersionCStr = NULL;
     // Mac OS 10.9 includes the [NSProcessInfo operatingSystemVersion] function,
-    // but it's not in the 10.9 SDK.  So, call it via objc_msgSend_stret.
+    // but it's not in the 10.9 SDK.  So, call it via NSInvocation.
     if ([[NSProcessInfo processInfo] respondsToSelector:@selector(operatingSystemVersion)]) {
-        OSVerStruct (*procInfoFn)(id rec, SEL sel) = (OSVerStruct(*)(id, SEL))objc_msgSend_stret;
-        OSVerStruct osVer = procInfoFn([NSProcessInfo processInfo],
-                                       @selector(operatingSystemVersion));
+	OSVerStruct osVer;
+	NSMethodSignature *sig = [[NSProcessInfo processInfo] methodSignatureForSelector:
+		@selector(operatingSystemVersion)];
+	NSInvocation *invoke = [NSInvocation invocationWithMethodSignature:sig];
+	invoke.selector = @selector(operatingSystemVersion);
+	[invoke invokeWithTarget:[NSProcessInfo processInfo]];
+	[invoke getReturnValue:&osVer];
+
         NSString *nsVerStr;
         if (osVer.patchVersion == 0) { // Omit trailing ".0"
             nsVerStr = [NSString stringWithFormat:@"%ld.%ld",
diff -Npur jdk11u-jdk-11.0.9-ga/src/java.base/macosx/native/libjli/java_md_macosx.c jdk11u-jdk-11.0.9-ga-patched/src/java.base/macosx/native/libjli/java_md_macosx.c
--- jdk11u-jdk-11.0.9-ga/src/java.base/macosx/native/libjli/java_md_macosx.c	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/java.base/macosx/native/libjli/java_md_macosx.c	2021-01-16 15:56:28.000000000 +0100
@@ -210,6 +210,8 @@ static InvocationFunctions *GetExportedJ
         preferredJVM = "client";
 #elif defined(__x86_64__)
         preferredJVM = "server";
+#elif defined(__aarch64__)
+        preferredJVM = "server";
 #else
 #error "Unknown architecture - needs definition"
 #endif
diff -Npur jdk11u-jdk-11.0.9-ga/src/java.desktop/macosx/native/libawt_lwawt/awt/AWTView.m jdk11u-jdk-11.0.9-ga-patched/src/java.desktop/macosx/native/libawt_lwawt/awt/AWTView.m
--- jdk11u-jdk-11.0.9-ga/src/java.desktop/macosx/native/libawt_lwawt/awt/AWTView.m	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/java.desktop/macosx/native/libawt_lwawt/awt/AWTView.m	2021-01-16 16:09:29.000000000 +0100
@@ -31,7 +31,6 @@
 #import "JavaTextAccessibility.h"
 #import "JavaAccessibilityUtilities.h"
 #import "GeomUtilities.h"
-#import "OSVersion.h"
 #import "ThreadUtilities.h"
 
 #import <Carbon/Carbon.h>
@@ -53,10 +52,7 @@
 //#define EXTRA_DEBUG
 
 static BOOL shouldUsePressAndHold() {
-    static int shouldUsePressAndHold = -1;
-    if (shouldUsePressAndHold != -1) return shouldUsePressAndHold;
-    shouldUsePressAndHold = !isSnowLeopardOrLower();
-    return shouldUsePressAndHold;
+    return YES;
 }
 
 @implementation AWTView
diff -Npur jdk11u-jdk-11.0.9-ga/src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.h jdk11u-jdk-11.0.9-ga-patched/src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.h
--- jdk11u-jdk-11.0.9-ga/src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.h	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +0,0 @@
-/*
- * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-// Support for detecting Mac OS X versions
-
-double getOSXMajorVersion();
-BOOL isSnowLeopardOrLower();
diff -Npur jdk11u-jdk-11.0.9-ga/src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.m jdk11u-jdk-11.0.9-ga-patched/src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.m
--- jdk11u-jdk-11.0.9-ga/src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.m	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/java.desktop/macosx/native/libawt_lwawt/awt/OSVersion.m	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-// Support for detecting Mac OS X Versions
-
-#include <math.h>
-#include <stdlib.h>
-#include <stdio.h>
-#import <JavaRuntimeSupport/JavaRuntimeSupport.h>
-
-
-// returns 107 for Lion, 106 for SnowLeopard etc.
-int getOSXMajorVersion() {
-    char *ver = JRSCopyOSVersion();
-    if (ver == NULL) { 
-        return 0;
-    }
-
-    int len = strlen(ver);
-    int v = 0;
-    
-    // Third char must be a '.'    
-    if (len >= 3 && ver[2] == '.') {
-        int i;
-        
-        v = (ver[0] - '0') * 10 + (ver[1] - '0');
-        for (i = 3; i < len && isdigit(ver[i]); ++i) {
-            v = v * 10 + (ver[i] - '0');
-        }
-    }
-
-    free(ver);
-    
-    return v;
-}
-
-BOOL isSnowLeopardOrLower() {
-    return (getOSXMajorVersion() < 107);
-}
diff -Npur jdk11u-jdk-11.0.9-ga/src/java.security.jgss/share/native/libj2gss/gssapi.h jdk11u-jdk-11.0.9-ga-patched/src/java.security.jgss/share/native/libj2gss/gssapi.h
--- jdk11u-jdk-11.0.9-ga/src/java.security.jgss/share/native/libj2gss/gssapi.h	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/java.security.jgss/share/native/libj2gss/gssapi.h	2021-01-16 15:56:38.000000000 +0100
@@ -43,10 +43,9 @@
 extern "C" {
 #endif /* __cplusplus */
 
-#if TARGET_OS_MAC
+#if TARGET_OS_MAC && (defined(__ppc__) || defined(__ppc64__) || defined(__i386__) || defined(__x86_64__))
 #    pragma pack(push,2)
 #endif
-
 /*
  * First, include stddef.h to get size_t defined.
  */
@@ -682,7 +681,7 @@ GSS_DLLIMP OM_uint32 gss_canonicalize_na
         gss_name_t *            /* output_name */
 );
 
-#if TARGET_OS_MAC
+#if TARGET_OS_MAC && (defined(__ppc__) || defined(__ppc64__) || defined(__i386__) || defined(__x86_64__))
 #    pragma pack(pop)
 #endif
 
diff -Npur jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m
--- jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m	2021-01-16 15:56:38.000000000 +0100
@@ -46,12 +46,10 @@
 
 #define UNSUPPORTED_ARCH "Unsupported architecture!"
 
-#if defined(x86_64) && !defined(amd64)
-#define amd64 1
-#endif
-
-#if amd64
+#if defined(amd64)
 #include "sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h"
+#elif defined(aarch64)
+#include "sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext.h"
 #else
 #error UNSUPPORTED_ARCH
 #endif
@@ -178,6 +176,13 @@ static struct ps_prochandle* get_proc_ha
     #define HSDB_FLOAT_STATE        x86_FLOAT_STATE64
     #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE64_COUNT
     #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE64_COUNT
+#elif defined(__aarch64__)
+    #define hsdb_thread_state_t     arm_thread_state64_t
+    #define hsdb_float_state_t      arm_neon_state64_t
+    #define HSDB_THREAD_STATE       ARM_THREAD_STATE64
+    #define HSDB_FLOAT_STATE        ARM_NEON_STATE64
+    #define HSDB_THREAD_STATE_COUNT ARM_THREAD_STATE64_COUNT
+    #define HSDB_FLOAT_STATE_COUNT  ARM_NEON_STATE64_COUNT
 #else
     #error UNSUPPORTED_ARCH
 #endif
@@ -461,11 +466,21 @@ bool fill_java_threads(JNIEnv* env, jobj
       lwpid_t  uid = cinfos[j];
       uint64_t beg = cinfos[j + 1];
       uint64_t end = cinfos[j + 2];
+#if defined(amd64)
       if ((regs.r_rsp < end && regs.r_rsp >= beg) ||
           (regs.r_rbp < end && regs.r_rbp >= beg)) {
         set_lwp_id(ph, i, uid);
         break;
       }
+#elif defined(aarch64)
+      if ((regs.r_sp < end && regs.r_sp >= beg) ||
+          (regs.r_fp < end && regs.r_fp >= beg)) {
+        set_lwp_id(ph, i, uid);
+        break;
+      }
+#else
+#error UNSUPPORTED_ARCH
+#endif
     }
   }
   (*env)->ReleaseLongArrayElements(env, thrinfos, (jlong*)cinfos, 0);
@@ -497,7 +512,7 @@ jlongArray getThreadIntegerRegisterSetFr
 
 #undef NPRGREG
 #undef REG_INDEX
-#if amd64
+#if defined(amd64)
 #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
 
@@ -533,7 +548,46 @@ jlongArray getThreadIntegerRegisterSetFr
   regs[REG_INDEX(TRAPNO)] = gregs.r_trapno;
   regs[REG_INDEX(RFL)]    = gregs.r_rflags;
 
-#endif /* amd64 */
+#elif defined(aarch64)
+#define NPRGREG sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_NPRGREG
+#define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg
+  array = (*env)->NewLongArray(env, NPRGREG);
+  CHECK_EXCEPTION_(0);
+  regs = (*env)->GetLongArrayElements(env, array, &isCopy);
+
+  regs[REG_INDEX(R28)] = gregs.r_r28;
+  regs[REG_INDEX(R27)] = gregs.r_r27;
+  regs[REG_INDEX(R26)] = gregs.r_r26;
+  regs[REG_INDEX(R25)] = gregs.r_r25;
+  regs[REG_INDEX(R24)] = gregs.r_r24;
+  regs[REG_INDEX(R23)] = gregs.r_r23;
+  regs[REG_INDEX(R22)] = gregs.r_r22;
+  regs[REG_INDEX(R21)] = gregs.r_r21;
+  regs[REG_INDEX(R20)] = gregs.r_r20;
+  regs[REG_INDEX(R19)] = gregs.r_r19;
+  regs[REG_INDEX(R17)] = gregs.r_r17;
+  regs[REG_INDEX(R16)] = gregs.r_r16;
+  regs[REG_INDEX(R15)] = gregs.r_r15;
+  regs[REG_INDEX(R14)] = gregs.r_r14;
+  regs[REG_INDEX(R13)] = gregs.r_r13;
+  regs[REG_INDEX(R12)] = gregs.r_r12;
+  regs[REG_INDEX(R11)] = gregs.r_r11;
+  regs[REG_INDEX(R10)] = gregs.r_r10;
+  regs[REG_INDEX(R9)]  = gregs.r_r9;
+  regs[REG_INDEX(R8)]  = gregs.r_r8;
+  regs[REG_INDEX(R7)]  = gregs.r_r7;
+  regs[REG_INDEX(R6)]  = gregs.r_r6;
+  regs[REG_INDEX(R5)]  = gregs.r_r5;
+  regs[REG_INDEX(R4)]  = gregs.r_r4;
+  regs[REG_INDEX(R3)]  = gregs.r_r3;
+  regs[REG_INDEX(R2)]  = gregs.r_r2;
+  regs[REG_INDEX(R1)]  = gregs.r_r1;
+  regs[REG_INDEX(R0)]  = gregs.r_r0;
+  regs[REG_INDEX(FP)]  = gregs.r_fp;
+  regs[REG_INDEX(SP)]  = gregs.r_sp;
+  regs[REG_INDEX(PC)]  = gregs.r_pc;
+
+#endif /* aarch64 */
   (*env)->ReleaseLongArrayElements(env, array, regs, JNI_COMMIT);
   return array;
 }
@@ -623,7 +677,7 @@ Java_sun_jvm_hotspot_debugger_bsd_BsdDeb
     return NULL;
   }
 
-#if amd64
+#if defined(amd64)
 #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
 #undef REG_INDEX
 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
@@ -666,6 +720,53 @@ Java_sun_jvm_hotspot_debugger_bsd_BsdDeb
 
   (*env)->ReleaseLongArrayElements(env, registerArray, primitiveArray, 0);
 
+#elif defined(aarch64)
+#define NPRGREG sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_NPRGREG
+#undef REG_INDEX
+#define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg
+  // 64 bit
+  print_debug("Getting threads for a 64-bit process\n");
+  registerArray = (*env)->NewLongArray(env, NPRGREG);
+  CHECK_EXCEPTION_(0);
+  primitiveArray = (*env)->GetLongArrayElements(env, registerArray, NULL);
+
+
+  primitiveArray[REG_INDEX(R28)] = state.__x[28];
+  primitiveArray[REG_INDEX(R27)] = state.__x[27];
+  primitiveArray[REG_INDEX(R26)] = state.__x[26];
+  primitiveArray[REG_INDEX(R25)] = state.__x[25];
+  primitiveArray[REG_INDEX(R24)] = state.__x[24];
+  primitiveArray[REG_INDEX(R23)] = state.__x[23];
+  primitiveArray[REG_INDEX(R22)] = state.__x[22];
+  primitiveArray[REG_INDEX(R21)] = state.__x[21];
+  primitiveArray[REG_INDEX(R20)] = state.__x[20];
+  primitiveArray[REG_INDEX(R19)] = state.__x[19];
+  primitiveArray[REG_INDEX(R17)] = state.__x[17];
+  primitiveArray[REG_INDEX(R16)] = state.__x[16];
+  primitiveArray[REG_INDEX(R15)] = state.__x[15];
+  primitiveArray[REG_INDEX(R14)] = state.__x[14];
+  primitiveArray[REG_INDEX(R13)] = state.__x[13];
+  primitiveArray[REG_INDEX(R12)] = state.__x[12];
+  primitiveArray[REG_INDEX(R11)] = state.__x[11];
+  primitiveArray[REG_INDEX(R10)] = state.__x[10];
+  primitiveArray[REG_INDEX(R9)]  = state.__x[9];
+  primitiveArray[REG_INDEX(R8)]  = state.__x[8];
+  primitiveArray[REG_INDEX(R7)]  = state.__x[7];
+  primitiveArray[REG_INDEX(R6)]  = state.__x[6];
+  primitiveArray[REG_INDEX(R5)]  = state.__x[5];
+  primitiveArray[REG_INDEX(R4)]  = state.__x[4];
+  primitiveArray[REG_INDEX(R3)]  = state.__x[3];
+  primitiveArray[REG_INDEX(R2)]  = state.__x[2];
+  primitiveArray[REG_INDEX(R1)]  = state.__x[1];
+  primitiveArray[REG_INDEX(R0)]  = state.__x[0];
+  primitiveArray[REG_INDEX(SP)]  = state.__sp;
+  primitiveArray[REG_INDEX(SP)]  = state.__fp;
+  primitiveArray[REG_INDEX(PC)]  = state.__pc;
+
+  print_debug("set registers\n");
+
+  (*env)->ReleaseLongArrayElements(env, registerArray, primitiveArray, 0);
+
 #else
 #error UNSUPPORTED_ARCH
 #endif /* amd64 */
diff -Npur jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h
--- jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/macosx/native/libsaproc/libproc_impl.h	2021-01-16 15:56:38.000000000 +0100
@@ -39,8 +39,16 @@
 
 #ifndef register_t
 #define register_t uint64_t
+#if defined(x86_64) && !defined(amd64)
+#define amd64 1
 #endif
 
+#if defined(__aarch64__) && !defined(aarch64)
+#define aarch64 1
+#endif
+#endif
+
+#if defined(amd64)
 /*** registers copied from bsd/amd64 */
 typedef struct reg {
   register_t      r_r15;
@@ -71,6 +79,42 @@ typedef struct reg {
   register_t      r_ss;          // not used
 } reg;
 
+#elif defined(aarch64)
+typedef struct reg {
+  register_t      r_r28;
+  register_t      r_r27;
+  register_t      r_r26;
+  register_t      r_r25;
+  register_t      r_r24;
+  register_t      r_r23;
+  register_t      r_r22;
+  register_t      r_r21;
+  register_t      r_r20;
+  register_t      r_r19;
+  register_t      r_r18;
+  register_t      r_r17;
+  register_t      r_r16;
+  register_t      r_r15;
+  register_t      r_r14;
+  register_t      r_r13;
+  register_t      r_r12;
+  register_t      r_r11;
+  register_t      r_r10;
+  register_t      r_r9;
+  register_t      r_r8;
+  register_t      r_r7;
+  register_t      r_r6;
+  register_t      r_r5;
+  register_t      r_r4;
+  register_t      r_r3;
+  register_t      r_r2;
+  register_t      r_r1;
+  register_t      r_r0;
+  register_t      r_fp;
+  register_t      r_sp;
+  register_t      r_pc;
+} reg;
+#endif
 // convenient defs
 typedef struct mach_header_64 mach_header_64;
 typedef struct load_command load_command;
diff -Npur jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c
--- jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c	2021-01-16 15:56:38.000000000 +0100
@@ -31,8 +31,16 @@
 #include "libproc_impl.h"
 #include "cds.h"
 
-#ifdef __APPLE__
+#define UNSUPPORTED_ARCH "Unsupported architecture!"
+
+#if defined(__APPLE__)
+#if defined(aarch64)
+#include "sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext.h"
+#elif defined(amd64)
 #include "sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h"
+#else
+#error UNSUPPORTED_ARCH
+#endif
 #endif
 
 // This file has the libproc implementation to read core files.
@@ -517,6 +525,7 @@ static ps_prochandle_ops core_ops = {
 
 #ifdef __APPLE__
 
+#if defined (amd64)
 void print_thread(sa_thread_info *threadinfo) {
   print_debug("thread added: %d\n", threadinfo->lwp_id);
   print_debug("registers:\n");
@@ -542,7 +551,45 @@ void print_thread(sa_thread_info *thread
   print_debug("  r_rsp: 0x%" PRIx64 "\n", threadinfo->regs.r_rsp);
   print_debug("  r_rflags: 0x%" PRIx64 "\n", threadinfo->regs.r_rflags);
 }
-
+#elif defined(aarch64)
+void print_thread(sa_thread_info *threadinfo) {
+  print_debug("thread added: %d\n", threadinfo->lwp_id);
+  print_debug("registers:\n");
+  print_debug("  r_r28: 0x%" PRIx64 "\n", threadinfo->regs.r_r28);
+  print_debug("  r_r27: 0x%" PRIx64 "\n", threadinfo->regs.r_r27);
+  print_debug("  r_r26: 0x%" PRIx64 "\n", threadinfo->regs.r_r26);
+  print_debug("  r_r25: 0x%" PRIx64 "\n", threadinfo->regs.r_r25);
+  print_debug("  r_r24: 0x%" PRIx64 "\n", threadinfo->regs.r_r24);
+  print_debug("  r_r23: 0x%" PRIx64 "\n", threadinfo->regs.r_r23);
+  print_debug("  r_r22: 0x%" PRIx64 "\n", threadinfo->regs.r_r22);
+  print_debug("  r_r21: 0x%" PRIx64 "\n", threadinfo->regs.r_r21);
+  print_debug("  r_r20: 0x%" PRIx64 "\n", threadinfo->regs.r_r20);
+  print_debug("  r_r19: 0x%" PRIx64 "\n", threadinfo->regs.r_r19);
+  print_debug("  r_r17: 0x%" PRIx64 "\n", threadinfo->regs.r_r17);
+  print_debug("  r_r16: 0x%" PRIx64 "\n", threadinfo->regs.r_r16);
+  print_debug("  r_r15: 0x%" PRIx64 "\n", threadinfo->regs.r_r15);
+  print_debug("  r_r14: 0x%" PRIx64 "\n", threadinfo->regs.r_r14);
+  print_debug("  r_r13: 0x%" PRIx64 "\n", threadinfo->regs.r_r13);
+  print_debug("  r_r12: 0x%" PRIx64 "\n", threadinfo->regs.r_r12);
+  print_debug("  r_r11: 0x%" PRIx64 "\n", threadinfo->regs.r_r11);
+  print_debug("  r_r10: 0x%" PRIx64 "\n", threadinfo->regs.r_r10);
+  print_debug("  r_r9:  0x%" PRIx64 "\n", threadinfo->regs.r_r9);
+  print_debug("  r_r8:  0x%" PRIx64 "\n", threadinfo->regs.r_r8);
+  print_debug("  r_r7:  0x%" PRIx64 "\n", threadinfo->regs.r_r7);
+  print_debug("  r_r6:  0x%" PRIx64 "\n", threadinfo->regs.r_r6);
+  print_debug("  r_r5:  0x%" PRIx64 "\n", threadinfo->regs.r_r5);
+  print_debug("  r_r4:  0x%" PRIx64 "\n", threadinfo->regs.r_r4);
+  print_debug("  r_r3:  0x%" PRIx64 "\n", threadinfo->regs.r_r3);
+  print_debug("  r_r2:  0x%" PRIx64 "\n", threadinfo->regs.r_r2);
+  print_debug("  r_r1:  0x%" PRIx64 "\n", threadinfo->regs.r_r1);
+  print_debug("  r_r0:  0x%" PRIx64 "\n", threadinfo->regs.r_r0);
+  print_debug("  r_fp:  0x%" PRIx64 "\n", threadinfo->regs.r_fp);
+  print_debug("  r_sp:  0x%" PRIx64 "\n", threadinfo->regs.r_sp);
+  print_debug("  r_pc:  0x%" PRIx64 "\n", threadinfo->regs.r_pc);
+}
+#else
+#error UNSUPPORTED_ARCH
+#endif
 // read all segments64 commands from core file
 // read all thread commands from core file
 static bool read_core_segments(struct ps_prochandle* ph) {
@@ -592,6 +639,7 @@ static bool read_core_segments(struct ps
           goto err;
         }
         size += sizeof(thread_fc);
+#if defined(amd64)
         if (fc.flavor == x86_THREAD_STATE) {
           x86_thread_state_t thrstate;
           if (read(fd, (void *)&thrstate, sizeof(x86_thread_state_t)) != sizeof(x86_thread_state_t)) {
@@ -651,6 +699,71 @@ static bool read_core_segments(struct ps
           }
           size += sizeof(x86_exception_state_t);
         }
+#elif defined(aarch64)
+        if (fc.flavor == ARM_THREAD_STATE64) {
+          arm_thread_state64_t thrstate;
+          if (read(fd, (void *)&thrstate, sizeof(arm_thread_state64_t)) != sizeof(arm_thread_state64_t)) {
+            printf("Reading flavor, count failed.\n");
+            goto err;
+          }
+          size += sizeof(arm_thread_state64_t);
+          // create thread info list, update lwp_id later
+          sa_thread_info* newthr = add_thread_info(ph, (pthread_t) -1, (lwpid_t) num_threads++);
+          if (newthr == NULL) {
+            printf("create thread_info failed\n");
+            goto err;
+          }
+
+          newthr->regs.r_r0 = thrstate.__x[0];
+          newthr->regs.r_r1 = thrstate.__x[1];
+          newthr->regs.r_r2 = thrstate.__x[2];
+          newthr->regs.r_r3 = thrstate.__x[3];
+          newthr->regs.r_r4 = thrstate.__x[4];
+          newthr->regs.r_r5 = thrstate.__x[5];
+          newthr->regs.r_r6 = thrstate.__x[6];
+          newthr->regs.r_r7 = thrstate.__x[7];
+          newthr->regs.r_r8  = thrstate.__x[8];
+          newthr->regs.r_r9  = thrstate.__x[9];
+          newthr->regs.r_r10 = thrstate.__x[10];
+          newthr->regs.r_r11 = thrstate.__x[11];
+          newthr->regs.r_r12 = thrstate.__x[12];
+          newthr->regs.r_r13 = thrstate.__x[13];
+          newthr->regs.r_r14 = thrstate.__x[14];
+          newthr->regs.r_r15 = thrstate.__x[15];
+          newthr->regs.r_r16 = thrstate.__x[16];
+          newthr->regs.r_r17 = thrstate.__x[17];
+          newthr->regs.r_r19 = thrstate.__x[19];
+          newthr->regs.r_r20 = thrstate.__x[20];
+          newthr->regs.r_r21 = thrstate.__x[21];
+          newthr->regs.r_r22 = thrstate.__x[22];
+          newthr->regs.r_r23 = thrstate.__x[23];
+          newthr->regs.r_r24 = thrstate.__x[24];
+          newthr->regs.r_r25 = thrstate.__x[25];
+          newthr->regs.r_r26 = thrstate.__x[26];
+          newthr->regs.r_r27 = thrstate.__x[27];
+          newthr->regs.r_r28 = thrstate.__x[28];
+          newthr->regs.r_pc  = thrstate.__pc;
+          newthr->regs.r_fp  = thrstate.__fp;
+          newthr->regs.r_sp  = thrstate.__sp;
+          print_thread(newthr);
+        } else if (fc.flavor == ARM_NEON_STATE64) {
+          arm_neon_state64_t flstate;
+          if (read(fd, (void *)&flstate, sizeof(arm_neon_state64_t)) != sizeof(arm_neon_state64_t)) {
+            print_debug("Reading flavor, count failed.\n");
+            goto err;
+          }
+          size += sizeof(arm_neon_state64_t);
+        } else if (fc.flavor == ARM_EXCEPTION_STATE64) {
+          arm_exception_state64_t excpstate;
+          if (read(fd, (void *)&excpstate, sizeof(arm_exception_state64_t)) != sizeof(arm_exception_state64_t)) {
+            printf("Reading flavor, count failed.\n");
+            goto err;
+          }
+          size += sizeof(arm_exception_state64_t);
+        }
+#else
+#error UNSUPPORTED_ARCH
+#endif
       }
     }
   }
diff -Npur jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java
--- jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java	2021-01-16 15:56:38.000000000 +0100
@@ -650,8 +650,10 @@ public class HotSpotAgent {
 
         if (cpu.equals("amd64") || cpu.equals("x86_64")) {
             machDesc = new MachineDescriptionAMD64();
+        } else if (cpu.equals("aarch64")) {
+            machDesc = new MachineDescriptionAArch64();
         } else {
-            throw new DebuggerException("Darwin only supported on x86_64. Current arch: " + cpu);
+            throw new DebuggerException("Darwin only supported on x86_64 and aarch64. Current arch: " + cpu);
         }
 
         BsdDebuggerLocal dbg = new BsdDebuggerLocal(machDesc, !isServer);
diff -Npur jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/asm/Disassembler.java jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/asm/Disassembler.java
--- jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/asm/Disassembler.java	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/asm/Disassembler.java	2021-01-16 15:56:38.000000000 +0100
@@ -100,7 +100,11 @@ public class Disassembler {
             }
          } else if (os.lastIndexOf("Mac OS X", 0) != -1) {
             path.append(sep + "lib" + sep);
-            libname += "-amd64" + ".dylib";       // x86_64 => amd64
+            if (arch.equals("amd64") || arch.equals("x86_64")) {
+               libname += "-amd64" + ".dylib";       // x86_64 => amd64
+            } else {
+               libname += "-" + arch + ".dylib";
+            }
          } else {
             path.append(sep + "lib" + sep + "arch" + sep);
             libname +=  "-" + arch + ".so";
diff -Npur jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java
--- jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java	2021-01-16 15:56:38.000000000 +0100
@@ -30,8 +30,10 @@ import sun.jvm.hotspot.debugger.*;
 import sun.jvm.hotspot.debugger.cdbg.*;
 import sun.jvm.hotspot.debugger.x86.*;
 import sun.jvm.hotspot.debugger.amd64.*;
+import sun.jvm.hotspot.debugger.aarch64.*;
 import sun.jvm.hotspot.debugger.bsd.x86.*;
 import sun.jvm.hotspot.debugger.bsd.amd64.*;
+import sun.jvm.hotspot.debugger.bsd.aarch64.*;
 import sun.jvm.hotspot.utilities.*;
 
 class BsdCDebugger implements CDebugger {
@@ -97,6 +99,13 @@ class BsdCDebugger implements CDebugger 
        Address pc  = context.getRegisterAsAddress(AMD64ThreadContext.RIP);
        if (pc == null) return null;
        return new BsdAMD64CFrame(dbg, rbp, pc);
+    } else if (cpu.equals("aarch64")) {
+       AARCH64ThreadContext context = (AARCH64ThreadContext) thread.getContext();
+       Address fp = context.getRegisterAsAddress(AARCH64ThreadContext.FP);
+       if (fp == null) return null;
+       Address pc  = context.getRegisterAsAddress(AARCH64ThreadContext.PC);
+       if (pc == null) return null;
+       return new BsdAARCH64CFrame(dbg, fp, pc);
     } else {
        throw new DebuggerException(cpu + " is not yet supported");
     }
diff -Npur jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java
--- jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java	2021-01-16 15:56:38.000000000 +0100
@@ -27,6 +27,7 @@ package sun.jvm.hotspot.debugger.bsd;
 import sun.jvm.hotspot.debugger.*;
 import sun.jvm.hotspot.debugger.bsd.amd64.*;
 import sun.jvm.hotspot.debugger.bsd.x86.*;
+import sun.jvm.hotspot.debugger.bsd.aarch64.*;
 
 class BsdThreadContextFactory {
    static ThreadContext createThreadContext(BsdDebugger dbg) {
@@ -35,6 +36,8 @@ class BsdThreadContextFactory {
          return new BsdX86ThreadContext(dbg);
       } else if (cpu.equals("amd64") || cpu.equals("x86_64")) {
          return new BsdAMD64ThreadContext(dbg);
+      } else if (cpu.equals("aarch64")) {
+         return new BsdAARCH64ThreadContext(dbg);
       } else {
          throw new RuntimeException("cpu " + cpu + " is not yet supported");
       }
diff -Npur jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java
--- jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64CFrame.java	2021-01-16 16:04:27.000000000 +0100
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Red Hat Inc.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.debugger.bsd.aarch64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.aarch64.*;
+import sun.jvm.hotspot.debugger.bsd.*;
+import sun.jvm.hotspot.debugger.cdbg.*;
+import sun.jvm.hotspot.debugger.cdbg.basic.*;
+
+final public class BsdAARCH64CFrame extends BasicCFrame {
+   public BsdAARCH64CFrame(BsdDebugger dbg, Address fp, Address pc) {
+      super(dbg.getCDebugger());
+      this.fp = fp;
+      this.pc = pc;
+      this.dbg = dbg;
+   }
+
+   // override base class impl to avoid ELF parsing
+   public ClosestSymbol closestSymbolToPC() {
+      // try native lookup in debugger.
+      return dbg.lookup(dbg.getAddressValue(pc()));
+   }
+
+   public Address pc() {
+      return pc;
+   }
+
+   public Address localVariableBase() {
+      return fp;
+   }
+
+   public CFrame sender(ThreadProxy thread) {
+      AARCH64ThreadContext context = (AARCH64ThreadContext) thread.getContext();
+      Address rsp = context.getRegisterAsAddress(AARCH64ThreadContext.SP);
+
+      if ((fp == null) || fp.lessThan(rsp)) {
+        return null;
+      }
+
+      // Check alignment of fp
+      if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {
+        return null;
+      }
+
+      Address nextFP = fp.getAddressAt(0 * ADDRESS_SIZE);
+      if (nextFP == null || nextFP.lessThanOrEqual(fp)) {
+        return null;
+      }
+      Address nextPC  = fp.getAddressAt(1 * ADDRESS_SIZE);
+      if (nextPC == null) {
+        return null;
+      }
+      return new BsdAARCH64CFrame(dbg, nextFP, nextPC);
+   }
+
+   // package/class internals only
+   private static final int ADDRESS_SIZE = 8;
+   private Address pc;
+   private Address sp;
+   private Address fp;
+   private BsdDebugger dbg;
+}
diff -Npur jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java
--- jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/bsd/aarch64/BsdAARCH64ThreadContext.java	2021-01-16 16:04:27.000000000 +0100
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Red Hat Inc.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.debugger.bsd.aarch64;
+
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.aarch64.*;
+import sun.jvm.hotspot.debugger.bsd.*;
+
+public class BsdAARCH64ThreadContext extends AARCH64ThreadContext {
+  private BsdDebugger debugger;
+
+  public BsdAARCH64ThreadContext(BsdDebugger debugger) {
+    super();
+    this.debugger = debugger;
+  }
+
+  public void setRegisterAsAddress(int index, Address value) {
+    setRegister(index, debugger.getAddressValue(value));
+  }
+
+  public Address getRegisterAsAddress(int index) {
+    return debugger.newAddress(getRegister(index));
+  }
+}
diff -Npur jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java
--- jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java	2020-09-11 18:12:45.000000000 +0200
+++ jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/Threads.java	2021-01-16 15:56:38.000000000 +0100
@@ -40,6 +40,7 @@ import sun.jvm.hotspot.runtime.linux_ppc
 import sun.jvm.hotspot.runtime.linux_sparc.LinuxSPARCJavaThreadPDAccess;
 import sun.jvm.hotspot.runtime.bsd_x86.BsdX86JavaThreadPDAccess;
 import sun.jvm.hotspot.runtime.bsd_amd64.BsdAMD64JavaThreadPDAccess;
+import sun.jvm.hotspot.runtime.bsd_aarch64.BsdAARCH64JavaThreadPDAccess;
 import sun.jvm.hotspot.utilities.*;
 
 public class Threads {
@@ -115,6 +116,9 @@ public class Threads {
             if (cpu.equals("amd64") || cpu.equals("x86_64")) {
                 access = new BsdAMD64JavaThreadPDAccess();
             }
+            if (cpu.equals("aarch64")) {
+                access = new BsdAARCH64JavaThreadPDAccess();
+            }
         }
 
         if (access == null) {
diff -Npur jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java
--- jdk11u-jdk-11.0.9-ga/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java	1970-01-01 01:00:00.000000000 +0100
+++ jdk11u-jdk-11.0.9-ga-patched/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/bsd_aarch64/BsdAARCH64JavaThreadPDAccess.java	2021-01-16 16:04:28.000000000 +0100
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, Red Hat Inc.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package sun.jvm.hotspot.runtime.bsd_aarch64;
+
+import java.io.*;
+import java.util.*;
+import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.aarch64.*;
+import sun.jvm.hotspot.debugger.bsd.BsdDebugger;
+import sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal;
+import sun.jvm.hotspot.runtime.*;
+import sun.jvm.hotspot.runtime.aarch64.*;
+import sun.jvm.hotspot.types.*;
+import sun.jvm.hotspot.utilities.*;
+
+public class BsdAARCH64JavaThreadPDAccess implements JavaThreadPDAccess {
+  private static AddressField  lastJavaFPField;
+  private static AddressField  osThreadField;
+
+  // Field from OSThread
+  private static CIntegerField osThreadThreadIDField;
+  private static CIntegerField osThreadUniqueThreadIDField;
+
+  // This is currently unneeded but is being kept in case we change
+  // the currentFrameGuess algorithm
+  private static final long GUESS_SCAN_RANGE = 128 * 1024;
+
+  static {
+    VM.registerVMInitializedObserver(new Observer() {
+        public void update(Observable o, Object data) {
+          initialize(VM.getVM().getTypeDataBase());
+        }
+      });
+  }
+
+  private static synchronized void initialize(TypeDataBase db) {
+    Type type = db.lookupType("JavaThread");
+    osThreadField           = type.getAddressField("_osthread");
+
+    Type anchorType = db.lookupType("JavaFrameAnchor");
+    lastJavaFPField         = anchorType.getAddressField("_last_Java_fp");
+
+    Type osThreadType = db.lookupType("OSThread");
+    osThreadThreadIDField   = osThreadType.getCIntegerField("_thread_id");
+    osThreadUniqueThreadIDField = osThreadType.getCIntegerField("_unique_thread_id");
+  }
+
+  public Address getLastJavaFP(Address addr) {
+    return lastJavaFPField.getValue(addr.addOffsetTo(sun.jvm.hotspot.runtime.JavaThread.getAnchorField().getOffset()));
+  }
+
+  public Address getLastJavaPC(Address addr) {
+    return null;
+  }
+
+  public Address getBaseOfStackPointer(Address addr) {
+    return null;
+  }
+
+  public Frame getLastFramePD(JavaThread thread, Address addr) {
+    Address fp = thread.getLastJavaFP();
+    if (fp == null) {
+      return null; // no information
+    }
+    return new AARCH64Frame(thread.getLastJavaSP(), fp);
+  }
+
+  public RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {
+    return new AARCH64RegisterMap(thread, updateMap);
+  }
+
+  public Frame getCurrentFrameGuess(JavaThread thread, Address addr) {
+    ThreadProxy t = getThreadProxy(addr);
+    AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();
+    AARCH64CurrentFrameGuess guesser = new AARCH64CurrentFrameGuess(context, thread);
+    if (!guesser.run(GUESS_SCAN_RANGE)) {
+      return null;
+    }
+    if (guesser.getPC() == null) {
+      return new AARCH64Frame(guesser.getSP(), guesser.getFP());
+    } else {
+      return new AARCH64Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());
+    }
+  }
+
+  public void printThreadIDOn(Address addr, PrintStream tty) {
+    tty.print(getThreadProxy(addr));
+  }
+
+  public void printInfoOn(Address threadAddr, PrintStream tty) {
+    tty.print("Thread id: ");
+    printThreadIDOn(threadAddr, tty);
+//    tty.println("\nPostJavaState: " + getPostJavaState(threadAddr));
+  }
+
+  public Address getLastSP(Address addr) {
+    ThreadProxy t = getThreadProxy(addr);
+    AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();
+    return context.getRegisterAsAddress(AARCH64ThreadContext.SP);
+  }
+
+  public ThreadProxy getThreadProxy(Address addr) {
+    // Addr is the address of the JavaThread.
+    // Fetch the OSThread (for now and for simplicity, not making a
+    // separate "OSThread" class in this package)
+    Address osThreadAddr = osThreadField.getValue(addr);
+    // Get the address of the _thread_id from the OSThread
+    Address threadIdAddr = osThreadAddr.addOffsetTo(osThreadThreadIDField.getOffset());
+    Address uniqueThreadIdAddr = osThreadAddr.addOffsetTo(osThreadUniqueThreadIDField.getOffset());
+
+    BsdDebuggerLocal debugger = (BsdDebuggerLocal) VM.getVM().getDebugger();
+    return debugger.getThreadForIdentifierAddress(threadIdAddr, uniqueThreadIdAddr);
+  }
+}
